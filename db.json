{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/lx/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/lx/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/lx/source/css/main.min.css","path":"css/main.min.css","modified":1,"renderable":1},{"_id":"themes/lx/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/lx/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/cover.jpeg","path":"images/cover.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/footer-l.jpeg","path":"images/footer-l.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/footer-r.jpeg","path":"images/footer-r.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/post_cover.jpeg","path":"images/post_cover.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/lx/source/js/jquery.easing.min.js","path":"js/jquery.easing.min.js","modified":1,"renderable":1},{"_id":"themes/lx/source/js/jquery.jside.menu.js","path":"js/jquery.jside.menu.js","modified":1,"renderable":1},{"_id":"themes/lx/source/js/local.search.js","path":"js/local.search.js","modified":1,"renderable":1},{"_id":"themes/lx/source/css/menu/button.styl","path":"css/menu/button.styl","modified":1,"renderable":1},{"_id":"themes/lx/source/css/menu/menu.styl","path":"css/menu/menu.styl","modified":1,"renderable":1},{"_id":"themes/lx/source/css/page_style/page_style.styl","path":"css/page_style/page_style.styl","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map.md","hash":"cf7376ed00a86b53719a318bcd0a48d12850a4df","modified":1629434042003},{"_id":"source/_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）.md","hash":"dbef6f52464383651f21e16fb358767cf5d05a80","modified":1629435320385},{"_id":"source/_posts/微信小程序：灵活适配不同标题栏高度的设备的方法.md","hash":"4b789df6dc42a261169f39240a460dc168bbd582","modified":1629435240795},{"_id":"source/_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）.md","hash":"cef3507a18693f5b4bcb2ddb0dc8c87a5d316671","modified":1629435329062},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg","hash":"2ad76c60d6d8f172555f45575da3bad866542aa2","modified":1629433329257},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png","hash":"ebab7bc8a320818e31d5952bec8009dc6abc14d1","modified":1629434328404},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png","hash":"c370ef1ff1e4458fcbf83ffe9802dfaccf193e2c","modified":1629432458846},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png","hash":"4324dcf04b74152be6de70860e3e1ee7cbe34953","modified":1629433944754},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/compare.png","hash":"710314ce886d5ca0e1c125b2f8d5197a70d4e998","modified":1629431961765},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png","hash":"c8abdb84d9c33272d5b815b72cec98adf467b2ad","modified":1629434333259},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png","hash":"0824bb0d2d6bb43a0028fafd26395aedb5bc2c27","modified":1629432457037},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png","hash":"bdf83f353affd7055761dd54d46f6e509aa8fe36","modified":1629431967787},{"_id":"themes/lx/.editorconfig","hash":"f8102695960fe708149c2e21934969700bfb0031","modified":1627294956000},{"_id":"themes/lx/.gitignore","hash":"05277dd213f5ca95847c7aef888ff8255a772418","modified":1627294956000},{"_id":"themes/lx/CODE_OF_CONDUCT.md","hash":"4faa826cb7049aff196edbf38e0b29c3fec2cf17","modified":1627294956000},{"_id":"themes/lx/CONTRIBUTING.md","hash":"c70e994eb59d431ccaaf8b114ad74c8962cc3f45","modified":1627294956000},{"_id":"themes/lx/LICENSE","hash":"2e43fe50cb85afda5cbd30aa4c056125f0e11a53","modified":1627294956000},{"_id":"themes/lx/README.md","hash":"6c8ff3355df92a0e7e6e789be59c8c0d2349fef3","modified":1627294956000},{"_id":"themes/lx/_config.yml","hash":"cf7a9424444f063e8aca412de5a3f88015def5ef","modified":1629451389429},{"_id":"themes/lx/.github/FUNDING.yml","hash":"21bed4e222cde27dc5875bfe39ce76165d519d71","modified":1627294956000},{"_id":"themes/lx/package.json","hash":"172d7956f0d7d35afc599fbc733f1d2224380820","modified":1627294956000},{"_id":"themes/lx/README/README.zh.md","hash":"5a28ec8f12503656d7a7df848f1f787e05127b0a","modified":1627294956000},{"_id":"themes/lx/languages/en.yml","hash":"ec59da08e7c8dc61872b7896f167e42491965b2e","modified":1627294956000},{"_id":"themes/lx/languages/zh.yml","hash":"b9a174e46bd89df7d6bf3a7863c350a62dce8a81","modified":1627294956000},{"_id":"themes/lx/layout/archive.ejs","hash":"539ad764457af4434a6764c2044c4bbb9c34759f","modified":1627294956000},{"_id":"themes/lx/layout/index.ejs","hash":"6c73bb34c29861124a0464a9a8dea95adf4fc5b0","modified":1627294956000},{"_id":"themes/lx/layout/layout.ejs","hash":"a8e012724633a45c7601c38866176e11f88b0db9","modified":1627294956000},{"_id":"themes/lx/layout/page.ejs","hash":"c0895bd2b63c5bba7c54686d6b7eaec9fbc520a5","modified":1627294956000},{"_id":"themes/lx/layout/post.ejs","hash":"9396418ae3822ee444f44c509ec27955842c9360","modified":1627294956000},{"_id":"themes/lx/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1627294956000},{"_id":"themes/lx/.github/ISSUE_TEMPLATE/--------feature-request.md","hash":"14c1b9b0234e1930cdcb5effade695dd8ed96378","modified":1627294956000},{"_id":"themes/lx/.github/ISSUE_TEMPLATE/------help-wanted.md","hash":"5d71620c4feb15de44248dc1bbfef0bdb83ff080","modified":1627294956000},{"_id":"themes/lx/.github/ISSUE_TEMPLATE/------bug-bug-report.md","hash":"31d326cf90434637cc1223d1272f3db6913c1bc0","modified":1627294956000},{"_id":"themes/lx/.github/workflows/greetings.yml","hash":"0076edf9d490a7d8695208e0e251ab89cd83064c","modified":1627294956000},{"_id":"themes/lx/layout/partials/aside.ejs","hash":"e9ea462c34f4edba0c62c5478b4a96edb66769ef","modified":1627294956000},{"_id":"themes/lx/layout/partials/config.ejs","hash":"6809577629e67dc00a2b20c2326818fa7f2c29be","modified":1627294956000},{"_id":"themes/lx/layout/partials/font.ejs","hash":"2dc65c0b4f60ed8329a296c5172aee8d42025a1e","modified":1627294956000},{"_id":"themes/lx/layout/partials/footer.ejs","hash":"cada2b375642f0e6485eeaaf023df6c8f4529ded","modified":1627294956000},{"_id":"themes/lx/layout/partials/menu.ejs","hash":"7c3d71999f233f5fb7549a472c922c8257711d5f","modified":1627294956000},{"_id":"themes/lx/layout/partials/pagination.ejs","hash":"82c25643c1e3b16f0472eebfe77f4a03ad0e8824","modified":1627294956000},{"_id":"themes/lx/layout/partials/post-footer.ejs","hash":"a2dbce8103bdc694439e8709c7f636f68ccc3328","modified":1627294956000},{"_id":"themes/lx/layout/partials/post-header.ejs","hash":"bf8fabdac5aec4eae08333058dde46e5094a7cff","modified":1629253480440},{"_id":"themes/lx/layout/partials/recent-posts.ejs","hash":"816079ea6ed78b20a56f32b9025facfb05f4b94d","modified":1629344660943},{"_id":"themes/lx/layout/partials/search.ejs","hash":"e68af7bfc83edcf8da639982e1766c53f129128f","modified":1627294956000},{"_id":"themes/lx/layout/partials/sociallinks.ejs","hash":"4460e06f88084f545b4409685644c7f101d11ba5","modified":1627294956000},{"_id":"themes/lx/layout/third-party/comment.ejs","hash":"f1d1c9425059e76c8481829797de44df637c0723","modified":1627294956000},{"_id":"themes/lx/layout/third-party/mathjax.ejs","hash":"e857f83195594e6ffcacf08f07df0c229806113b","modified":1627294956000},{"_id":"themes/lx/scripts/helpers/font.js","hash":"0e7adebaf7bb3ba516c8f82cf26100237584bf44","modified":1627294956000},{"_id":"themes/lx/scripts/tags/button.js","hash":"dd5da28768a3ed3f2e3b308a9ff220403825579f","modified":1627294956000},{"_id":"themes/lx/scripts/tags/center-quote.js","hash":"e5086a9b99ac1c8006f4fa7c5568b96cc1d47cf6","modified":1627294956000},{"_id":"themes/lx/scripts/tags/label.js","hash":"7247ac0f614993d4d162b14b68e924fc969581f5","modified":1627294956000},{"_id":"themes/lx/scripts/tags/note.js","hash":"19dc88f867d684101e851e25fe9da661c56acc66","modified":1627294956000},{"_id":"themes/lx/scripts/tags/video.js","hash":"3a70f28b9769fd308c8df7d694fb7f896f12ae58","modified":1627294956000},{"_id":"themes/lx/source/css/base.styl","hash":"6e0e60965934ef19bafc2ba3e863830e0b98f4d0","modified":1627294956000},{"_id":"themes/lx/source/css/main.min.css","hash":"20c32e1a93832269ab5c9ed0f9b07c6921a86bea","modified":1628960204348},{"_id":"themes/lx/source/css/main.styl","hash":"f18cf57ab0950b91bd6103933e239ecee34153a8","modified":1628960089947},{"_id":"themes/lx/source/images/avatar.jpeg","hash":"7ce0557fb0cdf3d05e2e3be975d73ea0e6635df6","modified":1627294956000},{"_id":"themes/lx/source/images/footer-l.jpeg","hash":"f036edc5f66ffbcc34c3d855414c6ca5ef30a04b","modified":1627294956000},{"_id":"themes/lx/source/images/footer-r.jpeg","hash":"5c7677ac85cf8a683b91e97702b7096017006b4f","modified":1627294956000},{"_id":"themes/lx/source/images/post_cover.jpeg","hash":"93f216636c87dbbe635d4bb6b944851d92d84723","modified":1627294956000},{"_id":"themes/lx/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1627294956000},{"_id":"themes/lx/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1627294956000},{"_id":"themes/lx/source/js/jquery.easing.min.js","hash":"af83a43279779fbc716f40ba8c5280782027540a","modified":1627294956000},{"_id":"themes/lx/source/js/jquery.jside.menu.js","hash":"d15b40199520d22771f9a211ac4282041df2ae5a","modified":1627294956000},{"_id":"themes/lx/source/js/local.search.js","hash":"3dd788d1e64431feb8faca7a7f175d25ed31f25a","modified":1627294956000},{"_id":"themes/lx/layout/third-party/analytics/baidu-analytics.ejs","hash":"30cf8cd193777b1e071313528e06b16eca508187","modified":1627294956000},{"_id":"themes/lx/layout/third-party/analytics/google-analytics.ejs","hash":"09775c366a01c656b7185ef3da4bc7b33caa2241","modified":1627294956000},{"_id":"themes/lx/layout/third-party/analytics/index.ejs","hash":"c98b574b2634de33694edb40b1f9120160b81acb","modified":1627294956000},{"_id":"themes/lx/source/css/menu/button.styl","hash":"d440d99e13b0f58edcab27bfce4e027e0e54fd77","modified":1627294956000},{"_id":"themes/lx/source/css/menu/menu.styl","hash":"ebe4d6bc7e0081ad4d7659427abb98a1344c1aae","modified":1627294956000},{"_id":"themes/lx/source/css/page_style/page_style.styl","hash":"001a90dacb84f56463c833238f2db947c092505c","modified":1627294956000},{"_id":"themes/lx/source/images/cover.jpeg","hash":"186350a358c03649b83d5501ee43c90b1cc1160e","modified":1627294956000},{"_id":"source/_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）/侧滑效果.gif","hash":"3b489ac4084d6ebd5b1b3de30b7d9d429f777af4","modified":1629278351146},{"_id":"public/sitemap.xml","hash":"0dbdd33659dfcd73d4aa37b981b87eedba7ae948","modified":1629451449754},{"_id":"public/search.xml","hash":"da789e0eb86f812fddf3c61d636ac0fe061e0a4d","modified":1629451449754},{"_id":"public/2021/08/14/微信小程序：灵活适配不同标题栏高度的设备的方法/index.html","hash":"d04162eb114f2f2a6f0f6cffbd6d0a2516b26d04","modified":1629451449754},{"_id":"public/archives/index.html","hash":"961b3e361ee292e8f310d93d99066a4967a88009","modified":1629451449754},{"_id":"public/archives/2021/index.html","hash":"961b3e361ee292e8f310d93d99066a4967a88009","modified":1629451449754},{"_id":"public/archives/2021/08/index.html","hash":"961b3e361ee292e8f310d93d99066a4967a88009","modified":1629451449754},{"_id":"public/categories/JS/index.html","hash":"92eba0bd30fc3b66842adcde1f36c324149da08c","modified":1629451449754},{"_id":"public/categories/JS/算法/index.html","hash":"c7350a14c675fa179b1ed8881993c5a1ca49e9d9","modified":1629451449754},{"_id":"public/categories/微信小程序/index.html","hash":"8b9cc6d44e6038b15b68cd1ecf416aae9687832e","modified":1629451449754},{"_id":"public/index.html","hash":"7404303b7ae16845517c374401af3008c2f4c71d","modified":1629451449754},{"_id":"public/tags/JS/index.html","hash":"f8aed9f343bda9c8762918326555012079cb7dda","modified":1629451449754},{"_id":"public/tags/算法/index.html","hash":"3a00f4f99a392b2a0966fc81acec62ce43ad2c83","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/index.html","hash":"0c7b1c87526f6633334ced80291acf0c36fa64ce","modified":1629451449754},{"_id":"public/2021/08/18/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）/index.html","hash":"094f8a1751c04b440896cde4157e15ef66be1913","modified":1629451449754},{"_id":"public/2021/08/16/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）/index.html","hash":"a3e117b3032085f9799feb863f94d59a97169104","modified":1629451449754},{"_id":"public/tags/fs/index.html","hash":"e5fcbffaccdfa42a427e291db18377e499036b99","modified":1629451449754},{"_id":"public/tags/微信小程序/index.html","hash":"57d5457e57f5afbfedf0559ab15f7a9af3e08ccc","modified":1629451449754},{"_id":"public/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1629451449754},{"_id":"public/images/avatar.jpeg","hash":"7ce0557fb0cdf3d05e2e3be975d73ea0e6635df6","modified":1629451449754},{"_id":"public/images/footer-l.jpeg","hash":"f036edc5f66ffbcc34c3d855414c6ca5ef30a04b","modified":1629451449754},{"_id":"public/images/footer-r.jpeg","hash":"5c7677ac85cf8a683b91e97702b7096017006b4f","modified":1629451449754},{"_id":"public/images/post_cover.jpeg","hash":"93f216636c87dbbe635d4bb6b944851d92d84723","modified":1629451449754},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1629451449754},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg","hash":"2ad76c60d6d8f172555f45575da3bad866542aa2","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png","hash":"ebab7bc8a320818e31d5952bec8009dc6abc14d1","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png","hash":"c370ef1ff1e4458fcbf83ffe9802dfaccf193e2c","modified":1629451449754},{"_id":"public/images/cover.jpeg","hash":"186350a358c03649b83d5501ee43c90b1cc1160e","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png","hash":"4324dcf04b74152be6de70860e3e1ee7cbe34953","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare.png","hash":"710314ce886d5ca0e1c125b2f8d5197a70d4e998","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png","hash":"c8abdb84d9c33272d5b815b72cec98adf467b2ad","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png","hash":"0824bb0d2d6bb43a0028fafd26395aedb5bc2c27","modified":1629451449754},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png","hash":"bdf83f353affd7055761dd54d46f6e509aa8fe36","modified":1629451449754},{"_id":"public/css/base.css","hash":"6d884ebc4f4c1a7c750e4b871ecfff6c28b47ed0","modified":1629451449754},{"_id":"public/js/jquery.easing.min.js","hash":"af83a43279779fbc716f40ba8c5280782027540a","modified":1629451449754},{"_id":"public/js/jquery.jside.menu.js","hash":"688b8b03f8590a05e35a1fbbc59f37bc36051aa1","modified":1629451449754},{"_id":"public/css/menu/button.css","hash":"ce03713a291978281b66ce9d5738c456020a8e61","modified":1629451449754},{"_id":"public/js/local.search.js","hash":"3dd788d1e64431feb8faca7a7f175d25ed31f25a","modified":1629451449754},{"_id":"public/css/menu/menu.css","hash":"70f8a5b346f4b106eebc1c5199bc4add479da3c5","modified":1629451449754},{"_id":"public/css/page_style/page_style.css","hash":"07178b2c270eafa0c21e424663946015bfc08b0e","modified":1629451449754},{"_id":"public/css/main.css","hash":"6918851c41dabfa45fcd46fdc871ed4a08c73109","modified":1629451449754},{"_id":"public/css/main.min.css","hash":"20c32e1a93832269ab5c9ed0f9b07c6921a86bea","modified":1629451449754},{"_id":"public/2021/08/16/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）/侧滑效果.gif","hash":"3b489ac4084d6ebd5b1b3de30b7d9d429f777af4","modified":1629451449754}],"Category":[{"name":"JS","_id":"cksk5blqj0001n0u607bu9ssv"},{"name":"算法","parent":"cksk5blqj0001n0u607bu9ssv","_id":"cksk5blqm0004n0u69rqcfq11"},{"name":"微信小程序","_id":"cksk5blqq000bn0u6g0rh9paj"}],"Data":[],"Page":[],"Post":[{"title":"JS: Union-find(quick-union + weighting + path compression + map)","date":"2021-08-20T01:52:59.000Z","_content":"\n## 简介\n\nUnion-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。\n\n### 用于解决的问题\n\n假定一个学校的圈子中，有A,B,C...这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。\n\n### 核心的方法需求\n\nUnion(p, q): 将点p和点q建立连接的方法。\n\nFind(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。\n\n<!-- more -->\n\n## 基本构建思路\n\n### Quick-Find\n\n这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。\n\n#### 图解\n\n![quick-find图解](qf1.png)\n\n#### Java代码\n\n![quick-find代码](qf2.png)\n\n#### 缺点\n\n如果一条很长的链被合并，可能需要大量地改变root值。\n\n### Quick-Union\n\n这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。\n\n此时使用类似链表的数据结构十分恰当。\n\n#### 图解\n\n![quick-union图解](qu1.png)\n\n#### Java代码\n\n![quick-union代码](qu2.png)\n\n#### 缺点\n\n如果有一条很长的链，查找效率会很低。\n\n### 二者比较\n\n#### 共通点\n\n不管是quick-find还是quick-union，算法中都有这样的共通点：\n\n1.每次union时会判断是否同根，如果是则直接跳过。\n\n2.在进行两个子集的union时，会连接两个子集的root。\n\n#### 时间复杂度比较\n\n![时间复杂度比较](compare.png)\n\n因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。\n\n由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。\n\n## Quick-Union算法的优化\n\n### Map\n\n因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。\n\n结构：{key: id, value: parent_id}\n\n### Weighting\n\nWeighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。\n\n#### 图解\n\n![weighting图解](weighting.png)\n\n#### 代码变动\n\n由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。\n\nmap结构变化: {key: id, value: {parent: parent_id, size: size}}\n\nunion时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身\n\n### Path Compression\n\nPath Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。\n\n#### 图解\n\n![path-compression图解](path-compression.jpg)\n\n## 最终代码\n\nquick-union + weighting + path compression + map\n\n``` javascript Union-Find.js\nconst map = new Map();\nclass Node {\n    //每个节点保存的结构\n    constructor(parent, size){\n        this.parent = parent || null;\n        this.size = size || 0;\n    }\n}\n\nfunction union(p, q){\n    if(!map.has(p)||!map.has(q)){\n        //有一个不在map里，说明是游离节点，自动设为child\n        if(!map.has(p)){\n            var child = p, parent = find(q); //path compression 父母直接设给根节点\n        } else {\n            var child = q, parent = find(p);\n        }\n        map.set(child, new Node(parent, 0));\n    } else {\n        //均存在map中，需要进行weighting的两个节点\n        const pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; //暂存两个节点的root\n        if(pr===qr){\n            //如果已经连通，不需要再连接了\n            return;\n        }\n        if(prs < qrs){\n            //把容量更小的那个设为child被合并\n            var child = pr, parent = qr;\n        } else {\n            var child = qr, parent = pr;\n        }\n        //root应该都存在map中\n        map.get(child).parent = parent;\n    }\n    if(!map.has(parent)){\n        map.set(parent, new Node(parent, map.get(child).size+1)); //map中新建一个root node，root的parent设给自己\n    } else {\n        map.get(parent).size+=map.get(child).size+1; //合并size\n    }\n};\n\nfunction find(p){\n    if(!map.has(p)){\n        return p;\n    }\n    while(map.get(p).parent!=p){\n        //如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent\n        p = map.get(p).parent;\n    }\n    return p;\n};\n\nfunction isConnected(p, q){\n    return (find(p)===find(q));\n}\n```\n\n## 时间复杂度\n\n最后贴上algorithms书中的各种方法的时间复杂度：\n\n![时间复杂度比较](compare-final.png)\n\n有weighting和path compression的quick union时间复杂度无限接近1。","source":"_posts/JS-Union-find-quick-union-weighting-path-compression-map.md","raw":"---\ntitle: 'JS: Union-find(quick-union + weighting + path compression + map)'\ndate: 2021-08-20 09:52:59\ntags: [JS, 算法]\ncategories: [JS, 算法]\n---\n\n## 简介\n\nUnion-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。\n\n### 用于解决的问题\n\n假定一个学校的圈子中，有A,B,C...这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。\n\n### 核心的方法需求\n\nUnion(p, q): 将点p和点q建立连接的方法。\n\nFind(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。\n\n<!-- more -->\n\n## 基本构建思路\n\n### Quick-Find\n\n这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。\n\n#### 图解\n\n![quick-find图解](qf1.png)\n\n#### Java代码\n\n![quick-find代码](qf2.png)\n\n#### 缺点\n\n如果一条很长的链被合并，可能需要大量地改变root值。\n\n### Quick-Union\n\n这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。\n\n此时使用类似链表的数据结构十分恰当。\n\n#### 图解\n\n![quick-union图解](qu1.png)\n\n#### Java代码\n\n![quick-union代码](qu2.png)\n\n#### 缺点\n\n如果有一条很长的链，查找效率会很低。\n\n### 二者比较\n\n#### 共通点\n\n不管是quick-find还是quick-union，算法中都有这样的共通点：\n\n1.每次union时会判断是否同根，如果是则直接跳过。\n\n2.在进行两个子集的union时，会连接两个子集的root。\n\n#### 时间复杂度比较\n\n![时间复杂度比较](compare.png)\n\n因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。\n\n由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。\n\n## Quick-Union算法的优化\n\n### Map\n\n因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。\n\n结构：{key: id, value: parent_id}\n\n### Weighting\n\nWeighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。\n\n#### 图解\n\n![weighting图解](weighting.png)\n\n#### 代码变动\n\n由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。\n\nmap结构变化: {key: id, value: {parent: parent_id, size: size}}\n\nunion时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身\n\n### Path Compression\n\nPath Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。\n\n#### 图解\n\n![path-compression图解](path-compression.jpg)\n\n## 最终代码\n\nquick-union + weighting + path compression + map\n\n``` javascript Union-Find.js\nconst map = new Map();\nclass Node {\n    //每个节点保存的结构\n    constructor(parent, size){\n        this.parent = parent || null;\n        this.size = size || 0;\n    }\n}\n\nfunction union(p, q){\n    if(!map.has(p)||!map.has(q)){\n        //有一个不在map里，说明是游离节点，自动设为child\n        if(!map.has(p)){\n            var child = p, parent = find(q); //path compression 父母直接设给根节点\n        } else {\n            var child = q, parent = find(p);\n        }\n        map.set(child, new Node(parent, 0));\n    } else {\n        //均存在map中，需要进行weighting的两个节点\n        const pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; //暂存两个节点的root\n        if(pr===qr){\n            //如果已经连通，不需要再连接了\n            return;\n        }\n        if(prs < qrs){\n            //把容量更小的那个设为child被合并\n            var child = pr, parent = qr;\n        } else {\n            var child = qr, parent = pr;\n        }\n        //root应该都存在map中\n        map.get(child).parent = parent;\n    }\n    if(!map.has(parent)){\n        map.set(parent, new Node(parent, map.get(child).size+1)); //map中新建一个root node，root的parent设给自己\n    } else {\n        map.get(parent).size+=map.get(child).size+1; //合并size\n    }\n};\n\nfunction find(p){\n    if(!map.has(p)){\n        return p;\n    }\n    while(map.get(p).parent!=p){\n        //如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent\n        p = map.get(p).parent;\n    }\n    return p;\n};\n\nfunction isConnected(p, q){\n    return (find(p)===find(q));\n}\n```\n\n## 时间复杂度\n\n最后贴上algorithms书中的各种方法的时间复杂度：\n\n![时间复杂度比较](compare-final.png)\n\n有weighting和path compression的quick union时间复杂度无限接近1。","slug":"JS-Union-find-quick-union-weighting-path-compression-map","published":1,"updated":"2021-08-20T04:34:02.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksk5blqc0000n0u69yt1c05l","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。</p>\n<h3 id=\"用于解决的问题\"><a href=\"#用于解决的问题\" class=\"headerlink\" title=\"用于解决的问题\"></a>用于解决的问题</h3><p>假定一个学校的圈子中，有A,B,C…这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。</p>\n<h3 id=\"核心的方法需求\"><a href=\"#核心的方法需求\" class=\"headerlink\" title=\"核心的方法需求\"></a>核心的方法需求</h3><p>Union(p, q): 将点p和点q建立连接的方法。</p>\n<p>Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"基本构建思路\"><a href=\"#基本构建思路\" class=\"headerlink\" title=\"基本构建思路\"></a>基本构建思路</h2><h3 id=\"Quick-Find\"><a href=\"#Quick-Find\" class=\"headerlink\" title=\"Quick-Find\"></a>Quick-Find</h3><p>这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。</p>\n<h4 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png\" alt=\"quick-find图解\"></p>\n<h4 id=\"Java代码\"><a href=\"#Java代码\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png\" alt=\"quick-find代码\"></p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果一条很长的链被合并，可能需要大量地改变root值。</p>\n<h3 id=\"Quick-Union\"><a href=\"#Quick-Union\" class=\"headerlink\" title=\"Quick-Union\"></a>Quick-Union</h3><p>这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。</p>\n<p>此时使用类似链表的数据结构十分恰当。</p>\n<h4 id=\"图解-1\"><a href=\"#图解-1\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png\" alt=\"quick-union图解\"></p>\n<h4 id=\"Java代码-1\"><a href=\"#Java代码-1\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png\" alt=\"quick-union代码\"></p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果有一条很长的链，查找效率会很低。</p>\n<h3 id=\"二者比较\"><a href=\"#二者比较\" class=\"headerlink\" title=\"二者比较\"></a>二者比较</h3><h4 id=\"共通点\"><a href=\"#共通点\" class=\"headerlink\" title=\"共通点\"></a>共通点</h4><p>不管是quick-find还是quick-union，算法中都有这样的共通点：</p>\n<p>1.每次union时会判断是否同根，如果是则直接跳过。</p>\n<p>2.在进行两个子集的union时，会连接两个子集的root。</p>\n<h4 id=\"时间复杂度比较\"><a href=\"#时间复杂度比较\" class=\"headerlink\" title=\"时间复杂度比较\"></a>时间复杂度比较</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare.png\" alt=\"时间复杂度比较\"></p>\n<p>因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。</p>\n<p>由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。</p>\n<h2 id=\"Quick-Union算法的优化\"><a href=\"#Quick-Union算法的优化\" class=\"headerlink\" title=\"Quick-Union算法的优化\"></a>Quick-Union算法的优化</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。</p>\n<p>结构：{key: id, value: parent_id}</p>\n<h3 id=\"Weighting\"><a href=\"#Weighting\" class=\"headerlink\" title=\"Weighting\"></a>Weighting</h3><p>Weighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。</p>\n<h4 id=\"图解-2\"><a href=\"#图解-2\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png\" alt=\"weighting图解\"></p>\n<h4 id=\"代码变动\"><a href=\"#代码变动\" class=\"headerlink\" title=\"代码变动\"></a>代码变动</h4><p>由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。</p>\n<p>map结构变化: {key: id, value: {parent: parent_id, size: size}}</p>\n<p>union时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身</p>\n<h3 id=\"Path-Compression\"><a href=\"#Path-Compression\" class=\"headerlink\" title=\"Path Compression\"></a>Path Compression</h3><p>Path Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。</p>\n<h4 id=\"图解-3\"><a href=\"#图解-3\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg\" alt=\"path-compression图解\"></p>\n<h2 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h2><p>quick-union + weighting + path compression + map</p>\n<figure class=\"highlight javascript\"><figcaption><span>Union-Find.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每个节点保存的结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">parent, size</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parent = parent || <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size = size || <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">union</span>(<span class=\"params\">p, q</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(p)||!map.has(q))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//有一个不在map里，说明是游离节点，自动设为child</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!map.has(p))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = p, parent = find(q); <span class=\"comment\">//path compression 父母直接设给根节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = q, parent = find(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.set(child, <span class=\"keyword\">new</span> Node(parent, <span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//均存在map中，需要进行weighting的两个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; <span class=\"comment\">//暂存两个节点的root</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pr===qr)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果已经连通，不需要再连接了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prs &lt; qrs)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//把容量更小的那个设为child被合并</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = pr, parent = qr;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = qr, parent = pr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//root应该都存在map中</span></span><br><span class=\"line\">        map.get(child).parent = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(parent))&#123;</span><br><span class=\"line\">        map.set(parent, <span class=\"keyword\">new</span> Node(parent, map.get(child).size+<span class=\"number\">1</span>)); <span class=\"comment\">//map中新建一个root node，root的parent设给自己</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        map.get(parent).size+=map.get(child).size+<span class=\"number\">1</span>; <span class=\"comment\">//合并size</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">p</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(p))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(map.get(p).parent!=p)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent</span></span><br><span class=\"line\">        p = map.get(p).parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isConnected</span>(<span class=\"params\">p, q</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (find(p)===find(q));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>最后贴上algorithms书中的各种方法的时间复杂度：</p>\n<p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png\" alt=\"时间复杂度比较\"></p>\n<p>有weighting和path compression的quick union时间复杂度无限接近1。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。</p>\n<h3 id=\"用于解决的问题\"><a href=\"#用于解决的问题\" class=\"headerlink\" title=\"用于解决的问题\"></a>用于解决的问题</h3><p>假定一个学校的圈子中，有A,B,C…这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。</p>\n<h3 id=\"核心的方法需求\"><a href=\"#核心的方法需求\" class=\"headerlink\" title=\"核心的方法需求\"></a>核心的方法需求</h3><p>Union(p, q): 将点p和点q建立连接的方法。</p>\n<p>Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。</p>","more":"<h2 id=\"基本构建思路\"><a href=\"#基本构建思路\" class=\"headerlink\" title=\"基本构建思路\"></a>基本构建思路</h2><h3 id=\"Quick-Find\"><a href=\"#Quick-Find\" class=\"headerlink\" title=\"Quick-Find\"></a>Quick-Find</h3><p>这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。</p>\n<h4 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png\" alt=\"quick-find图解\"></p>\n<h4 id=\"Java代码\"><a href=\"#Java代码\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png\" alt=\"quick-find代码\"></p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果一条很长的链被合并，可能需要大量地改变root值。</p>\n<h3 id=\"Quick-Union\"><a href=\"#Quick-Union\" class=\"headerlink\" title=\"Quick-Union\"></a>Quick-Union</h3><p>这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。</p>\n<p>此时使用类似链表的数据结构十分恰当。</p>\n<h4 id=\"图解-1\"><a href=\"#图解-1\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png\" alt=\"quick-union图解\"></p>\n<h4 id=\"Java代码-1\"><a href=\"#Java代码-1\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png\" alt=\"quick-union代码\"></p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果有一条很长的链，查找效率会很低。</p>\n<h3 id=\"二者比较\"><a href=\"#二者比较\" class=\"headerlink\" title=\"二者比较\"></a>二者比较</h3><h4 id=\"共通点\"><a href=\"#共通点\" class=\"headerlink\" title=\"共通点\"></a>共通点</h4><p>不管是quick-find还是quick-union，算法中都有这样的共通点：</p>\n<p>1.每次union时会判断是否同根，如果是则直接跳过。</p>\n<p>2.在进行两个子集的union时，会连接两个子集的root。</p>\n<h4 id=\"时间复杂度比较\"><a href=\"#时间复杂度比较\" class=\"headerlink\" title=\"时间复杂度比较\"></a>时间复杂度比较</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare.png\" alt=\"时间复杂度比较\"></p>\n<p>因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。</p>\n<p>由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。</p>\n<h2 id=\"Quick-Union算法的优化\"><a href=\"#Quick-Union算法的优化\" class=\"headerlink\" title=\"Quick-Union算法的优化\"></a>Quick-Union算法的优化</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。</p>\n<p>结构：{key: id, value: parent_id}</p>\n<h3 id=\"Weighting\"><a href=\"#Weighting\" class=\"headerlink\" title=\"Weighting\"></a>Weighting</h3><p>Weighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。</p>\n<h4 id=\"图解-2\"><a href=\"#图解-2\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png\" alt=\"weighting图解\"></p>\n<h4 id=\"代码变动\"><a href=\"#代码变动\" class=\"headerlink\" title=\"代码变动\"></a>代码变动</h4><p>由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。</p>\n<p>map结构变化: {key: id, value: {parent: parent_id, size: size}}</p>\n<p>union时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身</p>\n<h3 id=\"Path-Compression\"><a href=\"#Path-Compression\" class=\"headerlink\" title=\"Path Compression\"></a>Path Compression</h3><p>Path Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。</p>\n<h4 id=\"图解-3\"><a href=\"#图解-3\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg\" alt=\"path-compression图解\"></p>\n<h2 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h2><p>quick-union + weighting + path compression + map</p>\n<figure class=\"highlight javascript\"><figcaption><span>Union-Find.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每个节点保存的结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">parent, size</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parent = parent || <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size = size || <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">union</span>(<span class=\"params\">p, q</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(p)||!map.has(q))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//有一个不在map里，说明是游离节点，自动设为child</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!map.has(p))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = p, parent = find(q); <span class=\"comment\">//path compression 父母直接设给根节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = q, parent = find(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.set(child, <span class=\"keyword\">new</span> Node(parent, <span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//均存在map中，需要进行weighting的两个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; <span class=\"comment\">//暂存两个节点的root</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pr===qr)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果已经连通，不需要再连接了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prs &lt; qrs)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//把容量更小的那个设为child被合并</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = pr, parent = qr;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = qr, parent = pr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//root应该都存在map中</span></span><br><span class=\"line\">        map.get(child).parent = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(parent))&#123;</span><br><span class=\"line\">        map.set(parent, <span class=\"keyword\">new</span> Node(parent, map.get(child).size+<span class=\"number\">1</span>)); <span class=\"comment\">//map中新建一个root node，root的parent设给自己</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        map.get(parent).size+=map.get(child).size+<span class=\"number\">1</span>; <span class=\"comment\">//合并size</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">p</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(p))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(map.get(p).parent!=p)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent</span></span><br><span class=\"line\">        p = map.get(p).parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isConnected</span>(<span class=\"params\">p, q</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (find(p)===find(q));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>最后贴上algorithms书中的各种方法的时间复杂度：</p>\n<p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png\" alt=\"时间复杂度比较\"></p>\n<p>有weighting和path compression的quick union时间复杂度无限接近1。</p>"},{"title":"关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）","date":"2021-08-18T08:35:47.000Z","comment":true,"_content":"\n上一章内容：[关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）](/2021/08/16/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）)\n\n原代码不再贴出。\n\n## 新的工程需求\n\n上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：\n\n不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。\n\n## 初步想法：阻止手势穿透\n\n微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？\n\n<!-- more -->\n\n## 尝试：将bind换成catch\n\n``` wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"touchStart\" catchtouchmove=\"touchMove\">\n\t<!-- 内容 -->\n</view>\n```\n\n可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。\n\n## 尝试：使bind和catch的事件根据isTouchMove进行变化\n\n``` wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\" \n    bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n\t<!-- 内容 -->\n</view>\n```\n\n但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。\n\n## 尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\n\n``` wxml index.wxml\n<block wx:for=\"{{dataList}}\" data-index=\"{{index}}\">\n    <!-- 一个是没有被打开菜单的（支持上下滑动和返回） -->\n    <view wx:if=\"{{!item.isTouchMove}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n        <!-- 内容 -->\n    </view>\n    <!-- 被打开菜单的（阻止上下滑动和返回） -->\n    <view wx:else class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\">\n        <!-- 内容 -->\n    </view>\n</block>\n``` \n\n效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。\n\n## 最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\n\n绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。\n\n思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。\n\n注意：css中，动画设定是0.4s，延时应当适当小于这个值。\n\n``` wxml index.wxml\n<block wx:for=\"{{dataList}}\" data-index=\"{{index}}\">\n    <!-- 一个是没有被打开菜单的（支持上下滑动和返回） -->\n    <view wx:if=\"{{index!==hidden}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n        <!-- 内容 -->\n    </view>\n    <!-- 被打开菜单的（阻止上下滑动和返回） -->\n    <view wx:else class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\">\n        <!-- 内容 -->\n    </view>\n</block>\n``` \n\n```javascript index.js\n/* Page */\n  data: {\n    dataList: [/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/],\n    startX: 0,\n    startY: 0,\n    hidden: null,//标记被隐藏的块index\n  },\n\n\n  touchStart(e) {\n    let dataList = this.data.dataList;\n    dataList.forEach(item => {\n      if (item.isTouchMove) {\n        item.isTouchMove = !item.isTouchMove;\n      }\n    });\n    this.setData({\n      dataList: dataList,\n    });\n\n    this.data.hidden = null; //先把hidden置null, 但不渲染\n\n    this.data.startX = e.touches[0].clientX;\n    this.data.startY = e.touches[0].clientY;\n  },\n  touchMove(e) {\n    let moveX = e.changedTouches[0].clientX,\n      moveY = e.changedTouches[0].clientY,\n      curIndex = e.currentTarget.dataset.index, \n      dataList = this.data.dataList,\n      angle = this.angle(\n        { X: this.data.startX,\n\t    Y: this.data.startY\n\t    }, { X: moveX,\n\t    Y: moveY\n\t    }\n\t  );\n    const that = this; //用于在forEach函数里访问data\n    dataList.forEach((item, index) => {\n      if (curIndex === index && angle < 30 && moveX < this.data.startX) {\n        item.isTouchMove = true;\n        that.data.hidden = index;//如果有块被滑动，将hidden设为此块，否则就会保持在null\n      } else {\n      \titem.isTouchMove = false; \n      }\n    });\n\n    this.setData({\n      dataList: dataList,\n    });\n\n    setTimeOut({\n      that.setData({\n        hidden: that.data.hidden //0.3s后渲染hidden来替换组件，此时动画基本放完了\n      })\n    }, 300);\n  },\n```\n\n经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。\n\n## 总结\n\n至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。","source":"_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）.md","raw":"---\ntitle: 关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）\ndate: 2021-08-18 16:35:47\ntags: [微信小程序,fs]\ncategories: 微信小程序\ncomment: true\n---\n\n上一章内容：[关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）](/2021/08/16/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）)\n\n原代码不再贴出。\n\n## 新的工程需求\n\n上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：\n\n不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。\n\n## 初步想法：阻止手势穿透\n\n微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？\n\n<!-- more -->\n\n## 尝试：将bind换成catch\n\n``` wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"touchStart\" catchtouchmove=\"touchMove\">\n\t<!-- 内容 -->\n</view>\n```\n\n可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。\n\n## 尝试：使bind和catch的事件根据isTouchMove进行变化\n\n``` wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\" \n    bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n\t<!-- 内容 -->\n</view>\n```\n\n但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。\n\n## 尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\n\n``` wxml index.wxml\n<block wx:for=\"{{dataList}}\" data-index=\"{{index}}\">\n    <!-- 一个是没有被打开菜单的（支持上下滑动和返回） -->\n    <view wx:if=\"{{!item.isTouchMove}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n        <!-- 内容 -->\n    </view>\n    <!-- 被打开菜单的（阻止上下滑动和返回） -->\n    <view wx:else class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\">\n        <!-- 内容 -->\n    </view>\n</block>\n``` \n\n效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。\n\n## 最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\n\n绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。\n\n思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。\n\n注意：css中，动画设定是0.4s，延时应当适当小于这个值。\n\n``` wxml index.wxml\n<block wx:for=\"{{dataList}}\" data-index=\"{{index}}\">\n    <!-- 一个是没有被打开菜单的（支持上下滑动和返回） -->\n    <view wx:if=\"{{index!==hidden}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n        <!-- 内容 -->\n    </view>\n    <!-- 被打开菜单的（阻止上下滑动和返回） -->\n    <view wx:else class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\">\n        <!-- 内容 -->\n    </view>\n</block>\n``` \n\n```javascript index.js\n/* Page */\n  data: {\n    dataList: [/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/],\n    startX: 0,\n    startY: 0,\n    hidden: null,//标记被隐藏的块index\n  },\n\n\n  touchStart(e) {\n    let dataList = this.data.dataList;\n    dataList.forEach(item => {\n      if (item.isTouchMove) {\n        item.isTouchMove = !item.isTouchMove;\n      }\n    });\n    this.setData({\n      dataList: dataList,\n    });\n\n    this.data.hidden = null; //先把hidden置null, 但不渲染\n\n    this.data.startX = e.touches[0].clientX;\n    this.data.startY = e.touches[0].clientY;\n  },\n  touchMove(e) {\n    let moveX = e.changedTouches[0].clientX,\n      moveY = e.changedTouches[0].clientY,\n      curIndex = e.currentTarget.dataset.index, \n      dataList = this.data.dataList,\n      angle = this.angle(\n        { X: this.data.startX,\n\t    Y: this.data.startY\n\t    }, { X: moveX,\n\t    Y: moveY\n\t    }\n\t  );\n    const that = this; //用于在forEach函数里访问data\n    dataList.forEach((item, index) => {\n      if (curIndex === index && angle < 30 && moveX < this.data.startX) {\n        item.isTouchMove = true;\n        that.data.hidden = index;//如果有块被滑动，将hidden设为此块，否则就会保持在null\n      } else {\n      \titem.isTouchMove = false; \n      }\n    });\n\n    this.setData({\n      dataList: dataList,\n    });\n\n    setTimeOut({\n      that.setData({\n        hidden: that.data.hidden //0.3s后渲染hidden来替换组件，此时动画基本放完了\n      })\n    }, 300);\n  },\n```\n\n经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。\n\n## 总结\n\n至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。","slug":"关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）","published":1,"updated":"2021-08-20T04:55:29.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksk5blqo0009n0u61auvdoqy","content":"<p>上一章内容：<a href=\"/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89\">关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</a></p>\n<p>原代码不再贴出。</p>\n<h2 id=\"新的工程需求\"><a href=\"#新的工程需求\" class=\"headerlink\" title=\"新的工程需求\"></a>新的工程需求</h2><p>上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：</p>\n<p>不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。</p>\n<h2 id=\"初步想法：阻止手势穿透\"><a href=\"#初步想法：阻止手势穿透\" class=\"headerlink\" title=\"初步想法：阻止手势穿透\"></a>初步想法：阻止手势穿透</h2><p>微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"尝试：将bind换成catch\"><a href=\"#尝试：将bind换成catch\" class=\"headerlink\" title=\"尝试：将bind换成catch\"></a>尝试：将bind换成catch</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;touchStart&quot; catchtouchmove=&quot;touchMove&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。</p>\n<h2 id=\"尝试：使bind和catch的事件根据isTouchMove进行变化\"><a href=\"#尝试：使bind和catch的事件根据isTouchMove进行变化\" class=\"headerlink\" title=\"尝试：使bind和catch的事件根据isTouchMove进行变化\"></a>尝试：使bind和catch的事件根据isTouchMove进行变化</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot; </span><br><span class=\"line\">    bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。</p>\n<h2 id=\"尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\"><a href=\"#尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\" class=\"headerlink\" title=\"尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\"></a>尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:if=&quot;&#123;&#123;!item.isTouchMove&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。</p>\n<h2 id=\"最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\"><a href=\"#最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\" class=\"headerlink\" title=\"最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\"></a>最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换</h2><p>绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。</p>\n<p>思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。</p>\n<p>注意：css中，动画设定是0.4s，延时应当适当小于这个值。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:if=&quot;&#123;&#123;index!==hidden&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Page */</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">dataList</span>: [<span class=\"comment\">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class=\"line\">    <span class=\"attr\">startX</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">startY</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">hidden</span>: <span class=\"literal\">null</span>,<span class=\"comment\">//标记被隐藏的块index</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchStart</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataList = <span class=\"built_in\">this</span>.data.dataList;</span><br><span class=\"line\">    dataList.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item.isTouchMove) &#123;</span><br><span class=\"line\">        item.isTouchMove = !item.isTouchMove;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.hidden = <span class=\"literal\">null</span>; <span class=\"comment\">//先把hidden置null, 但不渲染</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startX = e.touches[<span class=\"number\">0</span>].clientX;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startY = e.touches[<span class=\"number\">0</span>].clientY;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchMove</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> moveX = e.changedTouches[<span class=\"number\">0</span>].clientX,</span><br><span class=\"line\">      moveY = e.changedTouches[<span class=\"number\">0</span>].clientY,</span><br><span class=\"line\">      curIndex = e.currentTarget.dataset.index, </span><br><span class=\"line\">      dataList = <span class=\"built_in\">this</span>.data.dataList,</span><br><span class=\"line\">      angle = <span class=\"built_in\">this</span>.angle(</span><br><span class=\"line\">        &#123; <span class=\"attr\">X</span>: <span class=\"built_in\">this</span>.data.startX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: <span class=\"built_in\">this</span>.data.startY</span><br><span class=\"line\">\t    &#125;, &#123; <span class=\"attr\">X</span>: moveX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: moveY</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  );</span><br><span class=\"line\">    <span class=\"keyword\">const</span> that = <span class=\"built_in\">this</span>; <span class=\"comment\">//用于在forEach函数里访问data</span></span><br><span class=\"line\">    dataList.forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curIndex === index &amp;&amp; angle &lt; <span class=\"number\">30</span> &amp;&amp; moveX &lt; <span class=\"built_in\">this</span>.data.startX) &#123;</span><br><span class=\"line\">        item.isTouchMove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        that.data.hidden = index;<span class=\"comment\">//如果有块被滑动，将hidden设为此块，否则就会保持在null</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \titem.isTouchMove = <span class=\"literal\">false</span>; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeOut(&#123;</span><br><span class=\"line\">      that.setData(&#123;</span><br><span class=\"line\">        <span class=\"attr\">hidden</span>: that.data.hidden <span class=\"comment\">//0.3s后渲染hidden来替换组件，此时动画基本放完了</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。</p>\n","site":{"data":{}},"excerpt":"<p>上一章内容：<a href=\"/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89\">关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</a></p>\n<p>原代码不再贴出。</p>\n<h2 id=\"新的工程需求\"><a href=\"#新的工程需求\" class=\"headerlink\" title=\"新的工程需求\"></a>新的工程需求</h2><p>上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：</p>\n<p>不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。</p>\n<h2 id=\"初步想法：阻止手势穿透\"><a href=\"#初步想法：阻止手势穿透\" class=\"headerlink\" title=\"初步想法：阻止手势穿透\"></a>初步想法：阻止手势穿透</h2><p>微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？</p>","more":"<h2 id=\"尝试：将bind换成catch\"><a href=\"#尝试：将bind换成catch\" class=\"headerlink\" title=\"尝试：将bind换成catch\"></a>尝试：将bind换成catch</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;touchStart&quot; catchtouchmove=&quot;touchMove&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。</p>\n<h2 id=\"尝试：使bind和catch的事件根据isTouchMove进行变化\"><a href=\"#尝试：使bind和catch的事件根据isTouchMove进行变化\" class=\"headerlink\" title=\"尝试：使bind和catch的事件根据isTouchMove进行变化\"></a>尝试：使bind和catch的事件根据isTouchMove进行变化</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot; </span><br><span class=\"line\">    bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。</p>\n<h2 id=\"尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\"><a href=\"#尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\" class=\"headerlink\" title=\"尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\"></a>尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:if=&quot;&#123;&#123;!item.isTouchMove&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。</p>\n<h2 id=\"最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\"><a href=\"#最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\" class=\"headerlink\" title=\"最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\"></a>最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换</h2><p>绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。</p>\n<p>思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。</p>\n<p>注意：css中，动画设定是0.4s，延时应当适当小于这个值。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:if=&quot;&#123;&#123;index!==hidden&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Page */</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">dataList</span>: [<span class=\"comment\">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class=\"line\">    <span class=\"attr\">startX</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">startY</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">hidden</span>: <span class=\"literal\">null</span>,<span class=\"comment\">//标记被隐藏的块index</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchStart</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataList = <span class=\"built_in\">this</span>.data.dataList;</span><br><span class=\"line\">    dataList.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item.isTouchMove) &#123;</span><br><span class=\"line\">        item.isTouchMove = !item.isTouchMove;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.hidden = <span class=\"literal\">null</span>; <span class=\"comment\">//先把hidden置null, 但不渲染</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startX = e.touches[<span class=\"number\">0</span>].clientX;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startY = e.touches[<span class=\"number\">0</span>].clientY;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchMove</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> moveX = e.changedTouches[<span class=\"number\">0</span>].clientX,</span><br><span class=\"line\">      moveY = e.changedTouches[<span class=\"number\">0</span>].clientY,</span><br><span class=\"line\">      curIndex = e.currentTarget.dataset.index, </span><br><span class=\"line\">      dataList = <span class=\"built_in\">this</span>.data.dataList,</span><br><span class=\"line\">      angle = <span class=\"built_in\">this</span>.angle(</span><br><span class=\"line\">        &#123; <span class=\"attr\">X</span>: <span class=\"built_in\">this</span>.data.startX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: <span class=\"built_in\">this</span>.data.startY</span><br><span class=\"line\">\t    &#125;, &#123; <span class=\"attr\">X</span>: moveX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: moveY</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  );</span><br><span class=\"line\">    <span class=\"keyword\">const</span> that = <span class=\"built_in\">this</span>; <span class=\"comment\">//用于在forEach函数里访问data</span></span><br><span class=\"line\">    dataList.forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curIndex === index &amp;&amp; angle &lt; <span class=\"number\">30</span> &amp;&amp; moveX &lt; <span class=\"built_in\">this</span>.data.startX) &#123;</span><br><span class=\"line\">        item.isTouchMove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        that.data.hidden = index;<span class=\"comment\">//如果有块被滑动，将hidden设为此块，否则就会保持在null</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \titem.isTouchMove = <span class=\"literal\">false</span>; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeOut(&#123;</span><br><span class=\"line\">      that.setData(&#123;</span><br><span class=\"line\">        <span class=\"attr\">hidden</span>: that.data.hidden <span class=\"comment\">//0.3s后渲染hidden来替换组件，此时动画基本放完了</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。</p>"},{"title":"关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）","date":"2021-08-16T03:14:19.000Z","comment":true,"_content":"\n## 工程需求\n\n开发的应用：用微信小程序经由hera生成的跨平台移动端APP。\n\n在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。\n\n## 方案参考\n\n由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。\n\n参考链接：https://blog.csdn.net/LiaoFengJi/article/details/105218664\n\n<!-- more -->\n\n## 提炼代码如下：\n\n```wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\">\n\t<!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 -->\n\t<view class=\"item-left\" data-index=\"{{index}}\">\n\t\t<!-- 每条要显示的内容 -->\n\t</view>\n\t<view class=\"item-right\">\n\t\t<view class=\"btn-right\" bindtap=\"setTopItem\">置顶</view>\n\t\t<view class=\"btn-right\" bindtap=\"deleteItem\">删除</view>\n\t</view>\n</view>\n```\n\n```wxss index.wxss\n.item {\n  display: flex;\n}\n\n/* 内容部分 */\n.item-left {\n  width: 100%;\n  /*关键代码*/\n  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  /*关键代码*/\n}\n\n/* 按钮部分 */\n.item-right {\n  height: 100%;\n  width: 400rpx; /*根据需要调整*/\n  display: flex;\n  flex-direction: row;\n  /*关键代码*/\n  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/\n  /*关键代码*/\n}\n\n.btn-right {\n  width: 50%; /*这里根据自己的需要划成了两半*/\n}\n\n/* 向左滑动 */\n.touch-move-active .item-left,\n.touch-move-active .item-right {\n  /*关键代码*/\n  -webkit-transform: translateX(0);\n  transform: translateX(0);\n  /*关键代码*/\n}\n```\n\n```javascript index.js\n/* Page */\n  data: {\n    dataList: [/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/],\n    startX: 0,// 设置开始的位置X\n    startY: 0,// 设置开始的位置Y\n  },\n\n  // 开始滑动\n  touchStart(e) {\n    let dataList = this.data.dataList;\n    dataList.forEach(item => {\n    // 让原先滑动的块隐藏\n      if (item.isTouchMove) {\n        item.isTouchMove = !item.isTouchMove;\n      }\n    });\n    this.setData({\n      dataList: dataList,\n    });\n    // 初始化开始位置\n    this.data.startX = e.touches[0].clientX;\n    this.data.startY = e.touches[0].clientY;\n\t// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData\n\t},\n  // 滑动的过程\n  touchMove(e) {\n    let moveX = e.changedTouches[0].clientX,\n      moveY = e.changedTouches[0].clientY,\n      curIndex = e.currentTarget.dataset.index, \n      //注意，wxml里面一定要设置data-index=\"{{index}}\",这样e.currentTarget.dataset中才会传index的值\n      dataList = this.data.dataList,\n      // 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动\n      angle = this.angle(\n        { X: this.data.startX,\n\t    Y: this.data.startY\n\t    }, { X: moveX,\n\t    Y: moveY\n\t    }\n\t  );\n\n    dataList.forEach((item, index) => {\n    // 这里相对参考代码做了精炼\n\t// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑\n      if (curIndex === index && angle < 30 && moveX < this.data.startX) {\n        item.isTouchMove = true;\n      } else {\n      \titem.isTouchMove = false; //否则右滑\n      }\n    });\n\n    this.setData({\n      dataList\n    });\n  },\n\n  /**\n   * 计算滑动角度\n   * @param {Object} start 起点坐标\n   * @param {Object} end 终点坐标\n   */\n  angle: function (start, end) {\n    var _X = end.X - start.X,\n      _Y = end.Y - start.Y\n    //返回角度 /Math.atan()返回数字的反正切值\n    return 360 * Math.atan(_Y / _X) / (2 * Math.PI);\n  },\n\n  // 删除\n  deleteItem(e) {\n  \t/* 这里是具体删除item的方法 */\n  }\n```\n\n## 实现效果\n\n![侧滑效果](侧滑效果.gif)\n\n## 结语\n\n本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。\n\n实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。","source":"_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）.md","raw":"---\ntitle: 关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）\ndate: 2021-08-16 11:14:19\ntags: [微信小程序,fs]\ncategories: 微信小程序\ncomment: true\n---\n\n## 工程需求\n\n开发的应用：用微信小程序经由hera生成的跨平台移动端APP。\n\n在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。\n\n## 方案参考\n\n由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。\n\n参考链接：https://blog.csdn.net/LiaoFengJi/article/details/105218664\n\n<!-- more -->\n\n## 提炼代码如下：\n\n```wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\">\n\t<!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 -->\n\t<view class=\"item-left\" data-index=\"{{index}}\">\n\t\t<!-- 每条要显示的内容 -->\n\t</view>\n\t<view class=\"item-right\">\n\t\t<view class=\"btn-right\" bindtap=\"setTopItem\">置顶</view>\n\t\t<view class=\"btn-right\" bindtap=\"deleteItem\">删除</view>\n\t</view>\n</view>\n```\n\n```wxss index.wxss\n.item {\n  display: flex;\n}\n\n/* 内容部分 */\n.item-left {\n  width: 100%;\n  /*关键代码*/\n  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  /*关键代码*/\n}\n\n/* 按钮部分 */\n.item-right {\n  height: 100%;\n  width: 400rpx; /*根据需要调整*/\n  display: flex;\n  flex-direction: row;\n  /*关键代码*/\n  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/\n  /*关键代码*/\n}\n\n.btn-right {\n  width: 50%; /*这里根据自己的需要划成了两半*/\n}\n\n/* 向左滑动 */\n.touch-move-active .item-left,\n.touch-move-active .item-right {\n  /*关键代码*/\n  -webkit-transform: translateX(0);\n  transform: translateX(0);\n  /*关键代码*/\n}\n```\n\n```javascript index.js\n/* Page */\n  data: {\n    dataList: [/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/],\n    startX: 0,// 设置开始的位置X\n    startY: 0,// 设置开始的位置Y\n  },\n\n  // 开始滑动\n  touchStart(e) {\n    let dataList = this.data.dataList;\n    dataList.forEach(item => {\n    // 让原先滑动的块隐藏\n      if (item.isTouchMove) {\n        item.isTouchMove = !item.isTouchMove;\n      }\n    });\n    this.setData({\n      dataList: dataList,\n    });\n    // 初始化开始位置\n    this.data.startX = e.touches[0].clientX;\n    this.data.startY = e.touches[0].clientY;\n\t// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData\n\t},\n  // 滑动的过程\n  touchMove(e) {\n    let moveX = e.changedTouches[0].clientX,\n      moveY = e.changedTouches[0].clientY,\n      curIndex = e.currentTarget.dataset.index, \n      //注意，wxml里面一定要设置data-index=\"{{index}}\",这样e.currentTarget.dataset中才会传index的值\n      dataList = this.data.dataList,\n      // 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动\n      angle = this.angle(\n        { X: this.data.startX,\n\t    Y: this.data.startY\n\t    }, { X: moveX,\n\t    Y: moveY\n\t    }\n\t  );\n\n    dataList.forEach((item, index) => {\n    // 这里相对参考代码做了精炼\n\t// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑\n      if (curIndex === index && angle < 30 && moveX < this.data.startX) {\n        item.isTouchMove = true;\n      } else {\n      \titem.isTouchMove = false; //否则右滑\n      }\n    });\n\n    this.setData({\n      dataList\n    });\n  },\n\n  /**\n   * 计算滑动角度\n   * @param {Object} start 起点坐标\n   * @param {Object} end 终点坐标\n   */\n  angle: function (start, end) {\n    var _X = end.X - start.X,\n      _Y = end.Y - start.Y\n    //返回角度 /Math.atan()返回数字的反正切值\n    return 360 * Math.atan(_Y / _X) / (2 * Math.PI);\n  },\n\n  // 删除\n  deleteItem(e) {\n  \t/* 这里是具体删除item的方法 */\n  }\n```\n\n## 实现效果\n\n![侧滑效果](侧滑效果.gif)\n\n## 结语\n\n本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。\n\n实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。","slug":"关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）","published":1,"updated":"2021-08-20T04:55:20.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksk5blqp000an0u69icg6wgd","content":"<h2 id=\"工程需求\"><a href=\"#工程需求\" class=\"headerlink\" title=\"工程需求\"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端APP。</p>\n<p>在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。</p>\n<h2 id=\"方案参考\"><a href=\"#方案参考\" class=\"headerlink\" title=\"方案参考\"></a>方案参考</h2><p>由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。</p>\n<p>参考链接：<a href=\"https://blog.csdn.net/LiaoFengJi/article/details/105218664\">https://blog.csdn.net/LiaoFengJi/article/details/105218664</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"提炼代码如下：\"><a href=\"#提炼代码如下：\" class=\"headerlink\" title=\"提炼代码如下：\"></a>提炼代码如下：</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;touchStart&quot; bindtouchmove=&quot;touchMove&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 --&gt;</span><br><span class=\"line\">\t&lt;view class=&quot;item-left&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">\t\t&lt;!-- 每条要显示的内容 --&gt;</span><br><span class=\"line\">\t&lt;/view&gt;</span><br><span class=\"line\">\t&lt;view class=&quot;item-right&quot;&gt;</span><br><span class=\"line\">\t\t&lt;view class=&quot;btn-right&quot; bindtap=&quot;setTopItem&quot;&gt;置顶&lt;/view&gt;</span><br><span class=\"line\">\t\t&lt;view class=&quot;btn-right&quot; bindtap=&quot;deleteItem&quot;&gt;删除&lt;/view&gt;</span><br><span class=\"line\">\t&lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxss</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 内容部分 */</span><br><span class=\"line\">.item-left &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  -webkit-transition: all 0.4s;</span><br><span class=\"line\">  transition: all 0.4s;</span><br><span class=\"line\">  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 按钮部分 */</span><br><span class=\"line\">.item-right &#123;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  width: 400rpx; /*根据需要调整*/</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: row;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class=\"line\">  -webkit-transition: all 0.4s;</span><br><span class=\"line\">  transition: all 0.4s;</span><br><span class=\"line\">  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.btn-right &#123;</span><br><span class=\"line\">  width: 50%; /*这里根据自己的需要划成了两半*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 向左滑动 */</span><br><span class=\"line\">.touch-move-active .item-left,</span><br><span class=\"line\">.touch-move-active .item-right &#123;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  -webkit-transform: translateX(0);</span><br><span class=\"line\">  transform: translateX(0);</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Page */</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">dataList</span>: [<span class=\"comment\">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class=\"line\">    <span class=\"attr\">startX</span>: <span class=\"number\">0</span>,<span class=\"comment\">// 设置开始的位置X</span></span><br><span class=\"line\">    <span class=\"attr\">startY</span>: <span class=\"number\">0</span>,<span class=\"comment\">// 设置开始的位置Y</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开始滑动</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchStart</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataList = <span class=\"built_in\">this</span>.data.dataList;</span><br><span class=\"line\">    dataList.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 让原先滑动的块隐藏</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item.isTouchMove) &#123;</span><br><span class=\"line\">        item.isTouchMove = !item.isTouchMove;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化开始位置</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startX = e.touches[<span class=\"number\">0</span>].clientX;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startY = e.touches[<span class=\"number\">0</span>].clientY;</span><br><span class=\"line\">\t<span class=\"comment\">// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 滑动的过程</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchMove</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> moveX = e.changedTouches[<span class=\"number\">0</span>].clientX,</span><br><span class=\"line\">      moveY = e.changedTouches[<span class=\"number\">0</span>].clientY,</span><br><span class=\"line\">      curIndex = e.currentTarget.dataset.index, </span><br><span class=\"line\">      <span class=\"comment\">//注意，wxml里面一定要设置data-index=&quot;&#123;&#123;index&#125;&#125;&quot;,这样e.currentTarget.dataset中才会传index的值</span></span><br><span class=\"line\">      dataList = <span class=\"built_in\">this</span>.data.dataList,</span><br><span class=\"line\">      <span class=\"comment\">// 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动</span></span><br><span class=\"line\">      angle = <span class=\"built_in\">this</span>.angle(</span><br><span class=\"line\">        &#123; <span class=\"attr\">X</span>: <span class=\"built_in\">this</span>.data.startX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: <span class=\"built_in\">this</span>.data.startY</span><br><span class=\"line\">\t    &#125;, &#123; <span class=\"attr\">X</span>: moveX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: moveY</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  );</span><br><span class=\"line\"></span><br><span class=\"line\">    dataList.forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里相对参考代码做了精炼</span></span><br><span class=\"line\">\t<span class=\"comment\">// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curIndex === index &amp;&amp; angle &lt; <span class=\"number\">30</span> &amp;&amp; moveX &lt; <span class=\"built_in\">this</span>.data.startX) &#123;</span><br><span class=\"line\">        item.isTouchMove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \titem.isTouchMove = <span class=\"literal\">false</span>; <span class=\"comment\">//否则右滑</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      dataList</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 计算滑动角度</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>start 起点坐标</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>end 终点坐标</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"attr\">angle</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _X = end.X - start.X,</span><br><span class=\"line\">      _Y = end.Y - start.Y</span><br><span class=\"line\">    <span class=\"comment\">//返回角度 /Math.atan()返回数字的反正切值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">360</span> * <span class=\"built_in\">Math</span>.atan(_Y / _X) / (<span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 删除</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">deleteItem</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">/* 这里是具体删除item的方法 */</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p><img src=\"/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/%E4%BE%A7%E6%BB%91%E6%95%88%E6%9E%9C.gif\" alt=\"侧滑效果\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。</p>\n<p>实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"工程需求\"><a href=\"#工程需求\" class=\"headerlink\" title=\"工程需求\"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端APP。</p>\n<p>在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。</p>\n<h2 id=\"方案参考\"><a href=\"#方案参考\" class=\"headerlink\" title=\"方案参考\"></a>方案参考</h2><p>由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。</p>\n<p>参考链接：<a href=\"https://blog.csdn.net/LiaoFengJi/article/details/105218664\">https://blog.csdn.net/LiaoFengJi/article/details/105218664</a></p>","more":"<h2 id=\"提炼代码如下：\"><a href=\"#提炼代码如下：\" class=\"headerlink\" title=\"提炼代码如下：\"></a>提炼代码如下：</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;touchStart&quot; bindtouchmove=&quot;touchMove&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 --&gt;</span><br><span class=\"line\">\t&lt;view class=&quot;item-left&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">\t\t&lt;!-- 每条要显示的内容 --&gt;</span><br><span class=\"line\">\t&lt;/view&gt;</span><br><span class=\"line\">\t&lt;view class=&quot;item-right&quot;&gt;</span><br><span class=\"line\">\t\t&lt;view class=&quot;btn-right&quot; bindtap=&quot;setTopItem&quot;&gt;置顶&lt;/view&gt;</span><br><span class=\"line\">\t\t&lt;view class=&quot;btn-right&quot; bindtap=&quot;deleteItem&quot;&gt;删除&lt;/view&gt;</span><br><span class=\"line\">\t&lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxss</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 内容部分 */</span><br><span class=\"line\">.item-left &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  -webkit-transition: all 0.4s;</span><br><span class=\"line\">  transition: all 0.4s;</span><br><span class=\"line\">  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 按钮部分 */</span><br><span class=\"line\">.item-right &#123;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  width: 400rpx; /*根据需要调整*/</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: row;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class=\"line\">  -webkit-transition: all 0.4s;</span><br><span class=\"line\">  transition: all 0.4s;</span><br><span class=\"line\">  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.btn-right &#123;</span><br><span class=\"line\">  width: 50%; /*这里根据自己的需要划成了两半*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 向左滑动 */</span><br><span class=\"line\">.touch-move-active .item-left,</span><br><span class=\"line\">.touch-move-active .item-right &#123;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  -webkit-transform: translateX(0);</span><br><span class=\"line\">  transform: translateX(0);</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Page */</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">dataList</span>: [<span class=\"comment\">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class=\"line\">    <span class=\"attr\">startX</span>: <span class=\"number\">0</span>,<span class=\"comment\">// 设置开始的位置X</span></span><br><span class=\"line\">    <span class=\"attr\">startY</span>: <span class=\"number\">0</span>,<span class=\"comment\">// 设置开始的位置Y</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开始滑动</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchStart</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataList = <span class=\"built_in\">this</span>.data.dataList;</span><br><span class=\"line\">    dataList.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 让原先滑动的块隐藏</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item.isTouchMove) &#123;</span><br><span class=\"line\">        item.isTouchMove = !item.isTouchMove;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化开始位置</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startX = e.touches[<span class=\"number\">0</span>].clientX;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startY = e.touches[<span class=\"number\">0</span>].clientY;</span><br><span class=\"line\">\t<span class=\"comment\">// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 滑动的过程</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchMove</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> moveX = e.changedTouches[<span class=\"number\">0</span>].clientX,</span><br><span class=\"line\">      moveY = e.changedTouches[<span class=\"number\">0</span>].clientY,</span><br><span class=\"line\">      curIndex = e.currentTarget.dataset.index, </span><br><span class=\"line\">      <span class=\"comment\">//注意，wxml里面一定要设置data-index=&quot;&#123;&#123;index&#125;&#125;&quot;,这样e.currentTarget.dataset中才会传index的值</span></span><br><span class=\"line\">      dataList = <span class=\"built_in\">this</span>.data.dataList,</span><br><span class=\"line\">      <span class=\"comment\">// 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动</span></span><br><span class=\"line\">      angle = <span class=\"built_in\">this</span>.angle(</span><br><span class=\"line\">        &#123; <span class=\"attr\">X</span>: <span class=\"built_in\">this</span>.data.startX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: <span class=\"built_in\">this</span>.data.startY</span><br><span class=\"line\">\t    &#125;, &#123; <span class=\"attr\">X</span>: moveX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: moveY</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  );</span><br><span class=\"line\"></span><br><span class=\"line\">    dataList.forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里相对参考代码做了精炼</span></span><br><span class=\"line\">\t<span class=\"comment\">// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curIndex === index &amp;&amp; angle &lt; <span class=\"number\">30</span> &amp;&amp; moveX &lt; <span class=\"built_in\">this</span>.data.startX) &#123;</span><br><span class=\"line\">        item.isTouchMove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \titem.isTouchMove = <span class=\"literal\">false</span>; <span class=\"comment\">//否则右滑</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      dataList</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 计算滑动角度</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>start 起点坐标</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>end 终点坐标</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"attr\">angle</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _X = end.X - start.X,</span><br><span class=\"line\">      _Y = end.Y - start.Y</span><br><span class=\"line\">    <span class=\"comment\">//返回角度 /Math.atan()返回数字的反正切值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">360</span> * <span class=\"built_in\">Math</span>.atan(_Y / _X) / (<span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 删除</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">deleteItem</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">/* 这里是具体删除item的方法 */</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p><img src=\"/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/%E4%BE%A7%E6%BB%91%E6%95%88%E6%9E%9C.gif\" alt=\"侧滑效果\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。</p>\n<p>实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。</p>"},{"title":"微信小程序：灵活适配不同标题栏高度的设备的方法","date":"2021-08-14T15:40:07.000Z","comment":true,"_content":"\n## 工程需求\n\n开发的应用：用微信小程序经由hera生成的跨平台移动端App。\n\n作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？\n\n首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。\n\n## 方案参考\n\n在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。\n\n私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：\n\n<!-- more -->\n\n## 最终方案\n\n### 大体思路如下：\n\n在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。\n\n### 主要代码：\n\n``` javascript index.js\n/* page */\n\tdata: {\n\t\tdAbsoluteTop: 0, //准备设置固定内容组件的高度\n\t},\n\n\tonLoad: function(){\n\t\tconst that = this;\n\t\tconst query = wx.createSelectorQuery();\n\t\tquery.select('#fixed-view').boundingClientRect();\n\t\tquery.selectViewport().scrollOffset();\n\t\tquery.exec(function(res){\n\t\t\tthat.setData({\n\t\t\t\tdAbsoluteTop: res[0].bottom //根据底部渲染\n\t\t\t});\n\t\t});\n\t},\n```\n\n``` wxml index.wxml\n<view id=\"fixed-view\" style=\"position: fixed; top: 0; display: flex; flex-direction: column;\">\n\t<titlebar /> <!-- 标题栏 -->\n\t<tabbar /> <!-- 选择标签栏 -->\n</view>\n<view style=\"position: absolute; top: {{dAbsolute}};\">\n\t<!-- 内容 -->\n</view>\n```\n\n经不同设备检验，效果良好。","source":"_posts/微信小程序：灵活适配不同标题栏高度的设备的方法.md","raw":"---\ntitle: 微信小程序：灵活适配不同标题栏高度的设备的方法\ndate: 2021-08-14 23:40:07\ntags: [微信小程序,fs]\ncategories: 微信小程序\ncomment: true\n---\n\n## 工程需求\n\n开发的应用：用微信小程序经由hera生成的跨平台移动端App。\n\n作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？\n\n首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。\n\n## 方案参考\n\n在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。\n\n私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：\n\n<!-- more -->\n\n## 最终方案\n\n### 大体思路如下：\n\n在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。\n\n### 主要代码：\n\n``` javascript index.js\n/* page */\n\tdata: {\n\t\tdAbsoluteTop: 0, //准备设置固定内容组件的高度\n\t},\n\n\tonLoad: function(){\n\t\tconst that = this;\n\t\tconst query = wx.createSelectorQuery();\n\t\tquery.select('#fixed-view').boundingClientRect();\n\t\tquery.selectViewport().scrollOffset();\n\t\tquery.exec(function(res){\n\t\t\tthat.setData({\n\t\t\t\tdAbsoluteTop: res[0].bottom //根据底部渲染\n\t\t\t});\n\t\t});\n\t},\n```\n\n``` wxml index.wxml\n<view id=\"fixed-view\" style=\"position: fixed; top: 0; display: flex; flex-direction: column;\">\n\t<titlebar /> <!-- 标题栏 -->\n\t<tabbar /> <!-- 选择标签栏 -->\n</view>\n<view style=\"position: absolute; top: {{dAbsolute}};\">\n\t<!-- 内容 -->\n</view>\n```\n\n经不同设备检验，效果良好。","slug":"微信小程序：灵活适配不同标题栏高度的设备的方法","published":1,"updated":"2021-08-20T04:54:00.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksk5blqq000dn0u6fqf29nom","content":"<h2 id=\"工程需求\"><a href=\"#工程需求\" class=\"headerlink\" title=\"工程需求\"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端App。</p>\n<p>作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？</p>\n<p>首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。</p>\n<h2 id=\"方案参考\"><a href=\"#方案参考\" class=\"headerlink\" title=\"方案参考\"></a>方案参考</h2><p>在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。</p>\n<p>私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：</p>\n<span id=\"more\"></span>\n\n<h2 id=\"最终方案\"><a href=\"#最终方案\" class=\"headerlink\" title=\"最终方案\"></a>最终方案</h2><h3 id=\"大体思路如下：\"><a href=\"#大体思路如下：\" class=\"headerlink\" title=\"大体思路如下：\"></a>大体思路如下：</h3><p>在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。</p>\n<h3 id=\"主要代码：\"><a href=\"#主要代码：\" class=\"headerlink\" title=\"主要代码：\"></a>主要代码：</h3><figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* page */</span></span><br><span class=\"line\">\t<span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">dAbsoluteTop</span>: <span class=\"number\">0</span>, <span class=\"comment\">//准备设置固定内容组件的高度</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">onLoad</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> that = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> query = wx.createSelectorQuery();</span><br><span class=\"line\">\t\tquery.select(<span class=\"string\">&#x27;#fixed-view&#x27;</span>).boundingClientRect();</span><br><span class=\"line\">\t\tquery.selectViewport().scrollOffset();</span><br><span class=\"line\">\t\tquery.exec(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">\t\t\tthat.setData(&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">dAbsoluteTop</span>: res[<span class=\"number\">0</span>].bottom <span class=\"comment\">//根据底部渲染</span></span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;,</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view id=&quot;fixed-view&quot; style=&quot;position: fixed; top: 0; display: flex; flex-direction: column;&quot;&gt;</span><br><span class=\"line\">\t&lt;titlebar /&gt; &lt;!-- 标题栏 --&gt;</span><br><span class=\"line\">\t&lt;tabbar /&gt; &lt;!-- 选择标签栏 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br><span class=\"line\">&lt;view style=&quot;position: absolute; top: &#123;&#123;dAbsolute&#125;&#125;;&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>经不同设备检验，效果良好。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"工程需求\"><a href=\"#工程需求\" class=\"headerlink\" title=\"工程需求\"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端App。</p>\n<p>作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？</p>\n<p>首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。</p>\n<h2 id=\"方案参考\"><a href=\"#方案参考\" class=\"headerlink\" title=\"方案参考\"></a>方案参考</h2><p>在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。</p>\n<p>私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：</p>","more":"<h2 id=\"最终方案\"><a href=\"#最终方案\" class=\"headerlink\" title=\"最终方案\"></a>最终方案</h2><h3 id=\"大体思路如下：\"><a href=\"#大体思路如下：\" class=\"headerlink\" title=\"大体思路如下：\"></a>大体思路如下：</h3><p>在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。</p>\n<h3 id=\"主要代码：\"><a href=\"#主要代码：\" class=\"headerlink\" title=\"主要代码：\"></a>主要代码：</h3><figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* page */</span></span><br><span class=\"line\">\t<span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">dAbsoluteTop</span>: <span class=\"number\">0</span>, <span class=\"comment\">//准备设置固定内容组件的高度</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">onLoad</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> that = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> query = wx.createSelectorQuery();</span><br><span class=\"line\">\t\tquery.select(<span class=\"string\">&#x27;#fixed-view&#x27;</span>).boundingClientRect();</span><br><span class=\"line\">\t\tquery.selectViewport().scrollOffset();</span><br><span class=\"line\">\t\tquery.exec(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">\t\t\tthat.setData(&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">dAbsoluteTop</span>: res[<span class=\"number\">0</span>].bottom <span class=\"comment\">//根据底部渲染</span></span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;,</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view id=&quot;fixed-view&quot; style=&quot;position: fixed; top: 0; display: flex; flex-direction: column;&quot;&gt;</span><br><span class=\"line\">\t&lt;titlebar /&gt; &lt;!-- 标题栏 --&gt;</span><br><span class=\"line\">\t&lt;tabbar /&gt; &lt;!-- 选择标签栏 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br><span class=\"line\">&lt;view style=&quot;position: absolute; top: &#123;&#123;dAbsolute&#125;&#125;;&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>经不同设备检验，效果良好。</p>"}],"PostAsset":[{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png","post":"cksk5blqc0000n0u69yt1c05l","slug":"compare-final.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/compare.png","post":"cksk5blqc0000n0u69yt1c05l","slug":"compare.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg","post":"cksk5blqc0000n0u69yt1c05l","slug":"path-compression.jpg","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png","post":"cksk5blqc0000n0u69yt1c05l","slug":"qf1.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png","post":"cksk5blqc0000n0u69yt1c05l","slug":"qf2.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png","post":"cksk5blqc0000n0u69yt1c05l","slug":"qu1.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png","post":"cksk5blqc0000n0u69yt1c05l","slug":"qu2.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png","post":"cksk5blqc0000n0u69yt1c05l","slug":"weighting.png","modified":1,"renderable":1},{"_id":"source/_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）/侧滑效果.gif","post":"cksk5blqp000an0u69icg6wgd","slug":"侧滑效果.gif","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cksk5blqc0000n0u69yt1c05l","category_id":"cksk5blqj0001n0u607bu9ssv","_id":"cksk5blqn0007n0u61v6fejc9"},{"post_id":"cksk5blqc0000n0u69yt1c05l","category_id":"cksk5blqm0004n0u69rqcfq11","_id":"cksk5blqn0008n0u6ealuhynj"},{"post_id":"cksk5blqo0009n0u61auvdoqy","category_id":"cksk5blqq000bn0u6g0rh9paj","_id":"cksk5blqu000hn0u63gt07ysd"},{"post_id":"cksk5blqp000an0u69icg6wgd","category_id":"cksk5blqq000bn0u6g0rh9paj","_id":"cksk5blqv000kn0u65bdo08ws"},{"post_id":"cksk5blqq000dn0u6fqf29nom","category_id":"cksk5blqq000bn0u6g0rh9paj","_id":"cksk5blqv000nn0u6bkcabxjt"}],"PostTag":[{"post_id":"cksk5blqc0000n0u69yt1c05l","tag_id":"cksk5blqk0002n0u6eday9b08","_id":"cksk5blqm0005n0u6bm0k6gld"},{"post_id":"cksk5blqc0000n0u69yt1c05l","tag_id":"cksk5blql0003n0u633t98ec7","_id":"cksk5blqm0006n0u670kd0fz9"},{"post_id":"cksk5blqo0009n0u61auvdoqy","tag_id":"cksk5blqq000cn0u67xye8kgt","_id":"cksk5blqv000jn0u6e5gn5r6m"},{"post_id":"cksk5blqo0009n0u61auvdoqy","tag_id":"cksk5blqs000fn0u6ghvj6s9t","_id":"cksk5blqv000ln0u6fs0ohowm"},{"post_id":"cksk5blqp000an0u69icg6wgd","tag_id":"cksk5blqq000cn0u67xye8kgt","_id":"cksk5blqw000pn0u6gnl38e6t"},{"post_id":"cksk5blqp000an0u69icg6wgd","tag_id":"cksk5blqs000fn0u6ghvj6s9t","_id":"cksk5blqw000qn0u647046dfn"},{"post_id":"cksk5blqq000dn0u6fqf29nom","tag_id":"cksk5blqq000cn0u67xye8kgt","_id":"cksk5blqx000sn0u6dumr9vhv"},{"post_id":"cksk5blqq000dn0u6fqf29nom","tag_id":"cksk5blqs000fn0u6ghvj6s9t","_id":"cksk5blqx000tn0u658wt8uei"}],"Tag":[{"name":"JS","_id":"cksk5blqk0002n0u6eday9b08"},{"name":"算法","_id":"cksk5blql0003n0u633t98ec7"},{"name":"微信小程序","_id":"cksk5blqq000cn0u67xye8kgt"},{"name":"fs","_id":"cksk5blqs000fn0u6ghvj6s9t"}]}}
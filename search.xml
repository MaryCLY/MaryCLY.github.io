<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS: Union-find(quick-union + weighting + path compression + map)</title>
    <url>/JS-Union-find-quick-union-weighting-path-compression-map/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。</p>
<h3 id="用于解决的问题"><a href="#用于解决的问题" class="headerlink" title="用于解决的问题"></a>用于解决的问题</h3><p>假定一个学校的圈子中，有A,B,C...这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。</p>
<h3 id="核心的方法需求"><a href="#核心的方法需求" class="headerlink" title="核心的方法需求"></a>核心的方法需求</h3><p>Union(p, q): 将点p和点q建立连接的方法。</p>
<p>Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。</p>
<span id="more"></span>

<h2 id="基本构建思路"><a href="#基本构建思路" class="headerlink" title="基本构建思路"></a>基本构建思路</h2><h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick-Find"></a>Quick-Find</h3><p>这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。</p>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png" alt="quick-find图解"></p>
<h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png" alt="quick-find代码"></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果一条很长的链被合并，可能需要大量地改变root值。</p>
<h3 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick-Union"></a>Quick-Union</h3><p>这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。</p>
<p>此时使用类似链表的数据结构十分恰当。</p>
<h4 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png" alt="quick-union图解"></p>
<h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png" alt="quick-union代码"></p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>如果有一条很长的链，查找效率会很低。</p>
<h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><h4 id="共通点"><a href="#共通点" class="headerlink" title="共通点"></a>共通点</h4><p>不管是quick-find还是quick-union，算法中都有这样的共通点：</p>
<p>1.每次union时会判断是否同根，如果是则直接跳过。</p>
<p>2.在进行两个子集的union时，会连接两个子集的root。</p>
<h4 id="时间复杂度比较"><a href="#时间复杂度比较" class="headerlink" title="时间复杂度比较"></a>时间复杂度比较</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/compare.png" alt="时间复杂度比较"></p>
<p>因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。</p>
<p>由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。</p>
<h2 id="Quick-Union算法的优化"><a href="#Quick-Union算法的优化" class="headerlink" title="Quick-Union算法的优化"></a>Quick-Union算法的优化</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。</p>
<p>结构：{key: id, value: parent_id}</p>
<h3 id="Weighting"><a href="#Weighting" class="headerlink" title="Weighting"></a>Weighting</h3><p>Weighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。</p>
<h4 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png" alt="weighting图解"></p>
<h4 id="代码变动"><a href="#代码变动" class="headerlink" title="代码变动"></a>代码变动</h4><p>由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。</p>
<p>map结构变化: {key: id, value: {parent: parent_id, size: size}}</p>
<p>union时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身</p>
<h3 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h3><p>Path Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。</p>
<h4 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg" alt="path-compression图解"></p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>quick-union + weighting + path compression + map</p>
<figure class="highlight javascript"><figcaption><span>Union-Find.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个节点保存的结构</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">parent, size</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent || <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.size = size || <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">p, q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(p)||!map.has(q))&#123;</span><br><span class="line">        <span class="comment">//有一个不在map里，说明是游离节点，自动设为child</span></span><br><span class="line">        <span class="keyword">if</span>(!map.has(p))&#123;</span><br><span class="line">            <span class="keyword">var</span> child = p, parent = find(q); <span class="comment">//path compression 父母直接设给根节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> child = q, parent = find(p);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(child, <span class="keyword">new</span> Node(parent, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//均存在map中，需要进行weighting的两个节点</span></span><br><span class="line">        <span class="keyword">const</span> pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; <span class="comment">//暂存两个节点的root</span></span><br><span class="line">        <span class="keyword">if</span>(pr===qr)&#123;</span><br><span class="line">            <span class="comment">//如果已经连通，不需要再连接了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prs &lt; qrs)&#123;</span><br><span class="line">            <span class="comment">//把容量更小的那个设为child被合并</span></span><br><span class="line">            <span class="keyword">var</span> child = pr, parent = qr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> child = qr, parent = pr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//root应该都存在map中</span></span><br><span class="line">        map.get(child).parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(parent))&#123;</span><br><span class="line">        map.set(parent, <span class="keyword">new</span> Node(parent, map.get(child).size+<span class="number">1</span>)); <span class="comment">//map中新建一个root node，root的parent设给自己</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.get(parent).size+=map.get(child).size+<span class="number">1</span>; <span class="comment">//合并size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(p))&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(map.get(p).parent!=p)&#123;</span><br><span class="line">        <span class="comment">//如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent</span></span><br><span class="line">        p = map.get(p).parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isConnected</span>(<span class="params">p, q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (find(p)===find(q));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最后贴上algorithms书中的各种方法的时间复杂度：</p>
<p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png" alt="时间复杂度比较"></p>
<p>有weighting和path compression的quick union时间复杂度无限接近1。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Pow(x, n)%10 （快速幂+大数取模问题）</title>
    <url>/Pow-x-n-10-%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。</p>
<p>任何数的0次方都是1.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>不难发现规律： ((x%y)^n)%y = (x^n)%y</p>
<span id="more"></span>

<p>因此很容易想到，第一步先把题目中的底数x提取成最后一位。但如果直接用编程语言库里自带的Math.pow(x, n)，依然可能会直接得到一个很大的结果，取模依然可能不正确。因此，我们需要考虑自己实现一套幂运算，在过程中多次取最后一位，这样就会使得所有的运算都是小数取模了。</p>
<p>快速幂公式参考<a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/">LeetCode 50. Pow(x, n) （快速幂，清晰图解）-Krahets</a></p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>根据观察不难发现，0-9为底的幂运算取最后一位是存在一个循环的。我们先求出这个循环的规律，然后判断n是在循环的第几位，即可直接得到结果。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>由于Javascript BigInt过于复杂，没有实现x, y为大数时的算法。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><figcaption><span>公用方法.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mod10</span>(<span class="params"> num </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>思路1.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastDigitQuickPow</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = mod10(str1); <span class="comment">// x直接取最后一位</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(str2); <span class="comment">// 可能涉及大数，转成BigInt</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 任何数的0次方都是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = x; n; i = mod10(i * i), n = n &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="comment">// 每次使i平方，然后n减少一位二进制位（位右移）</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = mod10(res * i); <span class="comment">// 如果当前位是1，则在结果中增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>思路2.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastDigit</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = mod10(str1); <span class="comment">// x直接取最后一位</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(str2); <span class="comment">// 可能涉及大数，转成BigInt</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 任何数的0次方都是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> loopCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> loopNum = [x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = x; <span class="literal">true</span>;) &#123;</span><br><span class="line">        i = mod10(i * x); <span class="comment">// 查找循环的下一位</span></span><br><span class="line">        loopCount++;</span><br><span class="line">        <span class="keyword">if</span> (i === x) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 得到循环的总长度loopCount和取余对应loopNum[]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loopNum.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> resMod = (n - <span class="number">1</span>) % loopCount; <span class="comment">// 获取循环中的余数（左移一位）</span></span><br><span class="line">    <span class="keyword">return</span> loopNum[resMod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
        <tag>快速幂</tag>
        <tag>大数越界</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件复制实现模块放大终极优化版</title>
    <url>/Vue%E7%BB%84%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96%E7%89%88/</url>
    <content><![CDATA[<p>继上章研究出模块放大的实现方法并选择了 Vue 组件复制的方法后，将该方法投入了实践。在开发过程中还是觉得之前设计的调用方式有些繁琐，于是灵机一动，改良了一下代码。接下来将放出完整的关键代码，没看上一章也没关系。</p>
<span id="more"></span>

<h3 id="用于渲染的组件"><a href="#用于渲染的组件" class="headerlink" title="用于渲染的组件"></a>用于渲染的组件</h3><figure class="highlight html"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;component&quot;</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperArea&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 遮罩，点击关闭 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperAreaMask&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 中心的一层包装，可设置背景 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapper&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: finalWidth + &#x27;px&#x27;, height: finalHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 这里设置了一个enlarged属性来便于组件内部分辨是否被放大，按需添加 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:is</span>=<span class="string">&quot;component&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-bind</span>=<span class="string">&quot;props&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;transform-origin: top left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:style</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">          width: initialWidth + &#x27;px&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          height: initialHeight + &#x27;px&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          transform: `scale($&#123;scale&#125;)`,</span></span></span><br><span class="line"><span class="string"><span class="tag">        &#125;&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">enlarged</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">component</span>: <span class="literal">null</span>, <span class="comment">// 渲染放大的组件，顺便控制是否显示</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">props</span>: &#123;&#125;, <span class="comment">// 将输入组件的参数</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">initialWidth</span>: <span class="number">0</span>, <span class="comment">// 原始组件的宽度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">initialHeight</span>: <span class="number">0</span>, <span class="comment">// 原始组件的高度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">finalWidth</span>: <span class="number">0</span>, <span class="comment">// 放大后的宽度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">finalHeight</span>: <span class="number">0</span>, <span class="comment">// 放大后的高度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">scale</span>: <span class="number">1</span>, <span class="comment">// 应放大的倍数</span></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收参数并显示浮层的方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">handler</span>(<span class="params">component, initialWidth, initialHeight, props = &#123;&#125;</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!component || !initialWidth || !initialHeight) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 预防异常</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.initialWidth = initialWidth;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.initialHeight = initialHeight;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 根据情况计算应放大的效果，获取finalWidth, finalHeight和scale.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> maxWidth = <span class="number">2400</span>, maxHeight = <span class="number">1200</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> maxWidthScale = maxWidth / <span class="built_in">this</span>.initialWidth, maxHeightScale = maxHeight / <span class="built_in">this</span>.initialHeight;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.scale = <span class="built_in">Math</span>.min(maxWidthScale, maxHeightScale);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.finalWidth = <span class="built_in">this</span>.initialWidth * <span class="built_in">this</span>.scale;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.finalHeight = <span class="built_in">this</span>.initialHeight * <span class="built_in">this</span>.scale;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置组件和参数，将会开始渲染</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.component = component;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.props = props;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 关闭浮层的方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.component = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.props = &#123;&#125;;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapperArea</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 覆盖全屏 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">z-index</span>: <span class="number">9999</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapperAreaMask</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 覆盖全屏，第一层 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>); <span class="comment">/* 遮罩颜色 */</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapper</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 居中，第二层 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="number">#061d33</span>; <span class="comment">/* 设置的深色背景颜色，用于显示浅色调的内容 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>该组件需要被设置在较低层级的地方，如#app 元素中，以使其 z-index 能否覆盖所有的图层。</strong></p>
<figure class="highlight html"><figcaption><span>App.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">enlarge-wrapper</span>&gt;</span><span class="tag">&lt;/<span class="name">enlarge-wrapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>上一个版本需要更改父组件，较为繁琐，本版本仅需操作需要复制放大的组件。</p>
<p>如果父组件中注册了我们的目标组件，名称为TargetComponent：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target-component</span>&gt;</span><span class="tag">&lt;/<span class="name">target-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> TargetComponent <span class="keyword">from</span> <span class="string">&#x27;[path]&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123; TargetComponent &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件中，需要这样调用放大功能：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 需要知道自己在父组件中的注册名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;enlarge(&#x27;TargetComponent&#x27;)&quot;</span>&gt;</span>Enlarge Myself<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">/* 按需获取enlarged属性 */</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="javascript">  props: &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">    enlarged: &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">      type: Boolean,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">      default: false</span></span></span><br><span class="line"><span class="comment"><span class="javascript">    &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">  &#125;, </span></span></span><br><span class="line"><span class="comment"><span class="javascript">  */</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">enlarge</span>(<span class="params">name</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> el = <span class="built_in">this</span>.$el;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> component = <span class="built_in">this</span>.$parent?.$options?.components[name];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!el || !component) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 保存当前的props列表及对应的值，用于再次渲染</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 过滤enlarged属性，因为在enlarge-wrapper中会直接置为true</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 保存成键值对的形式，用于传递给v-bind方法</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> propsNameList = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.$options.props).filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== <span class="string">&#x27;enlarged&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> props = propsNameList.reduce(<span class="function">(<span class="params">cum, v</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        cum[v] = <span class="built_in">this</span>[v];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> cum;</span></span><br><span class="line"><span class="javascript">      &#125;, &#123;&#125;);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 触发enlarge-wrapper组件中的handler方法，这里用的事件总线</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$bus.emit(<span class="string">&#x27;enlarge&#x27;</span>, component, el.clientWidth, el.clientHeight, props);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，你可以将以上的props和methods保存到mixin，方便在每个需要放大的组件中调用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然优化的代码行数不多，但是可以把代码局限在需要调用的目标组件中，缩小影响的代码范围。此外，能够复制props也是比较有用的功能拓展。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue router中params和query的区别</title>
    <url>/Vue-router%E4%B8%ADparams%E5%92%8Cquery%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在vue开发中，页面跳转时常需要传递一些参数。如果我们使用vue router来进行路由，通常有两种方式进行参数的传递，一种是使用params, 一种是使用query. 在下文中我将介绍一下个人使用中感受到的这两者的区别。</p>
<span id="more"></span>

<h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><p>如果在url中定义了params的绑定，则可以直接在url中传递params(&#39;/articles/:id&#39;), 否则只能通过vue router的方法（router-link或$router.push等）传递路径对象时添加params. params可以直接传递值和对象，并且定义了router中的props属性后，能在页面中通过props属性去获取。如果不通过props, 也可以使用this.$route.params获取。</p>
<h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>query既可以直接在url后添加(&#39;marycly.github.io/index?pageId=114514&#39;), 也可以通过vue router的方法传递路径对象时添加query. query可以传递值，但传递对象效果不稳定，最好将传递的对象通过JSON来保存。在页面中可以使用this.$route.query来获取query的内容。</p>
<h3 id="在页面跳转中的实际应用表现"><a href="#在页面跳转中的实际应用表现" class="headerlink" title="在页面跳转中的实际应用表现"></a>在页面跳转中的实际应用表现</h3><p>如果url中没有定义与params绑定的动态路由，个人不建议使用params来传递信息。因为这种情况下url里面并不包含params的信息，在浏览器历史前进/回退的过程中就会丢失，因此只能实现一个单向的传递。如果需要支持时常在页面之间跳转并保留信息的话，建议使用query.</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>一些使用UI组件库的经验</title>
    <url>/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>近期进行前端开发的过程中，接触了一些比较全面方便的UI库，有Ant Design Vue, 以及Vant. 这些UI库使用起来比自己造零件要方便且美观，不过在初使用的过程中也会遇到一些比较疑惑的问题，因此写下本文记录一下使用这些UI组件库所积累的一些经验。</p>
<span id="more"></span>

<h2 id="主题定制"><a href="#主题定制" class="headerlink" title="主题定制"></a>主题定制</h2><p>通常来说，UI组件库都提供全局的主题定制的功能，如某个组件的默认颜色或整体的颜色风格等，一般可以在官网找到更改方式，譬如Ant Design Vue 3的主题定制方式就在<a href="https://antdv.com/docs/vue/customize-theme-cn">定制主题 - Ant Design Vue</a>. Vue项目通常需要修改全局选项文件。</p>
<h2 id="调整内部样式"><a href="#调整内部样式" class="headerlink" title="调整内部样式"></a>调整内部样式</h2><p>在使用UI组件库的过程中，有时候需要调整个别组件的样式，而不改变全局的UI库参数。如果直接打开浏览器的开发者检查工具，可以看到UI库组件的内部存在一些class, 它们定义了那些你不想要的样式。这种时候，如果在源代码中直接用类名选择器设置这些class的样式，会发现并没有效果。这种时候，使用/deep/ .target-class 的选择器来定义你需要更改的样式，就能起到效果（LESS预编译语言下）。有一篇类似情况的文章可供参考：<a href="https://www.jianshu.com/p/5bd38a4d4d64">&gt;&gt;&gt;或/deep/的作用</a></p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件的复制或HTML快照，最终实现模块放大显示的功能</title>
    <url>/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>首先介绍一下开展本次尝试的需求背景：</p>
<p>该项目是一个 Web 大屏应用。有时在演示的时候，因为投影质量差的问题，如果字体不够大，就很难看清内容。产品提议开发一个放大功能，在点击某模块的时候能够放大展示。</p>
<span id="more"></span>

<p>延申的需求分析：</p>
<ol>
<li><p>尽可能保留组件中的各类交互，如果无法实现才使用快照。</p>
</li>
<li><p>因为大屏开发的元素排列较为紧密，因此没有做 CSS 的屏幕比例适应。如果改变了模块的宽高大小，可能放大后会造成样式偏差。而且，对每个模块都定制放大的 CSS 也不太可能，成本过高。因此，尽可能在保留原始模块元素大小的基础上，使用 transform: scale 来进行放大。</p>
</li>
<li><p>保证放大显示区域在最上层。根据本应用的结构，将放大显示区域插入#app 节点中。</p>
</li>
<li><p>关闭的方式。可以设计成点击遮罩关闭。</p>
</li>
</ol>
<p>在完成最终开发的过程中，尝试了三种方法，最终综合考虑实现难度和实现效果选择了其中一种。</p>
<h3 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h3><p>项目中的真实实现效果如图，所有数据已用劣质工具打码……</p>
<ul>
<li>原始元素：</li>
</ul>
<p><img src="https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/%E5%8E%9F%E5%A7%8B%E5%85%83%E7%B4%A0.png" alt="原始元素"></p>
<ul>
<li>放大效果 1：</li>
</ul>
<p><img src="https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C.png" alt="放大效果1"></p>
<ul>
<li>放大效果 2：</li>
</ul>
<p><img src="https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C1.png" alt="放大效果2"></p>
<h3 id="基础的放大显示区域组件"><a href="#基础的放大显示区域组件" class="headerlink" title="基础的放大显示区域组件"></a>基础的放大显示区域组件</h3><figure class="highlight html"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;component&quot;</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperArea&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 遮罩，点击关闭 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperAreaMask&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 中心的一层包装，可设置背景 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapper&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: finalWidth + &#x27;px&#x27;, height: finalHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">component</span>: <span class="literal">null</span>, <span class="comment">// 渲染放大的组件，顺便控制是否显示</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">initialWidth</span>: <span class="number">0</span>, <span class="comment">// 原始组件的宽度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">initialHeight</span>: <span class="number">0</span>, <span class="comment">// 原始组件的高度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">finalWidth</span>: <span class="number">0</span>, <span class="comment">// 放大后的宽度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">finalHeight</span>: <span class="number">0</span>, <span class="comment">// 放大后的高度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">scale</span>: <span class="number">1</span>, <span class="comment">// 应放大的倍数</span></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapperArea</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 覆盖全屏 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">z-index</span>: <span class="number">9999</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapperAreaMask</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 覆盖全屏，第一层 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>); <span class="comment">/* 遮罩颜色 */</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapper</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 居中，第二层 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="number">#061d33</span>; <span class="comment">/* 设置的深色背景颜色，用于显示浅色调的内容 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将该组件插入 body 或#app 节点下，设置为一个最高层级的覆盖物。</p>
<h3 id="方法一：cloneNode"><a href="#方法一：cloneNode" class="headerlink" title="方法一：cloneNode"></a>方法一：cloneNode</h3><p>这个方法的核心是使用 cloneNode 方法进行 DOM 节点复制。</p>
<figure class="highlight javascript"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 接收参数并显示浮层的方法</span></span><br><span class="line">    <span class="function"><span class="title">handler</span>(<span class="params">component, initialWidth, initialHeight</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 使用任何方法（如querySelector）获取到目标节点component, 然后用clientWidth和clientHeight属性获取到initialWidth和initialHeight参数</span></span><br><span class="line">      <span class="keyword">if</span> (!component || !initialWidth || !initialHeight) &#123;</span><br><span class="line">        <span class="comment">// 预防异常</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.initialWidth = initialWidth;</span><br><span class="line">      <span class="built_in">this</span>.initialHeight = initialHeight;</span><br><span class="line">      <span class="comment">// 根据情况计算应放大的效果，获取finalWidth, finalHeight和scale.</span></span><br><span class="line">      <span class="keyword">const</span> maxWidth = <span class="number">2400</span>, maxHeight = <span class="number">1200</span>;</span><br><span class="line">      <span class="keyword">const</span> maxWidthScale = maxWidth / <span class="built_in">this</span>.initialWidth, maxHeightScale = maxHeight / <span class="built_in">this</span>.initialHeight;</span><br><span class="line">      <span class="built_in">this</span>.scale = <span class="built_in">Math</span>.min(maxWidthScale, maxHeightScale);</span><br><span class="line">      <span class="built_in">this</span>.finalWidth = <span class="built_in">this</span>.initialWidth * <span class="built_in">this</span>.scale;</span><br><span class="line">      <span class="built_in">this</span>.finalHeight = <span class="built_in">this</span>.initialHeight * <span class="built_in">this</span>.scale;</span><br><span class="line">      <span class="comment">// 克隆节点</span></span><br><span class="line">      <span class="keyword">const</span> el = component.cloneNode(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 设置样式</span></span><br><span class="line">      el.style.width = <span class="built_in">this</span>.initialWidth;</span><br><span class="line">      el.style.height = <span class="built_in">this</span>.initialHeight;</span><br><span class="line">      el.style.transform = <span class="string">`scale(<span class="subst">$&#123;<span class="built_in">this</span>.scale&#125;</span>)`</span>;</span><br><span class="line">      el.style.transformOrigin = <span class="string">&#x27;top left&#x27;</span>;</span><br><span class="line">      <span class="comment">// 插入节点</span></span><br><span class="line">      <span class="keyword">const</span> parent = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#EnlargeWrapper&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">        <span class="comment">// 预防异常</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      parent.appendChild(el);</span><br><span class="line">      <span class="comment">// 记录对象并显示浮层</span></span><br><span class="line">      <span class="built_in">this</span>.component = el;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 关闭浮层的方法</span></span><br><span class="line">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> component = <span class="built_in">this</span>.component;</span><br><span class="line">      <span class="comment">// 隐藏</span></span><br><span class="line">      <span class="built_in">this</span>.component = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 删除节点</span></span><br><span class="line">      <span class="keyword">if</span> (component) &#123;</span><br><span class="line">        component.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：可以以较快的速度生成 HTML 节点快照，一般情况下对静态 HTML、CSS 的渲染效果很好。</p>
<p>缺点：丢弃了所有的 JavaScript，因此无法交互，并且没有成功渲染 ECharts 图表。</p>
<h3 id="方法二：html2canvas"><a href="#方法二：html2canvas" class="headerlink" title="方法二：html2canvas"></a>方法二：html2canvas</h3><p>第二个尝试，考虑用 html2canvas 将代码转为 canvas 来展示。</p>
<p>首先需在项目中下载 html2canvas 依赖库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install html2canvas</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">yarn add html2canvas</span><br></pre></td></tr></table></figure>

<p>然后只需修改方法一的部分代码：</p>
<figure class="highlight javascript"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> html2canvas <span class="keyword">from</span> <span class="string">&#x27;html2canvas&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 接收参数并显示浮层的方法（添加async）</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">handler</span>(<span class="params">component, initialWidth, initialHeight</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 修改方法一中的【克隆节点】步骤</span></span><br><span class="line">      <span class="keyword">const</span> el = <span class="keyword">await</span> html2canvas(component);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：一般情况下对静态 HTML、CSS 的渲染效果较好，而且如果有需求可以保存canvas，导出图片。</p>
<p>缺点：生成速度较慢；放大后画质的损失略大于方法一；同样也无法交互；不支持高级的CSS属性，对于复杂的元素也经常有各种各样的问题。</p>
<h3 id="方法三：重新挂载Vue组件"><a href="#方法三：重新挂载Vue组件" class="headerlink" title="方法三：重新挂载Vue组件"></a>方法三：重新挂载Vue组件</h3><p>先决条件：目标模块是一个可以独立运行的组件。</p>
<p>首先需要在EnlargeWrapper组件中增加一个&lt;component&gt;，以渲染Vue组件。如果使用标签定义元素，则可以直接在&lt;component&gt;标签中定义样式，而无需通过DOM对象来给style属性赋值。</p>
<figure class="highlight html"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;component&quot;</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperArea&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperAreaMask&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapper&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: finalWidth + &#x27;px&#x27;, height: finalHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在这里插入一个component --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:is</span>=<span class="string">&quot;component&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;transform-origin: top left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:style</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">          width: initialWidth + &#x27;px&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          height: initialHeight + &#x27;px&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          transform: `scale($&#123;scale&#125;)`,</span></span></span><br><span class="line"><span class="string"><span class="tag">        &#125;&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后更改handler和close方法，把DOM操作的部分移除。</p>
<figure class="highlight javascript"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">handler</span>(<span class="params">component, initialWidth, initialHeight</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ... 获取原始高度和计算放大后的效果</span></span><br><span class="line">      <span class="comment">// 删除方法一、方法二的【克隆节点】【设置样式】和【插入节点】步骤</span></span><br><span class="line">      <span class="comment">// 直接赋值component标签的is属性</span></span><br><span class="line">      <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.component = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 去掉了删除DOM元素的部分</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何获取传给handler的component参数：</p>
<p>在目标模块的父组件中，通常注册方法是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;[path]&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; ComponentA &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种情况下，methods中比较难获取到组件模板，即ComponentA这个引用常量。</p>
<p>因此可以将代码修改成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;[path]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> components = &#123; ComponentA &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; ...components &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后就可以在method中通过名称ComponentA获取到组件模板，通过事件总线传给EnlargeWrapper.handler;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">enlarge</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> component = components[id];</span><br><span class="line">      <span class="keyword">const</span> el = <span class="built_in">this</span>.$refs[id];</span><br><span class="line">      <span class="built_in">this</span>.$bus.emit(<span class="string">&#x27;enlarge&#x27;</span>, component, el.clientWidth, el.clientHeight);</span><br><span class="line">      <span class="comment">// 注：此为示例，事件总线需自行配置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：在不依赖其他组件运行的情况下，可以最大程度地复刻目标模块，保留一切交互。</p>
<p>缺点：会出现组件初挂载的加载过程；如果没有单独处理，不能体现放大时的组件状态；需要更改父组件，代码会更复杂。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本应用的情况下，方法一和方法二都出现了比较明显的实现偏差，但是对于方法三的实施条件充足，因此最终使用的是方法三。</p>
<p>但是，根据不同的应用情况和需求，您可以参考这三种方法来选择最合适的解决方案。希望这些思路能帮到您。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>使用AWS Amplify搭建一个Degrees of Lewdity(DOL)私服</title>
    <url>/%E4%BD%BF%E7%94%A8AWS-Amplify%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AADegrees-of-Lewdity-DOL-%E7%A7%81%E6%9C%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近迷上了一款文字纯爱战斗冒险游戏（雾），我本人是用 iPhone 手机玩所以一直都是玩的 web 版本。一开始玩的是汉化组提供的 GitHub Pages 线上版，后来又玩了 DOL-Lyra 的美化封装版，也是有 GitHub Pages 线上版。玩了几个档以后开始尝试自己折腾模组，学会用<a href="https://github.com/cphxj123">北极星</a>大佬提供的美化模组生成器，可以把一些旧时代的直接覆盖游戏图片的美化模组封装成 mod loader 版本。后来又想尝试一下<a href="https://github.com/cphxj123/Dol-BJX-Ex">北极星扩展</a>，这回提供的是游戏本体 html 且没有直接提供的线上部署版，于是想着尝试自己弄一个静态 web 服务来托管这个游戏，并且看看能不能做一些不同的美化组合的快捷切换方式（mod loader 的模组顺序和启用切换还是太累，不是很好用）。最后算是弄出来了一个比较满意的成果，于是发个帖子分享一下我的操作路径。</p>
<span id="more"></span>

<h2 id="托管服务的选择"><a href="#托管服务的选择" class="headerlink" title="托管服务的选择"></a>托管服务的选择</h2><p>首先作为个人自用的小站点，也没有安全性要求，优先选择便宜甚至免费的服务。目前 GitHub Pages 托管静态站点是免费无限制使用的；AWS Amplify 是前 12 个月免费，不使用 SSR 的话部署不到 1GB 的数据月费也很低，最多不到 1 刀吧。考虑了一下 AWS 我没用过，这个网站也没有公开的需求，干脆用它搭一个试试。（Github Pages 也很好的，推荐使用）</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>现在主流的模组管理方法是通过 mod loader 来管理，网络上都可以直接下到内置 mod loader 的游戏本体。它们基本上只包含一个 html 文件，原版图片包和 i18n 等都需要通过 mod 的形式传入。</p>
<ul>
<li><a href="https://github.com/Eltirosto/Degrees-of-Lewdity-Chinese-Localization/releases">最新汉化版游戏本体</a></li>
<li><a href="https://github.com/cphxj123/Dol-BJX-Ex">包含北极星拓展的汉化版游戏本体</a></li>
</ul>
<p>下载了游戏本体后，还需要下载所需预安装的相关 mod 文件。</p>
<h2 id="单个游戏程序的部署代码"><a href="#单个游戏程序的部署代码" class="headerlink" title="单个游戏程序的部署代码"></a>单个游戏程序的部署代码</h2><p>以最新汉化版游戏本体为例，游戏本体关键文件目录是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.html</span><br><span class="line">style.css</span><br></pre></td></tr></table></figure>

<p>（注：release 包里有多个文件，只有 html 和 css 这两个是游戏本体）</p>
<p>如果需要在进入游戏程序时预加载模组，我们需要在 index.html 的同目录下新建一个 modList.json 文件，里面的内容是一个包含模组加载路径的数组。预加载的模组可以存放在服务器上，我们就直接在根目录下建一个 mods 文件夹，里面存放.mod.zip 文件，然后使用相对路径引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.html</span><br><span class="line">style.css</span><br><span class="line">modList.json +</span><br><span class="line">mods +</span><br><span class="line">- GameOriginalImagePack-0.4.5.3.mod.zip +</span><br><span class="line">- ModI18N-0.4.5.3-chs-alpha1.5.0.mod.zip +</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><figcaption><span>modList.json</span></figcaption><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">&quot;mods/GameOriginalImagePack-0.4.5.3.mod.zip&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mods/ModI18N-0.4.5.3-chs-alpha1.5.0.mod.zip&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如此这般，单个游戏程序的部署代码就完成了。你可以建一个 GitHub 仓库来管理它。</p>
<h2 id="用-AWS-Amplify-部署"><a href="#用-AWS-Amplify-部署" class="headerlink" title="用 AWS Amplify 部署"></a>用 AWS Amplify 部署</h2><p>在 AWS 控制台里可以找到这样的选项：“创建静态 web 服务”，进入配置页，连接到你的 GitHub 仓库并选择相应分支。可以允许 AWS 在 GitHub 提交更新时自动部署。配置项按照默认的来即可，等待 AWS 进行初次构建和部署，提示完成以后这个服务就创建好了。</p>
<p>浏览器通常会自动以 index.html 作为重定向入口，所以部署成功后直接访问 AWS 提供的域名就会进到游戏里面，打开 mod loader 就可以看到你在 modList.json 中选择的 mod 已经加载。如果你有自己的域名，可以不使用 AWS 提供的随机域名，在应用程序设置-域管理中绑定自己的域名。</p>
<p>如果你不想让陌生人访问你的站点，可以在应用程序设置-访问控制中添加限制，访问站点时会要求输入用户名和密码。</p>
<h2 id="在一个站点上实现不同模组组合的切换"><a href="#在一个站点上实现不同模组组合的切换" class="headerlink" title="在一个站点上实现不同模组组合的切换"></a>在一个站点上实现不同模组组合的切换</h2><p>如果你也像我一样需要经常调整 mod 组合，那么可以接着看下去。大致的思路是做多个子页面，每个子页面都有一个 index.html 和 modList.json，mod 文件则都放在一个文件夹里复用。文件目录大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mods</span><br><span class="line">- mod1.mod.zip</span><br><span class="line">- mod2.mod.zip</span><br><span class="line">game1</span><br><span class="line">- index.html</span><br><span class="line">- modList.json</span><br><span class="line">game2</span><br><span class="line">- index.html</span><br><span class="line">- modList.json</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure>

<p>代码编写示例如下：</p>
<figure class="highlight json"><figcaption><span>game1/modList.json</span></figcaption><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">&quot;../mods/mod1.mod.zip&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><figcaption><span>game2/modList.json</span></figcaption><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="string">&quot;../mods/mod2.mod.zip&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一个简陋的选择页 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Degrees of Lewdity 游戏选择页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/game1&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span>game1&lt;/a</span><br><span class="line">        &gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/game2&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span>game2&lt;/a</span><br><span class="line">        &gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我自己使用的部署代码可以参考：<a href="https://github.com/MaryCLY/Degrees-of-Lewdity-Chinese-Localization/tree/build_clymini">GitHub链接</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用这种方式实现的模组组合切换我还是比较满意的，首先是静态网站无需搭后端服务，总共的存储数据量也不是很大。因为是同一个站点，浏览器缓存是共通的，所以切换mod组合甚至本体也不需要导入导出存档（虽然本体切换有跳error的风险，但是保留成就点数还是需要导存档的啊）。日后如果有时间的话也可以研究研究有没有更省空间的方式来做这样的切换模组服务。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>DOL</tag>
        <tag>AWS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</title>
    <url>/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="工程需求"><a href="#工程需求" class="headerlink" title="工程需求"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端APP。</p>
<p>在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。</p>
<h2 id="方案参考"><a href="#方案参考" class="headerlink" title="方案参考"></a>方案参考</h2><p>由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。</p>
<p>参考链接：<a href="https://blog.csdn.net/LiaoFengJi/article/details/105218664">https://blog.csdn.net/LiaoFengJi/article/details/105218664</a></p>
<span id="more"></span>

<h2 id="提炼代码如下："><a href="#提炼代码如下：" class="headerlink" title="提炼代码如下："></a>提炼代码如下：</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;touchStart&quot; bindtouchmove=&quot;touchMove&quot;&gt;</span><br><span class="line">	&lt;!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 --&gt;</span><br><span class="line">	&lt;view class=&quot;item-left&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">		&lt;!-- 每条要显示的内容 --&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">	&lt;view class=&quot;item-right&quot;&gt;</span><br><span class="line">		&lt;view class=&quot;btn-right&quot; bindtap=&quot;setTopItem&quot;&gt;置顶&lt;/view&gt;</span><br><span class="line">		&lt;view class=&quot;btn-right&quot; bindtap=&quot;deleteItem&quot;&gt;删除&lt;/view&gt;</span><br><span class="line">	&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>index.wxss</span></figcaption><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 内容部分 */</span><br><span class="line">.item-left &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  -webkit-transition: all 0.4s;</span><br><span class="line">  transition: all 0.4s;</span><br><span class="line">  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 按钮部分 */</span><br><span class="line">.item-right &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  width: 400rpx; /*根据需要调整*/</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class="line">  -webkit-transition: all 0.4s;</span><br><span class="line">  transition: all 0.4s;</span><br><span class="line">  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btn-right &#123;</span><br><span class="line">  width: 50%; /*这里根据自己的需要划成了两半*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 向左滑动 */</span><br><span class="line">.touch-move-active .item-left,</span><br><span class="line">.touch-move-active .item-right &#123;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  -webkit-transform: translateX(0);</span><br><span class="line">  transform: translateX(0);</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Page */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">dataList</span>: [<span class="comment">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class="line">    <span class="attr">startX</span>: <span class="number">0</span>,<span class="comment">// 设置开始的位置X</span></span><br><span class="line">    <span class="attr">startY</span>: <span class="number">0</span>,<span class="comment">// 设置开始的位置Y</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始滑动</span></span><br><span class="line">  <span class="function"><span class="title">touchStart</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataList = <span class="built_in">this</span>.data.dataList;</span><br><span class="line">    dataList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 让原先滑动的块隐藏</span></span><br><span class="line">      <span class="keyword">if</span> (item.isTouchMove) &#123;</span><br><span class="line">        item.isTouchMove = !item.isTouchMove;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 初始化开始位置</span></span><br><span class="line">    <span class="built_in">this</span>.data.startX = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">    <span class="built_in">this</span>.data.startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">	<span class="comment">// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData</span></span><br><span class="line">	&#125;,</span><br><span class="line">  <span class="comment">// 滑动的过程</span></span><br><span class="line">  <span class="function"><span class="title">touchMove</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> moveX = e.changedTouches[<span class="number">0</span>].clientX,</span><br><span class="line">      moveY = e.changedTouches[<span class="number">0</span>].clientY,</span><br><span class="line">      curIndex = e.currentTarget.dataset.index, </span><br><span class="line">      <span class="comment">//注意，wxml里面一定要设置data-index=&quot;&#123;&#123;index&#125;&#125;&quot;,这样e.currentTarget.dataset中才会传index的值</span></span><br><span class="line">      dataList = <span class="built_in">this</span>.data.dataList,</span><br><span class="line">      <span class="comment">// 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动</span></span><br><span class="line">      angle = <span class="built_in">this</span>.angle(</span><br><span class="line">        &#123; <span class="attr">X</span>: <span class="built_in">this</span>.data.startX,</span><br><span class="line">	    <span class="attr">Y</span>: <span class="built_in">this</span>.data.startY</span><br><span class="line">	    &#125;, &#123; <span class="attr">X</span>: moveX,</span><br><span class="line">	    <span class="attr">Y</span>: moveY</span><br><span class="line">	    &#125;</span><br><span class="line">	  );</span><br><span class="line"></span><br><span class="line">    dataList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里相对参考代码做了精炼</span></span><br><span class="line">	<span class="comment">// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑</span></span><br><span class="line">      <span class="keyword">if</span> (curIndex === index &amp;&amp; angle &lt; <span class="number">30</span> &amp;&amp; moveX &lt; <span class="built_in">this</span>.data.startX) &#123;</span><br><span class="line">        item.isTouchMove = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	item.isTouchMove = <span class="literal">false</span>; <span class="comment">//否则右滑</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      dataList</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 计算滑动角度</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>start 起点坐标</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>end 终点坐标</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">angle</span>: <span class="function"><span class="keyword">function</span> (<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _X = end.X - start.X,</span><br><span class="line">      _Y = end.Y - start.Y</span><br><span class="line">    <span class="comment">//返回角度 /Math.atan()返回数字的反正切值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">360</span> * <span class="built_in">Math</span>.atan(_Y / _X) / (<span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="function"><span class="title">deleteItem</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">/* 这里是具体删除item的方法 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/%E4%BE%A7%E6%BB%91%E6%95%88%E6%9E%9C.gif" alt="侧滑效果"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。</p>
<p>实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）</title>
    <url>/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>上一章内容：<a href="/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89">关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</a></p>
<p>原代码不再贴出。</p>
<h2 id="新的工程需求"><a href="#新的工程需求" class="headerlink" title="新的工程需求"></a>新的工程需求</h2><p>上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：</p>
<p>不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。</p>
<h2 id="初步想法：阻止手势穿透"><a href="#初步想法：阻止手势穿透" class="headerlink" title="初步想法：阻止手势穿透"></a>初步想法：阻止手势穿透</h2><p>微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？</p>
<span id="more"></span>

<h2 id="尝试：将bind换成catch"><a href="#尝试：将bind换成catch" class="headerlink" title="尝试：将bind换成catch"></a>尝试：将bind换成catch</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;touchStart&quot; catchtouchmove=&quot;touchMove&quot;&gt;</span><br><span class="line">	&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。</p>
<h2 id="尝试：使bind和catch的事件根据isTouchMove进行变化"><a href="#尝试：使bind和catch的事件根据isTouchMove进行变化" class="headerlink" title="尝试：使bind和catch的事件根据isTouchMove进行变化"></a>尝试：使bind和catch的事件根据isTouchMove进行变化</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot; </span><br><span class="line">    bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">	&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。</p>
<h2 id="尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个"><a href="#尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个" class="headerlink" title="尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个"></a>尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:if=&quot;&#123;&#123;!item.isTouchMove&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure>

<p>效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。</p>
<h2 id="最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换"><a href="#最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换" class="headerlink" title="最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换"></a>最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换</h2><p>绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。</p>
<p>思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。</p>
<p>注意：css中，动画设定是0.4s，延时应当适当小于这个值。</p>
<figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:if=&quot;&#123;&#123;index!==hidden&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Page */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">dataList</span>: [<span class="comment">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class="line">    <span class="attr">startX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">startY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">null</span>,<span class="comment">//标记被隐藏的块index</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">touchStart</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataList = <span class="built_in">this</span>.data.dataList;</span><br><span class="line">    dataList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.isTouchMove) &#123;</span><br><span class="line">        item.isTouchMove = !item.isTouchMove;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.data.hidden = <span class="literal">null</span>; <span class="comment">//先把hidden置null, 但不渲染</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.data.startX = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">    <span class="built_in">this</span>.data.startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">touchMove</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> moveX = e.changedTouches[<span class="number">0</span>].clientX,</span><br><span class="line">      moveY = e.changedTouches[<span class="number">0</span>].clientY,</span><br><span class="line">      curIndex = e.currentTarget.dataset.index, </span><br><span class="line">      dataList = <span class="built_in">this</span>.data.dataList,</span><br><span class="line">      angle = <span class="built_in">this</span>.angle(</span><br><span class="line">        &#123; <span class="attr">X</span>: <span class="built_in">this</span>.data.startX,</span><br><span class="line">	    <span class="attr">Y</span>: <span class="built_in">this</span>.data.startY</span><br><span class="line">	    &#125;, &#123; <span class="attr">X</span>: moveX,</span><br><span class="line">	    <span class="attr">Y</span>: moveY</span><br><span class="line">	    &#125;</span><br><span class="line">	  );</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span>; <span class="comment">//用于在forEach函数里访问data</span></span><br><span class="line">    dataList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (curIndex === index &amp;&amp; angle &lt; <span class="number">30</span> &amp;&amp; moveX &lt; <span class="built_in">this</span>.data.startX) &#123;</span><br><span class="line">        item.isTouchMove = <span class="literal">true</span>;</span><br><span class="line">        that.data.hidden = index;<span class="comment">//如果有块被滑动，将hidden设为此块，否则就会保持在null</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	item.isTouchMove = <span class="literal">false</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    setTimeOut(&#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        <span class="attr">hidden</span>: that.data.hidden <span class="comment">//0.3s后渲染hidden来替换组件，此时动画基本放完了</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>各种问题的发现、解决与感想(2)</title>
    <url>/%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%84%9F%E6%83%B3-2/</url>
    <content><![CDATA[<p>目录：</p>
<ul>
<li><a href="#CSS-opacity%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E7%99%BE%E5%88%86%E6%AF%94%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98">CSS opacity属性设置百分比会导致生产环境问题</a></li>
<li><a href="#HTML%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">HTML文件引用在服务器上的路径问题</a></li>
</ul>
<span id="more"></span>

<hr>
<h2 id="CSS-opacity属性设置百分比会导致生产环境问题"><a href="#CSS-opacity属性设置百分比会导致生产环境问题" class="headerlink" title="CSS opacity属性设置百分比会导致生产环境问题"></a>CSS opacity属性设置百分比会导致生产环境问题</h2><p>在某个项目的测试阶段中，测试人员反馈某个元素没有显示，但是本地开发环境一切正常。在浏览器检查时发现，该元素的opacity属性值被设置为1%，故几乎不可见，但实际代码中设置为70%.</p>
<p>经过网络查询发现，原来别人也有出现同样的问题，即当opacity属性设置为百分比的时候，打包工具无法正确处理，就会变成1%. 如果使用0.7这样的小数值，便可以正常处理。</p>
<p>实际上，opacity的值的标准写法就是小数（见MDN Web Doc），但工程中往往写百分比形式也可以正常使用（且符合直觉，通常不透明度的概念经常以百分比表示），然而使用一些打包工具转移到生产环境的时候，就会导致数值错误的问题。希望读者都能够知道这件事情，不要犯类似的错误。</p>
<hr>
<h2 id="HTML文件引用在服务器上的路径问题"><a href="#HTML文件引用在服务器上的路径问题" class="headerlink" title="HTML文件引用在服务器上的路径问题"></a>HTML文件引用在服务器上的路径问题</h2><p>有时我们不使用node进行开发和打包，而是直接使用HTML, CSS, JS文件开发和打包。</p>
<p>在开发阶段，我们在HTML代码中引用文件时通常使用文件的相对路径，如&quot;image/xxx.png&quot;, &quot;css/common.css&quot;，并且可以正常调试。打包到服务器上时，有时会把资源文件和HTML分开存放，有时就保留原始目录结构放在同一个文件夹下。但尽管放在同一个文件夹下，原来的相对路径却无法正常在浏览器中引用了，这是为什么呢？</p>
<p>因为HTML文件中的相对路径，在浏览器环境下，会引用的实际路径是相对服务器根目录的路径。如HTML代码中引用了&quot;image/xxx.png&quot;，服务器地址是&quot;localhost:8080&quot;, 页面的地址是&quot;localhost:8080/hello/index.html&quot;, 反馈到浏览器中则不是期望的&quot;localhost:8080/hello/image/xxx.png&quot;, 而是&quot;localhost:8080/image/xxx.png&quot;，这样就无法正确地引用到文件了。</p>
<p>因此，实际部署时正确的引用方式应该是&quot;hello/image/xxx.png&quot;. 实际上是一个相对服务器根目录的绝对路径。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序：灵活适配不同标题栏高度的设备的方法</title>
    <url>/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E7%81%B5%E6%B4%BB%E9%80%82%E9%85%8D%E4%B8%8D%E5%90%8C%E6%A0%87%E9%A2%98%E6%A0%8F%E9%AB%98%E5%BA%A6%E7%9A%84%E8%AE%BE%E5%A4%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="工程需求"><a href="#工程需求" class="headerlink" title="工程需求"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端App。</p>
<p>作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？</p>
<p>首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。</p>
<h2 id="方案参考"><a href="#方案参考" class="headerlink" title="方案参考"></a>方案参考</h2><p>在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。</p>
<p>私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：</p>
<span id="more"></span>

<h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><h3 id="大体思路如下："><a href="#大体思路如下：" class="headerlink" title="大体思路如下："></a>大体思路如下：</h3><p>在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。</p>
<h3 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/* page */</span></span><br><span class="line">	<span class="attr">data</span>: &#123;</span><br><span class="line">		<span class="attr">dAbsoluteTop</span>: <span class="number">0</span>, <span class="comment">//准备设置固定内容组件的高度</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">		<span class="keyword">const</span> query = wx.createSelectorQuery();</span><br><span class="line">		query.select(<span class="string">&#x27;#fixed-view&#x27;</span>).boundingClientRect();</span><br><span class="line">		query.selectViewport().scrollOffset();</span><br><span class="line">		query.exec(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">			that.setData(&#123;</span><br><span class="line">				<span class="attr">dAbsoluteTop</span>: res[<span class="number">0</span>].bottom <span class="comment">//根据底部渲染</span></span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;view id=&quot;fixed-view&quot; style=&quot;position: fixed; top: 0; display: flex; flex-direction: column;&quot;&gt;</span><br><span class="line">	&lt;titlebar /&gt; &lt;!-- 标题栏 --&gt;</span><br><span class="line">	&lt;tabbar /&gt; &lt;!-- 选择标签栏 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view style=&quot;position: absolute; top: &#123;&#123;dAbsolute&#125;&#125;;&quot;&gt;</span><br><span class="line">	&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>经不同设备检验，效果良好。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>各种问题的发现、解决与感想</title>
    <url>/%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<p>前段时间参与了一个项目的开发，共计超过一个月的时间。工作量其实是非常饱和的，并且在接手各种老旧工程的时候经历了很多奇奇怪怪的问题，有的至今难以解决。特此分享一下在这段项目中发现的一些问题解决方案及感想。</p>
<p>目录：</p>
<ul>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%90%8E%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E5%9C%B0%E5%9D%80%E9%BB%98%E8%AE%A4%E6%98%AF%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">重定向到统一登录页面后，返回的地址默认是网站首页的解决方案</a></li>
<li><a href="#%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">跨域传输数据的解决方案</a></li>
<li><a href="#%E6%97%A0%E6%B3%95%E6%9B%B4%E6%94%B9%E6%BA%90%E7%A0%81%E6%97%B6%E9%98%BB%E6%AD%A2%E7%BD%91%E9%A1%B5%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">无法更改源码时阻止网页中默认弹出提示的解决方案</a></li>
<li><a href="#%E5%AF%B9%E4%BB%98%E5%89%8D%E4%BA%BA%E5%86%99%E7%9A%84%E5%9D%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E6%84%9F%E6%83%B3">对付前人写的坏代码的心得感想</a></li>
</ul>
<span id="more"></span>

<hr>
<h2 id="重定向到统一登录页面后，返回的地址默认是网站首页的解决方案"><a href="#重定向到统一登录页面后，返回的地址默认是网站首页的解决方案" class="headerlink" title="重定向到统一登录页面后，返回的地址默认是网站首页的解决方案"></a>重定向到统一登录页面后，返回的地址默认是网站首页的解决方案</h2><p>问题描述：网站未登录时重定向到统一登录页面，登录成功自动返回时返回的是网站首页，丢失了后面的路由部分，不能按照预期返回原来的页面。</p>
<p>解决方式：未登录重定向前，将原先的url（删去携带的用户令牌信息）完整保存在Session Storage（浏览器临时存储）中。在进入网站首页时，检测Session Storage是否保存了url，如果有的话，重定向到该url，并删除存储即可。</p>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定向前</span></span><br><span class="line"><span class="keyword">const</span> unsavedHref = <span class="built_in">window</span>.top.location.href <span class="comment">// 获取窗口url</span></span><br><span class="line"><span class="comment">// 我这边加入了删除用户令牌信息的代码（使用正则）</span></span><br><span class="line"><span class="built_in">window</span>.top.sessionStorage.setItem(<span class="string">&#x27;unsavedHref&#x27;</span>, unsavedHref) <span class="comment">// 将url保存在sessionStorage里</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录成功回到网站首页后</span></span><br><span class="line"><span class="keyword">const</span> unsavedHref = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;unsavedHref&#x27;</span>) <span class="comment">// 获取sessionStorage，如果没有则会得到undefined</span></span><br><span class="line"><span class="keyword">if</span> (unsavedHref) &#123;</span><br><span class="line">  <span class="comment">// 如果sessionStorage中存在未保存链接，则恢复</span></span><br><span class="line">  <span class="built_in">window</span>.sessionStorage.removeItem(<span class="string">&#x27;unsavedHref&#x27;</span>) <span class="comment">// 删除存储，这是为了防止后续正常访问首页时也被重定向到存储中的链接</span></span><br><span class="line">  <span class="built_in">window</span>.top.location.href = unsavedHref <span class="comment">// 进行跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="跨域传输数据的解决方案"><a href="#跨域传输数据的解决方案" class="headerlink" title="跨域传输数据的解决方案"></a>跨域传输数据的解决方案</h2><p>问题描述：A页面中存在一定的数据，需要在跨域打开的B页面中获取使用。</p>
<h3 id="方案一：使用url传参的方式。"><a href="#方案一：使用url传参的方式。" class="headerlink" title="方案一：使用url传参的方式。"></a>方案一：使用url传参的方式。</h3><p>实现方式：A页面跳转到B页面时，在url中拼接?data=&lt;…&gt;形式的参数。B页面启动时，获取到url中的参数即可。</p>
<p>优点：速度快，B页面启动后立刻能获取到。</p>
<p>缺点：数据过长的时候，url长度可能会被浏览器限制。</p>
<h3 id="方案二：使用window-postMessage方法。"><a href="#方案二：使用window-postMessage方法。" class="headerlink" title="方案二：使用window.postMessage方法。"></a>方案二：使用window.postMessage方法。</h3><p>技术前提：使用window.open打开页面时，A页面可获取到B页面的窗口对象，B页面也可通过window.opener获取到A页面的窗口对象。</p>
<p>具体过程：B页面加载完成并绑定监听器后，先发送消息告知A页面；A页面接收到消息后，向B页面发送消息传递数据；B页面接收到消息后，则根据消息中的数据执行操作。</p>
<p>优点：无需考虑数据的长度限制。</p>
<p>缺点：异步操作，需要一定时间才能完成；A、B页面都需要明确对方的源地址；需要A页面保持开启才会发送数据。</p>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A页面 - 打开B页面前</span></span><br><span class="line"><span class="keyword">const</span> nextOrigin = <span class="string">&#x27;https://marycly.github.io&#x27;</span> <span class="comment">// B页面的源地址</span></span><br><span class="line"><span class="keyword">const</span> nextUrl = <span class="string">&#x27;https://marycly.github.io/archives/&#x27;</span> <span class="comment">// B页面的完整打开地址</span></span><br><span class="line"><span class="keyword">const</span> parseValue = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// 要传递的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.origin.includes(nextOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 任何消息监听器里都应该加上这个判断，不仅可以区分不同地址发来的消息所产生的不同效果，也可以防止未知网站的消息攻击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.receiveMessageTimeout) &#123;</span><br><span class="line">    <span class="built_in">window</span>.clearTimeout(<span class="built_in">this</span>.receiveMessageTimeout)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.receiveMessageTimeout = <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nextPage.postMessage(parseValue, nextOrigin) <span class="comment">// 这是最终会干的事情，向B页面发送数据</span></span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">  <span class="comment">// 这里小小做了一个0.5s延时的消抖，防止消息重复发送</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">this</span>.nextPage = <span class="built_in">window</span>.open(nextUrl) <span class="comment">// 然后打开B页面，并保存窗口对象到变量中，便于监听器调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B页面 - 加载完成后</span></span><br><span class="line"><span class="keyword">const</span> lastOrigin = <span class="string">&#x27;https://anyone.hello&#x27;</span> <span class="comment">// A页面的源地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.origin.includes(lastOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 任何消息监听器里都应该加上这个判断，不仅可以区分不同地址发来的消息所产生的不同效果，也可以防止未知网站的消息攻击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用e.data干任何事！</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.data)</span><br><span class="line">  <span class="built_in">this</span>.lastPageData = e.data</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> lastPage = <span class="built_in">window</span>.opener <span class="comment">// 通过opener获取A页面的窗口对象</span></span><br><span class="line">lastPage.postMessage(<span class="string">&#x27;I am all okay!&#x27;</span>, lastOrigin) <span class="comment">// 向A页面表示你已经准备好接收数据了</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="无法更改源码时阻止网页中默认弹出提示的解决方案"><a href="#无法更改源码时阻止网页中默认弹出提示的解决方案" class="headerlink" title="无法更改源码时阻止网页中默认弹出提示的解决方案"></a>无法更改源码时阻止网页中默认弹出提示的解决方案</h2><p>问题描述：工程所使用的一个依赖包中有这样一个逻辑，提交数据成功时会默认弹出一个提示（element-ui的message组件）。现需要阻止该提示，但依赖包的内容难以直接更改。</p>
<p>解决方式：获取该message组件弹窗显示的元素类名，在弹窗出现时使用querySelector找到该元素，并移除它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.querySelector(&#x27;.el-message&#x27;).remove()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对付前人写的坏代码的心得感想"><a href="#对付前人写的坏代码的心得感想" class="headerlink" title="对付前人写的坏代码的心得感想"></a>对付前人写的坏代码的心得感想</h2><p>当接手某个工程的时候，有时会发现一些不规范的，逻辑错误的，或是造成了全局性不良污染的代码。我认为比较合适的处理方式如下：</p>
<ol>
<li><p>首先，需要仔细评估该段代码的影响范围。如果牵涉的范围非常大，且依赖于该代码的功能都能够正常运行，则不应轻易更改，而考虑使用局部重写的方式解决问题。</p>
</li>
<li><p>然后，需要理解该段代码的意义和作用，确定自己的更改是否100%不影响原先的功能。如果不确定，尝试跟原开发者联系确认。</p>
</li>
<li><p>如果影响范围较小且能确保不影响逻辑，或者影响范围只有正在开发的当前页面或模块，便可以进行修改。修改后必须要经过反复的自测验证，保证功能正常运作。</p>
</li>
<li><p>有时某段有问题的代码会随着工程体量的增加而积重难返，这时大概率是要对它妥协，将就总比意外好。</p>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再也不想加班和直面屎山了！</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对一些团队前端开发规范的质疑、求证和思考总结</title>
    <url>/%E5%AF%B9%E4%B8%80%E4%BA%9B%E5%9B%A2%E9%98%9F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E7%9A%84%E8%B4%A8%E7%96%91%E3%80%81%E6%B1%82%E8%AF%81%E5%92%8C%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>因为我算是比较重视代码质量的一个人，在刚进公司的时候就开始积极地学习团队内的一些开发规范。其中有写在文档里面的，也有同事们在代码审查中提到的；有美观性、易读性方面的，也有性能提升方面的。有时，看到一些开发规范，我无法理解它的意义和必要性，并且觉得非常不方便，便会在网络上寻找相关的资料，以及与同事交流。当然，作为一名前端新人，我个人的考虑其实也有很多不足之处，以下就介绍一下我对一些团队前端开发规范产生的质疑、求证和思考总结。</p>
<span id="more"></span>

<hr>
<h2 id="定义样式时使用class，避免使用id"><a href="#定义样式时使用class，避免使用id" class="headerlink" title="定义样式时使用class，避免使用id"></a>定义样式时使用class，避免使用id</h2><p>这一点，我一开始不知道有什么意义，在深入了解过后觉得是必要的。</p>
<p>首先这两个属性存在明显的不同：class属性是专为样式准备的，并且可复用；id属性具有当前文档内的唯一性，通常能够起到特殊的作用，比如作为&lt;a&gt;标签的锚点，以及最快地被JavaScript元素节点语法选中。</p>
<p>因此，id属性通常作为一种具有特殊性的标识，表示本元素可能用作页面锚点，或者代码中需要对该元素执行JavaScript操作。除此之外，不在非必要的时候使用id属性也可以减少出现意外重复的概率。</p>
<p>总之，使用CSS选择器的时候，如果该本身就需要使用id进行其他操作，就可以使用id选择器，否则尽量不要仅为了定义样式而使用id.</p>
<hr>
<h2 id="少使用标签选择器"><a href="#少使用标签选择器" class="headerlink" title="少使用标签选择器"></a>少使用标签选择器</h2><p>从开发者的角度来说，其实使用标签选择器是很方便的。譬如某个div元素中只存在一个img标签，使用[.certain-div img]的选择器就可以最快地选中该img元素。</p>
<p>但从性能的方面考虑，使用标签选择器可能会带来一些性能影响。CSS选择器的层次逻辑是从右到左执行的，因此越往右边的选择器越影响效率。而标签选择器通常放在较右边，这就使得CSS先选中文档中所有的该标签，再执行上一步的层次查找。标签往往在文档中相比class和id是最多的，因此会影响CSS选择器的效率。</p>
<p>当然，如果本身就是在文档中比较少使用的标签，自然不会非常影响效率，但div, span等使用频率较高的标签，可以想象对性能影响还是比较大的。</p>
<p>总的来说，定义样式的时候，如果能使用class，尽量还是避免使用标签选择器。</p>
<hr>
<h2 id="Vue框架中v-for列表渲染的key属性是否能使用index"><a href="#Vue框架中v-for列表渲染的key属性是否能使用index" class="headerlink" title="Vue框架中v-for列表渲染的key属性是否能使用index"></a>Vue框架中v-for列表渲染的key属性是否能使用index</h2><p>key属性，是在Vue列表渲染时，被用于唯一标识每一列表项的属性。在列表渲染的机制中起到非常重要的作用。</p>
<p>首先，在比较简单且静态的列表结构里面，使用index作为key, 或者不使用key, 其实是能够通过依赖默认行为提高性能的。</p>
<p>但是，以下几种情况无法使用index作为key:</p>
<ol>
<li>该列表可能出现顺序变化。譬如需要提供向列表中间插入项的功能，这时会把顺序打乱，原本的标识作用也将产生混乱。这种情况，建议在列表结构中，给每一项增加一个单独的识别码，譬如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;hello1&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;hello2&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>两个及以上的列表渲染作为兄弟节点出现。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in array&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item1, index1) in array1&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为key的作用范围是同一元素下，这种条件下就可能会出现key重复的情况。解决方式是把index和一些字符拼接起来，就可以把两种key区分开。这种方式生成的key实际上也是和index完全相对应的。如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in array&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;`a$&#123;index&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item1, index1) in array1&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;`b$&#123;index1&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>跟前辈讨论的时候，她认为为了避免key重复的情况，应该完全不使用index作为key, 尽量拼接字符串。我其实觉得，这种情况在使用简单静态列表的场景下很少出现，只要心里有数就可以用。</p>
<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>没人爱写注释，我也不爱。听过一种说法，一个条理清晰、命名意义明确、排版舒适的代码胜过各种注释，因此我也一直很努力地在做到，为了不写注释。</p>
<p>当然，有些注释还是可以一写，大多方便别人，部分方便自己：</p>
<ol>
<li><p>公用的方法、变量、组件等。方法的注释推荐使用VSCode拓展koroFileHeader生成模板。如有需要，变量、组件参数建议说明取值范围。</p>
</li>
<li><p>文件头注释。也可以使用koroFileHeader生成模板，主要是介绍一下该文件负责的功能。</p>
</li>
<li><p>确实复杂，不易看懂的代码部分。如果发现某一段代码可能让未来的自己或别人看不懂，及时写注释。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>邮箱系统界面设计</title>
    <url>/%E9%82%AE%E7%AE%B1%E7%B3%BB%E7%BB%9F%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>谨以本文记录2022年7月入职科大讯飞后，作为培训的一部分参加的编程大赛。</p>
<p>因为项目要求队员中至少一位有TCP编程经验，原本小组中的两位前端之一（自然不是我）被分配到其他小组了，而新分配进来的这位是一个Android开发工程师，并没有Vue开发经验（比赛要求使用Vue框架进行开发）。因此，所有的前端开发工作便由我一个人完成。因为前端部分代码完全由我独立开发，因此作为个人成果发布于<a href="https://github.com/MaryCLY/mail-system-ui">GitHub</a>供公开交流学习。</p>
<span id="more"></span>

<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="登录-注册界面"><a href="#登录-注册界面" class="headerlink" title="登录/注册界面"></a>登录/注册界面</h3><p>登录/注册的过程又被分为两个步骤：第一个步骤是输入用户名并点击“下一步”，这时系统会检测用户名是否已注册，从而将用户转入登录或注册页面。而第二个步骤则是输入密码，其中需要注册的用户将被要求重复输入密码，而登录的用户只需输入一次。在这个过程中，前端包含用户名与密码的格式检测。</p>
<p>点击确认后，系统请求后端是否注册/登录成功，如果失败弹出错误提示，反之则弹出成功提示，并将页面转入主页。</p>
<h3 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h3><p>主页提供查看邮件以及写新邮件的功能。其中查看邮件的内容分为收件箱和发件箱，邮件列表提供分页功能，点击列表中的邮件标题进入邮件详情。</p>
<p>写邮件的功能采用按钮+模态弹窗的形式实现。因为开发时采用的富文本编辑器出现bug难以修复，只提供了输入纯文本的功能。未支持上传附件。</p>
<p>头部提供退出登录按钮。</p>
<h2 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h2><p>系统使用Vite+Vue 3进行前端开发。</p>
<h2 id="部分细节"><a href="#部分细节" class="headerlink" title="部分细节"></a>部分细节</h2><p>交付时的版本，只使用点击来切换sider中的选项卡，而复杂的操作下会出现bug. 之后进行了一定的优化，使用vuex state来管理当前处于的页面，从而保证sider的选项正确。</p>
]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>

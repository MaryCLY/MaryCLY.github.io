<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员玛丽的星海方舟</title>
  
  <subtitle>陈俪影的个人空间，用于分享自己学习、工作和兴趣中写程序的心得体会。</subtitle>
  <link href="https://marycly.github.io/atom.xml" rel="self"/>
  
  <link href="https://marycly.github.io/"/>
  <updated>2022-10-28T05:46:22.496Z</updated>
  <id>https://marycly.github.io/</id>
  
  <author>
    <name>陈俪影</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最近项目中发现的一些问题解决方案及感想</title>
    <link href="https://marycly.github.io/%E6%9C%80%E8%BF%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8F%91%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8F%8A%E6%84%9F%E6%83%B3/"/>
    <id>https://marycly.github.io/%E6%9C%80%E8%BF%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8F%91%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%8F%8A%E6%84%9F%E6%83%B3/</id>
    <published>2022-10-28T03:44:09.000Z</published>
    <updated>2022-10-28T05:46:22.496Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间参与了一个项目的开发，共计超过一个月的时间。工作量其实是非常饱和的，并且在接手各种老旧工程的时候经历了很多奇奇怪怪的问题，有的至今难以解决。特此分享一下在这段项目中发现的一些问题解决方案及感想。</p><p>目录：</p><ul><li>重定向到统一登录页面后，返回的地址默认是网站首页的解决方案</li><li>跨域传输数据的解决方案</li><li>无法更改源码时阻止网页中默认弹出提示的解决方案</li><li>对付前人写的坏代码的心得感想</li></ul><span id="more"></span><hr><h2 id="重定向到统一登录页面后，返回的地址默认是网站首页的解决方案"><a href="#重定向到统一登录页面后，返回的地址默认是网站首页的解决方案" class="headerlink" title="重定向到统一登录页面后，返回的地址默认是网站首页的解决方案"></a>重定向到统一登录页面后，返回的地址默认是网站首页的解决方案</h2><p>问题描述：网站未登录时重定向到统一登录页面，登录成功自动返回时返回的是网站首页，丢失了后面的路由部分，不能按照预期返回原来的页面。</p><p>解决方式：未登录重定向前，将原先的url（删去携带的用户令牌信息）完整保存在Session Storage（浏览器临时存储）中。在进入网站首页时，检测Session Storage是否保存了url，如果有的话，重定向到该url，并删除存储即可。</p><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向前</span></span><br><span class="line"><span class="keyword">const</span> unsavedHref = <span class="built_in">window</span>.top.location.href <span class="comment">// 获取窗口url</span></span><br><span class="line"><span class="comment">// 我这边加入了删除用户令牌信息的代码（使用正则）</span></span><br><span class="line"><span class="built_in">window</span>.top.sessionStorage.setItem(<span class="string">&#x27;unsavedHref&#x27;</span>, unsavedHref) <span class="comment">// 将url保存在sessionStorage里</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录成功回到网站首页后</span></span><br><span class="line"><span class="keyword">const</span> unsavedHref = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;unsavedHref&#x27;</span>) <span class="comment">// 获取sessionStorage，如果没有则会得到undefined</span></span><br><span class="line"><span class="keyword">if</span> (unsavedHref) &#123;</span><br><span class="line">  <span class="comment">// 如果sessionStorage中存在未保存链接，则恢复</span></span><br><span class="line">  <span class="built_in">window</span>.sessionStorage.removeItem(<span class="string">&#x27;unsavedHref&#x27;</span>) <span class="comment">// 删除存储，这是为了防止后续正常访问首页时也被重定向到存储中的链接</span></span><br><span class="line">  <span class="built_in">window</span>.top.location.href = unsavedHref <span class="comment">// 进行跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="跨域传输数据的解决方案"><a href="#跨域传输数据的解决方案" class="headerlink" title="跨域传输数据的解决方案"></a>跨域传输数据的解决方案</h2><p>问题描述：A页面中存在一定的数据，需要在跨域打开的B页面中获取使用。</p><h3 id="方案一：使用url传参的方式。"><a href="#方案一：使用url传参的方式。" class="headerlink" title="方案一：使用url传参的方式。"></a>方案一：使用url传参的方式。</h3><p>实现方式：A页面跳转到B页面时，在url中拼接?data=&lt;…&gt;形式的参数。B页面启动时，获取到url中的参数即可。</p><p>优点：速度快，B页面启动后立刻能获取到。</p><p>缺点：数据过长的时候，url长度可能会被浏览器限制。</p><h3 id="方案二：使用window-postMessage方法。"><a href="#方案二：使用window-postMessage方法。" class="headerlink" title="方案二：使用window.postMessage方法。"></a>方案二：使用window.postMessage方法。</h3><p>技术前提：使用window.open打开页面时，A页面可获取到B页面的窗口对象，B页面也可通过window.opener获取到A页面的窗口对象。</p><p>具体过程：B页面加载完成并绑定监听器后，先发送消息告知A页面；A页面接收到消息后，向B页面发送消息传递数据；B页面接收到消息后，则根据消息中的数据执行操作。</p><p>优点：无需考虑数据的长度限制。</p><p>缺点：异步操作，需要一定时间才能完成；A、B页面都需要明确对方的源地址；需要A页面保持开启才会发送数据。</p><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A页面 - 打开B页面前</span></span><br><span class="line"><span class="keyword">const</span> nextOrigin = <span class="string">&#x27;https://marycly.github.io&#x27;</span> <span class="comment">// B页面的源地址</span></span><br><span class="line"><span class="keyword">const</span> nextUrl = <span class="string">&#x27;https://marycly.github.io/archives/&#x27;</span> <span class="comment">// B页面的完整打开地址</span></span><br><span class="line"><span class="keyword">const</span> parseValue = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// 要传递的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.origin.includes(nextOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 任何消息监听器里都应该加上这个判断，不仅可以区分不同地址发来的消息所产生的不同效果，也可以防止未知网站的消息攻击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.receiveMessageTimeout) &#123;</span><br><span class="line">    <span class="built_in">window</span>.clearTimeout(<span class="built_in">this</span>.receiveMessageTimeout)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.receiveMessageTimeout = <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nextPage.postMessage(parseValue, nextOrigin) <span class="comment">// 这是最终会干的事情，向B页面发送数据</span></span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">  <span class="comment">// 这里小小做了一个0.5s延时的消抖，防止消息重复发送</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">this</span>.nextPage = <span class="built_in">window</span>.open(nextUrl) <span class="comment">// 然后打开B页面，并保存窗口对象到变量中，便于监听器调用</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B页面 - 加载完成后</span></span><br><span class="line"><span class="keyword">const</span> lastOrigin = <span class="string">&#x27;https://anyone.github.io&#x27;</span> <span class="comment">// A页面的源地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.origin.includes(lastOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 任何消息监听器里都应该加上这个判断，不仅可以区分不同地址发来的消息所产生的不同效果，也可以防止未知网站的消息攻击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用e.data干任何事！</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.data)</span><br><span class="line">  <span class="built_in">this</span>.lastPageData = e.data</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> lastPage = <span class="built_in">window</span>.opener <span class="comment">// 通过opener获取A页面的窗口对象</span></span><br><span class="line">lastPage.postMessage(<span class="string">&#x27;I am all okay!&#x27;</span>, lastOrigin) <span class="comment">// 向A页面表示你已经准备好接收数据了</span></span><br></pre></td></tr></table></figure><hr><h2 id="无法更改源码时阻止网页中默认弹出提示的解决方案"><a href="#无法更改源码时阻止网页中默认弹出提示的解决方案" class="headerlink" title="无法更改源码时阻止网页中默认弹出提示的解决方案"></a>无法更改源码时阻止网页中默认弹出提示的解决方案</h2><p>问题描述：工程所使用的一个依赖包中有这样一个逻辑，提交数据成功时会默认弹出一个提示（element-ui的message组件）。现需要阻止该提示，但依赖包的内容难以直接更改。</p><p>解决方式：获取该message组件弹窗显示的元素类名，在弹窗出现时使用querySelector找到该元素，并移除它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&#x27;.el-message&#x27;).remove()</span><br></pre></td></tr></table></figure><hr><h2 id="对付前人写的坏代码的心得感想"><a href="#对付前人写的坏代码的心得感想" class="headerlink" title="对付前人写的坏代码的心得感想"></a>对付前人写的坏代码的心得感想</h2><p>当接手某个工程的时候，有时会发现一些不规范的，逻辑错误的，或是造成了全局性不良污染的代码。我认为比较合适的处理方式如下：</p><ol><li><p>首先，需要仔细评估该段代码的影响范围。如果牵涉的范围非常大，且依赖于该代码的功能都能够正常运行，则不应轻易更改，而考虑使用局部重写的方式解决问题。</p></li><li><p>然后，需要理解该段代码的意义和作用，确定自己的更改是否100%不影响原先的功能。如果不确定，尝试跟原开发者联系确认。</p></li><li><p>如果影响范围较小且能确保不影响逻辑，或者影响范围只有正在开发的当前页面或模块，便可以进行修改。修改后必须要经过反复的自测验证，保证功能正常运作。</p></li><li><p>有时某段有问题的代码会随着工程体量的增加而积重难返，这时大概率是要对它妥协，将就总比意外好。</p></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再也不想加班和直面屎山了！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间参与了一个项目的开发，共计超过一个月的时间。工作量其实是非常饱和的，并且在接手各种老旧工程的时候经历了很多奇奇怪怪的问题，有的至今难以解决。特此分享一下在这段项目中发现的一些问题解决方案及感想。&lt;/p&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重定向到统一登录页面后，返回的地址默认是网站首页的解决方案&lt;/li&gt;
&lt;li&gt;跨域传输数据的解决方案&lt;/li&gt;
&lt;li&gt;无法更改源码时阻止网页中默认弹出提示的解决方案&lt;/li&gt;
&lt;li&gt;对付前人写的坏代码的心得感想&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JS" scheme="https://marycly.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>一些使用UI组件库的经验</title>
    <link href="https://marycly.github.io/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    <id>https://marycly.github.io/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E7%BB%8F%E9%AA%8C/</id>
    <published>2022-08-24T08:58:36.000Z</published>
    <updated>2022-08-24T09:25:39.006Z</updated>
    
    <content type="html"><![CDATA[<p>近期进行前端开发的过程中，接触了一些比较全面方便的UI库，有Ant Design Vue, 以及Vant. 这些UI库使用起来比自己造零件要方便且美观，不过在初使用的过程中也会遇到一些比较疑惑的问题，因此写下本文记录一下使用这些UI组件库所积累的一些经验。</p><span id="more"></span><h2 id="主题定制"><a href="#主题定制" class="headerlink" title="主题定制"></a>主题定制</h2><p>通常来说，UI组件库都提供全局的主题定制的功能，如某个组件的默认颜色或整体的颜色风格等，一般可以在官网找到更改方式，譬如Ant Design Vue 3的主题定制方式就在<a href="https://antdv.com/docs/vue/customize-theme-cn">定制主题 - Ant Design Vue</a>. Vue项目通常需要修改全局选项文件。</p><h2 id="调整内部样式"><a href="#调整内部样式" class="headerlink" title="调整内部样式"></a>调整内部样式</h2><p>在使用UI组件库的过程中，有时候需要调整个别组件的样式，而不改变全局的UI库参数。如果直接打开浏览器的开发者检查工具，可以看到UI库组件的内部存在一些class, 它们定义了那些你不想要的样式。这种时候，如果在源代码中直接用类名选择器设置这些class的样式，会发现并没有效果。这种时候，使用/deep/ .target-class 的选择器来定义你需要更改的样式，就能起到效果（LESS预编译语言下）。有一篇类似情况的文章可供参考：<a href="https://www.jianshu.com/p/5bd38a4d4d64">&gt;&gt;&gt;或/deep/的作用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期进行前端开发的过程中，接触了一些比较全面方便的UI库，有Ant Design Vue, 以及Vant. 这些UI库使用起来比自己造零件要方便且美观，不过在初使用的过程中也会遇到一些比较疑惑的问题，因此写下本文记录一下使用这些UI组件库所积累的一些经验。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
    <category term="CSS" scheme="https://marycly.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue router中params和query的区别</title>
    <link href="https://marycly.github.io/Vue-router%E4%B8%ADparams%E5%92%8Cquery%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://marycly.github.io/Vue-router%E4%B8%ADparams%E5%92%8Cquery%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-08-19T02:15:05.000Z</published>
    <updated>2022-08-24T09:03:10.351Z</updated>
    
    <content type="html"><![CDATA[<p>在vue开发中，页面跳转时常需要传递一些参数。如果我们使用vue router来进行路由，通常有两种方式进行参数的传递，一种是使用params, 一种是使用query. 在下文中我将介绍一下个人使用中感受到的这两者的区别。</p><span id="more"></span><h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><p>如果在url中定义了params的绑定，则可以直接在url中传递params(‘/articles/:id’), 否则只能通过vue router的方法（router-link或$router.push等）传递路径对象时添加params. params可以直接传递值和对象，并且定义了router中的props属性后，能在页面中通过props属性去获取。如果不通过props, 也可以使用this.$route.params获取。</p><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>query既可以直接在url后添加(‘marycly.github.io/index?pageId=114514’), 也可以通过vue router的方法传递路径对象时添加query. query可以传递值，但传递对象效果不稳定，最好将传递的对象通过JSON来保存。在页面中可以使用this.$route.query来获取query的内容。</p><h3 id="在页面跳转中的实际应用表现"><a href="#在页面跳转中的实际应用表现" class="headerlink" title="在页面跳转中的实际应用表现"></a>在页面跳转中的实际应用表现</h3><p>如果url中没有定义与params绑定的动态路由，个人不建议使用params来传递信息。因为这种情况下url里面并不包含params的信息，在浏览器历史前进/回退的过程中就会丢失，因此只能实现一个单向的传递。如果需要支持时常在页面之间跳转并保留信息的话，建议使用query.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在vue开发中，页面跳转时常需要传递一些参数。如果我们使用vue router来进行路由，通常有两种方式进行参数的传递，一种是使用params, 一种是使用query. 在下文中我将介绍一下个人使用中感受到的这两者的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>邮箱系统界面设计</title>
    <link href="https://marycly.github.io/%E9%82%AE%E7%AE%B1%E7%B3%BB%E7%BB%9F%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
    <id>https://marycly.github.io/%E9%82%AE%E7%AE%B1%E7%B3%BB%E7%BB%9F%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-08-12T07:48:50.000Z</published>
    <updated>2022-08-24T09:02:51.429Z</updated>
    
    <content type="html"><![CDATA[<p>谨以本文记录2022年7月入职科大讯飞后，作为培训的一部分参加的编程大赛。</p><p>因为项目要求队员中至少一位有TCP编程经验，原本小组中的两位前端之一（自然不是我）被分配到其他小组了，而新分配进来的这位是一个Android开发工程师，并没有Vue开发经验（比赛要求使用Vue框架进行开发）。因此，所有的前端开发工作便由我一个人完成。因为前端部分代码完全由我独立开发，因此作为个人成果发布于<a href="https://github.com/MaryCLY/mail-system-ui">GitHub</a>供公开交流学习。</p><span id="more"></span><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="登录-注册界面"><a href="#登录-注册界面" class="headerlink" title="登录/注册界面"></a>登录/注册界面</h3><p>登录/注册的过程又被分为两个步骤：第一个步骤是输入用户名并点击“下一步”，这时系统会检测用户名是否已注册，从而将用户转入登录或注册页面。而第二个步骤则是输入密码，其中需要注册的用户将被要求重复输入密码，而登录的用户只需输入一次。在这个过程中，前端包含用户名与密码的格式检测。</p><p>点击确认后，系统请求后端是否注册/登录成功，如果失败弹出错误提示，反之则弹出成功提示，并将页面转入主页。</p><h3 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h3><p>主页提供查看邮件以及写新邮件的功能。其中查看邮件的内容分为收件箱和发件箱，邮件列表提供分页功能，点击列表中的邮件标题进入邮件详情。</p><p>写邮件的功能采用按钮+模态弹窗的形式实现。因为开发时采用的富文本编辑器出现bug难以修复，只提供了输入纯文本的功能。未支持上传附件。</p><p>头部提供退出登录按钮。</p><h2 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h2><p>系统使用Vite+Vue 3进行前端开发。</p><h2 id="部分细节"><a href="#部分细节" class="headerlink" title="部分细节"></a>部分细节</h2><p>交付时的版本，只使用点击来切换sider中的选项卡，而复杂的操作下会出现bug. 之后进行了一定的优化，使用vuex state来管理当前处于的页面，从而保证sider的选项正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;谨以本文记录2022年7月入职科大讯飞后，作为培训的一部分参加的编程大赛。&lt;/p&gt;
&lt;p&gt;因为项目要求队员中至少一位有TCP编程经验，原本小组中的两位前端之一（自然不是我）被分配到其他小组了，而新分配进来的这位是一个Android开发工程师，并没有Vue开发经验（比赛要求使用Vue框架进行开发）。因此，所有的前端开发工作便由我一个人完成。因为前端部分代码完全由我独立开发，因此作为个人成果发布于&lt;a href=&quot;https://github.com/MaryCLY/mail-system-ui&quot;&gt;GitHub&lt;/a&gt;供公开交流学习。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Pow(x, n)%10 （快速幂+大数取模问题）</title>
    <link href="https://marycly.github.io/Pow-x-n-10-%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <id>https://marycly.github.io/Pow-x-n-10-%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1%E9%97%AE%E9%A2%98%EF%BC%89/</id>
    <published>2021-08-29T15:13:10.000Z</published>
    <updated>2022-08-24T09:03:04.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。</p><p>任何数的0次方都是1.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>不难发现规律： ((x%y)^n)%y = (x^n)%y</p><span id="more"></span><p>因此很容易想到，第一步先把题目中的底数x提取成最后一位。但如果直接用编程语言库里自带的Math.pow(x, n)，依然可能会直接得到一个很大的结果，取模依然可能不正确。因此，我们需要考虑自己实现一套幂运算，在过程中多次取最后一位，这样就会使得所有的运算都是小数取模了。</p><p>快速幂公式参考<a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/">LeetCode 50. Pow(x, n) （快速幂，清晰图解）-Krahets</a></p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>根据观察不难发现，0-9为底的幂运算取最后一位是存在一个循环的。我们先求出这个循环的规律，然后判断n是在循环的第几位，即可直接得到结果。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>由于Javascript BigInt过于复杂，没有实现x, y为大数时的算法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><figcaption><span>公用方法.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mod10</span>(<span class="params"> num </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>思路1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastDigitQuickPow</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = mod10(str1); <span class="comment">// x直接取最后一位</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(str2); <span class="comment">// 可能涉及大数，转成BigInt</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 任何数的0次方都是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = x; n; i = mod10(i * i), n = n &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 每次使i平方，然后n减少一位二进制位（位右移）</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = mod10(res * i); <span class="comment">// 如果当前位是1，则在结果中增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>思路2.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastDigit</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = mod10(str1); <span class="comment">// x直接取最后一位</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(str2); <span class="comment">// 可能涉及大数，转成BigInt</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 任何数的0次方都是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> loopCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> loopNum = [x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = x; <span class="literal">true</span>;) &#123;</span><br><span class="line">        i = mod10(i * x); <span class="comment">// 查找循环的下一位</span></span><br><span class="line">        loopCount++;</span><br><span class="line">        <span class="keyword">if</span> (i === x) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 得到循环的总长度loopCount和取余对应loopNum[]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loopNum.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> resMod = (n - <span class="number">1</span>) % loopCount; <span class="comment">// 获取循环中的余数（左移一位）</span></span><br><span class="line">    <span class="keyword">return</span> loopNum[resMod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。&lt;/p&gt;
&lt;p&gt;任何数的0次方都是1.&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;h3 id=&quot;思路1&quot;&gt;&lt;a href=&quot;#思路1&quot; class=&quot;headerlink&quot; title=&quot;思路1&quot;&gt;&lt;/a&gt;思路1&lt;/h3&gt;&lt;p&gt;不难发现规律： ((x%y)^n)%y = (x^n)%y&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JS" scheme="https://marycly.github.io/tags/JS/"/>
    
    <category term="算法" scheme="https://marycly.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="快速幂" scheme="https://marycly.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="大数越界" scheme="https://marycly.github.io/tags/%E5%A4%A7%E6%95%B0%E8%B6%8A%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>JS: Union-find(quick-union + weighting + path compression + map)</title>
    <link href="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/"/>
    <id>https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/</id>
    <published>2021-08-20T01:52:59.000Z</published>
    <updated>2022-08-24T09:02:57.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。</p><h3 id="用于解决的问题"><a href="#用于解决的问题" class="headerlink" title="用于解决的问题"></a>用于解决的问题</h3><p>假定一个学校的圈子中，有A,B,C…这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。</p><h3 id="核心的方法需求"><a href="#核心的方法需求" class="headerlink" title="核心的方法需求"></a>核心的方法需求</h3><p>Union(p, q): 将点p和点q建立连接的方法。</p><p>Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。</p><span id="more"></span><h2 id="基本构建思路"><a href="#基本构建思路" class="headerlink" title="基本构建思路"></a>基本构建思路</h2><h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick-Find"></a>Quick-Find</h3><p>这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png" alt="quick-find图解"></p><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png" alt="quick-find代码"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果一条很长的链被合并，可能需要大量地改变root值。</p><h3 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick-Union"></a>Quick-Union</h3><p>这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。</p><p>此时使用类似链表的数据结构十分恰当。</p><h4 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png" alt="quick-union图解"></p><h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png" alt="quick-union代码"></p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>如果有一条很长的链，查找效率会很低。</p><h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><h4 id="共通点"><a href="#共通点" class="headerlink" title="共通点"></a>共通点</h4><p>不管是quick-find还是quick-union，算法中都有这样的共通点：</p><p>1.每次union时会判断是否同根，如果是则直接跳过。</p><p>2.在进行两个子集的union时，会连接两个子集的root。</p><h4 id="时间复杂度比较"><a href="#时间复杂度比较" class="headerlink" title="时间复杂度比较"></a>时间复杂度比较</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/compare.png" alt="时间复杂度比较"></p><p>因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。</p><p>由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。</p><h2 id="Quick-Union算法的优化"><a href="#Quick-Union算法的优化" class="headerlink" title="Quick-Union算法的优化"></a>Quick-Union算法的优化</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。</p><p>结构：{key: id, value: parent_id}</p><h3 id="Weighting"><a href="#Weighting" class="headerlink" title="Weighting"></a>Weighting</h3><p>Weighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。</p><h4 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png" alt="weighting图解"></p><h4 id="代码变动"><a href="#代码变动" class="headerlink" title="代码变动"></a>代码变动</h4><p>由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。</p><p>map结构变化: {key: id, value: {parent: parent_id, size: size}}</p><p>union时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身</p><h3 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h3><p>Path Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。</p><h4 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg" alt="path-compression图解"></p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>quick-union + weighting + path compression + map</p><figure class="highlight javascript"><figcaption><span>Union-Find.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个节点保存的结构</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">parent, size</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent || <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.size = size || <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">p, q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(p)||!map.has(q))&#123;</span><br><span class="line">        <span class="comment">//有一个不在map里，说明是游离节点，自动设为child</span></span><br><span class="line">        <span class="keyword">if</span>(!map.has(p))&#123;</span><br><span class="line">            <span class="keyword">var</span> child = p, parent = find(q); <span class="comment">//path compression 父母直接设给根节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> child = q, parent = find(p);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(child, <span class="keyword">new</span> Node(parent, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//均存在map中，需要进行weighting的两个节点</span></span><br><span class="line">        <span class="keyword">const</span> pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; <span class="comment">//暂存两个节点的root</span></span><br><span class="line">        <span class="keyword">if</span>(pr===qr)&#123;</span><br><span class="line">            <span class="comment">//如果已经连通，不需要再连接了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prs &lt; qrs)&#123;</span><br><span class="line">            <span class="comment">//把容量更小的那个设为child被合并</span></span><br><span class="line">            <span class="keyword">var</span> child = pr, parent = qr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> child = qr, parent = pr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//root应该都存在map中</span></span><br><span class="line">        map.get(child).parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(parent))&#123;</span><br><span class="line">        map.set(parent, <span class="keyword">new</span> Node(parent, map.get(child).size+<span class="number">1</span>)); <span class="comment">//map中新建一个root node，root的parent设给自己</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.get(parent).size+=map.get(child).size+<span class="number">1</span>; <span class="comment">//合并size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(p))&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(map.get(p).parent!=p)&#123;</span><br><span class="line">        <span class="comment">//如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent</span></span><br><span class="line">        p = map.get(p).parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isConnected</span>(<span class="params">p, q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (find(p)===find(q));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最后贴上algorithms书中的各种方法的时间复杂度：</p><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png" alt="时间复杂度比较"></p><p>有weighting和path compression的quick union时间复杂度无限接近1。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。&lt;/p&gt;
&lt;h3 id=&quot;用于解决的问题&quot;&gt;&lt;a href=&quot;#用于解决的问题&quot; class=&quot;headerlink&quot; title=&quot;用于解决的问题&quot;&gt;&lt;/a&gt;用于解决的问题&lt;/h3&gt;&lt;p&gt;假定一个学校的圈子中，有A,B,C…这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。&lt;/p&gt;
&lt;h3 id=&quot;核心的方法需求&quot;&gt;&lt;a href=&quot;#核心的方法需求&quot; class=&quot;headerlink&quot; title=&quot;核心的方法需求&quot;&gt;&lt;/a&gt;核心的方法需求&lt;/h3&gt;&lt;p&gt;Union(p, q): 将点p和点q建立连接的方法。&lt;/p&gt;
&lt;p&gt;Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JS" scheme="https://marycly.github.io/tags/JS/"/>
    
    <category term="算法" scheme="https://marycly.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）</title>
    <link href="https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-08-18T08:35:47.000Z</published>
    <updated>2022-08-24T09:02:07.318Z</updated>
    
    <content type="html"><![CDATA[<p>上一章内容：<a href="/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89">关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</a></p><p>原代码不再贴出。</p><h2 id="新的工程需求"><a href="#新的工程需求" class="headerlink" title="新的工程需求"></a>新的工程需求</h2><p>上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：</p><p>不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。</p><h2 id="初步想法：阻止手势穿透"><a href="#初步想法：阻止手势穿透" class="headerlink" title="初步想法：阻止手势穿透"></a>初步想法：阻止手势穿透</h2><p>微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？</p><span id="more"></span><h2 id="尝试：将bind换成catch"><a href="#尝试：将bind换成catch" class="headerlink" title="尝试：将bind换成catch"></a>尝试：将bind换成catch</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;touchStart&quot; catchtouchmove=&quot;touchMove&quot;&gt;</span><br><span class="line">&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。</p><h2 id="尝试：使bind和catch的事件根据isTouchMove进行变化"><a href="#尝试：使bind和catch的事件根据isTouchMove进行变化" class="headerlink" title="尝试：使bind和catch的事件根据isTouchMove进行变化"></a>尝试：使bind和catch的事件根据isTouchMove进行变化</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot; </span><br><span class="line">    bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。</p><h2 id="尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个"><a href="#尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个" class="headerlink" title="尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个"></a>尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:if=&quot;&#123;&#123;!item.isTouchMove&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><p>效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。</p><h2 id="最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换"><a href="#最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换" class="headerlink" title="最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换"></a>最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换</h2><p>绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。</p><p>思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。</p><p>注意：css中，动画设定是0.4s，延时应当适当小于这个值。</p><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:if=&quot;&#123;&#123;index!==hidden&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Page */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">dataList</span>: [<span class="comment">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class="line">    <span class="attr">startX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">startY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">null</span>,<span class="comment">//标记被隐藏的块index</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">touchStart</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataList = <span class="built_in">this</span>.data.dataList;</span><br><span class="line">    dataList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.isTouchMove) &#123;</span><br><span class="line">        item.isTouchMove = !item.isTouchMove;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.data.hidden = <span class="literal">null</span>; <span class="comment">//先把hidden置null, 但不渲染</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.data.startX = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">    <span class="built_in">this</span>.data.startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">touchMove</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> moveX = e.changedTouches[<span class="number">0</span>].clientX,</span><br><span class="line">      moveY = e.changedTouches[<span class="number">0</span>].clientY,</span><br><span class="line">      curIndex = e.currentTarget.dataset.index, </span><br><span class="line">      dataList = <span class="built_in">this</span>.data.dataList,</span><br><span class="line">      angle = <span class="built_in">this</span>.angle(</span><br><span class="line">        &#123; <span class="attr">X</span>: <span class="built_in">this</span>.data.startX,</span><br><span class="line">    <span class="attr">Y</span>: <span class="built_in">this</span>.data.startY</span><br><span class="line">    &#125;, &#123; <span class="attr">X</span>: moveX,</span><br><span class="line">    <span class="attr">Y</span>: moveY</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span>; <span class="comment">//用于在forEach函数里访问data</span></span><br><span class="line">    dataList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (curIndex === index &amp;&amp; angle &lt; <span class="number">30</span> &amp;&amp; moveX &lt; <span class="built_in">this</span>.data.startX) &#123;</span><br><span class="line">        item.isTouchMove = <span class="literal">true</span>;</span><br><span class="line">        that.data.hidden = index;<span class="comment">//如果有块被滑动，将hidden设为此块，否则就会保持在null</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      item.isTouchMove = <span class="literal">false</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    setTimeOut(&#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        <span class="attr">hidden</span>: that.data.hidden <span class="comment">//0.3s后渲染hidden来替换组件，此时动画基本放完了</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一章内容：&lt;a href=&quot;/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89&quot;&gt;关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原代码不再贴出。&lt;/p&gt;
&lt;h2 id=&quot;新的工程需求&quot;&gt;&lt;a href=&quot;#新的工程需求&quot; class=&quot;headerlink&quot; title=&quot;新的工程需求&quot;&gt;&lt;/a&gt;新的工程需求&lt;/h2&gt;&lt;p&gt;上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：&lt;/p&gt;
&lt;p&gt;不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。&lt;/p&gt;
&lt;h2 id=&quot;初步想法：阻止手势穿透&quot;&gt;&lt;a href=&quot;#初步想法：阻止手势穿透&quot; class=&quot;headerlink&quot; title=&quot;初步想法：阻止手势穿透&quot;&gt;&lt;/a&gt;初步想法：阻止手势穿透&lt;/h2&gt;&lt;p&gt;微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="微信小程序" scheme="https://marycly.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</title>
    <link href="https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-08-16T03:14:19.000Z</published>
    <updated>2022-08-24T09:02:22.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工程需求"><a href="#工程需求" class="headerlink" title="工程需求"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端APP。</p><p>在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。</p><h2 id="方案参考"><a href="#方案参考" class="headerlink" title="方案参考"></a>方案参考</h2><p>由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。</p><p>参考链接：<a href="https://blog.csdn.net/LiaoFengJi/article/details/105218664">https://blog.csdn.net/LiaoFengJi/article/details/105218664</a></p><span id="more"></span><h2 id="提炼代码如下："><a href="#提炼代码如下：" class="headerlink" title="提炼代码如下："></a>提炼代码如下：</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;touchStart&quot; bindtouchmove=&quot;touchMove&quot;&gt;</span><br><span class="line">&lt;!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 --&gt;</span><br><span class="line">&lt;view class=&quot;item-left&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;!-- 每条要显示的内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;item-right&quot;&gt;</span><br><span class="line">&lt;view class=&quot;btn-right&quot; bindtap=&quot;setTopItem&quot;&gt;置顶&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;btn-right&quot; bindtap=&quot;deleteItem&quot;&gt;删除&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>index.wxss</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 内容部分 */</span><br><span class="line">.item-left &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  -webkit-transition: all 0.4s;</span><br><span class="line">  transition: all 0.4s;</span><br><span class="line">  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 按钮部分 */</span><br><span class="line">.item-right &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  width: 400rpx; /*根据需要调整*/</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class="line">  -webkit-transition: all 0.4s;</span><br><span class="line">  transition: all 0.4s;</span><br><span class="line">  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btn-right &#123;</span><br><span class="line">  width: 50%; /*这里根据自己的需要划成了两半*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 向左滑动 */</span><br><span class="line">.touch-move-active .item-left,</span><br><span class="line">.touch-move-active .item-right &#123;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  -webkit-transform: translateX(0);</span><br><span class="line">  transform: translateX(0);</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Page */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">dataList</span>: [<span class="comment">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class="line">    <span class="attr">startX</span>: <span class="number">0</span>,<span class="comment">// 设置开始的位置X</span></span><br><span class="line">    <span class="attr">startY</span>: <span class="number">0</span>,<span class="comment">// 设置开始的位置Y</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始滑动</span></span><br><span class="line">  <span class="function"><span class="title">touchStart</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataList = <span class="built_in">this</span>.data.dataList;</span><br><span class="line">    dataList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 让原先滑动的块隐藏</span></span><br><span class="line">      <span class="keyword">if</span> (item.isTouchMove) &#123;</span><br><span class="line">        item.isTouchMove = !item.isTouchMove;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 初始化开始位置</span></span><br><span class="line">    <span class="built_in">this</span>.data.startX = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">    <span class="built_in">this</span>.data.startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line"><span class="comment">// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="comment">// 滑动的过程</span></span><br><span class="line">  <span class="function"><span class="title">touchMove</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> moveX = e.changedTouches[<span class="number">0</span>].clientX,</span><br><span class="line">      moveY = e.changedTouches[<span class="number">0</span>].clientY,</span><br><span class="line">      curIndex = e.currentTarget.dataset.index, </span><br><span class="line">      <span class="comment">//注意，wxml里面一定要设置data-index=&quot;&#123;&#123;index&#125;&#125;&quot;,这样e.currentTarget.dataset中才会传index的值</span></span><br><span class="line">      dataList = <span class="built_in">this</span>.data.dataList,</span><br><span class="line">      <span class="comment">// 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动</span></span><br><span class="line">      angle = <span class="built_in">this</span>.angle(</span><br><span class="line">        &#123; <span class="attr">X</span>: <span class="built_in">this</span>.data.startX,</span><br><span class="line">    <span class="attr">Y</span>: <span class="built_in">this</span>.data.startY</span><br><span class="line">    &#125;, &#123; <span class="attr">X</span>: moveX,</span><br><span class="line">    <span class="attr">Y</span>: moveY</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">    dataList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里相对参考代码做了精炼</span></span><br><span class="line"><span class="comment">// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑</span></span><br><span class="line">      <span class="keyword">if</span> (curIndex === index &amp;&amp; angle &lt; <span class="number">30</span> &amp;&amp; moveX &lt; <span class="built_in">this</span>.data.startX) &#123;</span><br><span class="line">        item.isTouchMove = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      item.isTouchMove = <span class="literal">false</span>; <span class="comment">//否则右滑</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      dataList</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 计算滑动角度</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>start 起点坐标</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>end 终点坐标</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">angle</span>: <span class="function"><span class="keyword">function</span> (<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _X = end.X - start.X,</span><br><span class="line">      _Y = end.Y - start.Y</span><br><span class="line">    <span class="comment">//返回角度 /Math.atan()返回数字的反正切值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">360</span> * <span class="built_in">Math</span>.atan(_Y / _X) / (<span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="function"><span class="title">deleteItem</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 这里是具体删除item的方法 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/%E4%BE%A7%E6%BB%91%E6%95%88%E6%9E%9C.gif" alt="侧滑效果"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。</p><p>实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;工程需求&quot;&gt;&lt;a href=&quot;#工程需求&quot; class=&quot;headerlink&quot; title=&quot;工程需求&quot;&gt;&lt;/a&gt;工程需求&lt;/h2&gt;&lt;p&gt;开发的应用：用微信小程序经由hera生成的跨平台移动端APP。&lt;/p&gt;
&lt;p&gt;在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。&lt;/p&gt;
&lt;h2 id=&quot;方案参考&quot;&gt;&lt;a href=&quot;#方案参考&quot; class=&quot;headerlink&quot; title=&quot;方案参考&quot;&gt;&lt;/a&gt;方案参考&lt;/h2&gt;&lt;p&gt;由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/LiaoFengJi/article/details/105218664&quot;&gt;https://blog.csdn.net/LiaoFengJi/article/details/105218664&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="微信小程序" scheme="https://marycly.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序：灵活适配不同标题栏高度的设备的方法</title>
    <link href="https://marycly.github.io/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E7%81%B5%E6%B4%BB%E9%80%82%E9%85%8D%E4%B8%8D%E5%90%8C%E6%A0%87%E9%A2%98%E6%A0%8F%E9%AB%98%E5%BA%A6%E7%9A%84%E8%AE%BE%E5%A4%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://marycly.github.io/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E7%81%B5%E6%B4%BB%E9%80%82%E9%85%8D%E4%B8%8D%E5%90%8C%E6%A0%87%E9%A2%98%E6%A0%8F%E9%AB%98%E5%BA%A6%E7%9A%84%E8%AE%BE%E5%A4%87%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2021-08-14T15:40:07.000Z</published>
    <updated>2022-08-24T09:02:33.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工程需求"><a href="#工程需求" class="headerlink" title="工程需求"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端App。</p><p>作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？</p><p>首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。</p><h2 id="方案参考"><a href="#方案参考" class="headerlink" title="方案参考"></a>方案参考</h2><p>在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。</p><p>私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：</p><span id="more"></span><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><h3 id="大体思路如下："><a href="#大体思路如下：" class="headerlink" title="大体思路如下："></a>大体思路如下：</h3><p>在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。</p><h3 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page */</span></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"><span class="attr">dAbsoluteTop</span>: <span class="number">0</span>, <span class="comment">//准备设置固定内容组件的高度</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">const</span> query = wx.createSelectorQuery();</span><br><span class="line">query.select(<span class="string">&#x27;#fixed-view&#x27;</span>).boundingClientRect();</span><br><span class="line">query.selectViewport().scrollOffset();</span><br><span class="line">query.exec(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">that.setData(&#123;</span><br><span class="line"><span class="attr">dAbsoluteTop</span>: res[<span class="number">0</span>].bottom <span class="comment">//根据底部渲染</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=&quot;fixed-view&quot; style=&quot;position: fixed; top: 0; display: flex; flex-direction: column;&quot;&gt;</span><br><span class="line">&lt;titlebar /&gt; &lt;!-- 标题栏 --&gt;</span><br><span class="line">&lt;tabbar /&gt; &lt;!-- 选择标签栏 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view style=&quot;position: absolute; top: &#123;&#123;dAbsolute&#125;&#125;;&quot;&gt;</span><br><span class="line">&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>经不同设备检验，效果良好。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;工程需求&quot;&gt;&lt;a href=&quot;#工程需求&quot; class=&quot;headerlink&quot; title=&quot;工程需求&quot;&gt;&lt;/a&gt;工程需求&lt;/h2&gt;&lt;p&gt;开发的应用：用微信小程序经由hera生成的跨平台移动端App。&lt;/p&gt;
&lt;p&gt;作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？&lt;/p&gt;
&lt;p&gt;首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。&lt;/p&gt;
&lt;h2 id=&quot;方案参考&quot;&gt;&lt;a href=&quot;#方案参考&quot; class=&quot;headerlink&quot; title=&quot;方案参考&quot;&gt;&lt;/a&gt;方案参考&lt;/h2&gt;&lt;p&gt;在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。&lt;/p&gt;
&lt;p&gt;私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="微信小程序" scheme="https://marycly.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>

<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>程序员玛丽的星海方舟 | 各种问题的发现、解决与感想</title><meta name="description" content="&lt;p&gt;前段时间参与了一个项目的开发，共计超过一个月的时间。工作量其实是非常饱和的，并且在接手各种老旧工程的时候经历了很多奇奇怪怪的问题，有的至今难以解决。特此分享一下在这段项目中发现的一些问题解决方案及感想。&lt;/p&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%90%8E%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E5%9C%B0%E5%9D%80%E9%BB%98%E8%AE%A4%E6%98%AF%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;重定向到统一登录页面后，返回的地址默认是网站首页的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;跨域传输数据的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%97%A0%E6%B3%95%E6%9B%B4%E6%94%B9%E6%BA%90%E7%A0%81%E6%97%B6%E9%98%BB%E6%AD%A2%E7%BD%91%E9%A1%B5%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;无法更改源码时阻止网页中默认弹出提示的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E4%BB%98%E5%89%8D%E4%BA%BA%E5%86%99%E7%9A%84%E5%9D%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E6%84%9F%E6%83%B3&quot;&gt;对付前人写的坏代码的心得感想&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;"><link rel="icon" href="https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/物理2-飞船2.svg"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700"><link rel="stylesheet" href="/css/highlights/darkula.css"><link rel="stylesheet" href="/css/main.css"><link rel="search" type="application/opensearchdescription+xml" href="https://MaryCLY.github.io/atom.xml" title="程序员玛丽的星海方舟"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="程序员玛丽的星海方舟" type="application/atom+xml">
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">程序员玛丽的星海方舟</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link" href="/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/about/" target="_self">ABOUT</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="/archives/" target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/maryCLY" target="_blank">GITHUB</a></li></ul></nav></header><main class="container__wrapper"><article class="article post"><h1 class="article__title">各种问题的发现、解决与感想</h1><div class="article__date metadata"><div class="post-info">2022/10/28</div></div><div class="article__categories metadata">分类:
<a class="article__categories__link metadata" href="/categories/%E5%BC%80%E5%8F%91/">开发</a></div><div class="article__tags metadata">标签:
<a class="article__tags__link metadata" href="/tags/JS/">JS</a></div><div class="article__body"><p>前段时间参与了一个项目的开发，共计超过一个月的时间。工作量其实是非常饱和的，并且在接手各种老旧工程的时候经历了很多奇奇怪怪的问题，有的至今难以解决。特此分享一下在这段项目中发现的一些问题解决方案及感想。</p>
<p>目录：</p>
<ul>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%90%8E%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E5%9C%B0%E5%9D%80%E9%BB%98%E8%AE%A4%E6%98%AF%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">重定向到统一登录页面后，返回的地址默认是网站首页的解决方案</a></li>
<li><a href="#%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">跨域传输数据的解决方案</a></li>
<li><a href="#%E6%97%A0%E6%B3%95%E6%9B%B4%E6%94%B9%E6%BA%90%E7%A0%81%E6%97%B6%E9%98%BB%E6%AD%A2%E7%BD%91%E9%A1%B5%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">无法更改源码时阻止网页中默认弹出提示的解决方案</a></li>
<li><a href="#%E5%AF%B9%E4%BB%98%E5%89%8D%E4%BA%BA%E5%86%99%E7%9A%84%E5%9D%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E6%84%9F%E6%83%B3">对付前人写的坏代码的心得感想</a></li>
</ul>
<span id="more"></span>

<hr>
<h2 id="重定向到统一登录页面后，返回的地址默认是网站首页的解决方案"><a href="#重定向到统一登录页面后，返回的地址默认是网站首页的解决方案" class="headerlink" title="重定向到统一登录页面后，返回的地址默认是网站首页的解决方案"></a>重定向到统一登录页面后，返回的地址默认是网站首页的解决方案</h2><p>问题描述：网站未登录时重定向到统一登录页面，登录成功自动返回时返回的是网站首页，丢失了后面的路由部分，不能按照预期返回原来的页面。</p>
<p>解决方式：未登录重定向前，将原先的url（删去携带的用户令牌信息）完整保存在Session Storage（浏览器临时存储）中。在进入网站首页时，检测Session Storage是否保存了url，如果有的话，重定向到该url，并删除存储即可。</p>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向前</span></span><br><span class="line"><span class="keyword">const</span> unsavedHref = <span class="built_in">window</span>.top.location.href <span class="comment">// 获取窗口url</span></span><br><span class="line"><span class="comment">// 我这边加入了删除用户令牌信息的代码（使用正则）</span></span><br><span class="line"><span class="built_in">window</span>.top.sessionStorage.setItem(<span class="string">&#x27;unsavedHref&#x27;</span>, unsavedHref) <span class="comment">// 将url保存在sessionStorage里</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录成功回到网站首页后</span></span><br><span class="line"><span class="keyword">const</span> unsavedHref = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;unsavedHref&#x27;</span>) <span class="comment">// 获取sessionStorage，如果没有则会得到undefined</span></span><br><span class="line"><span class="keyword">if</span> (unsavedHref) &#123;</span><br><span class="line">  <span class="comment">// 如果sessionStorage中存在未保存链接，则恢复</span></span><br><span class="line">  <span class="built_in">window</span>.sessionStorage.removeItem(<span class="string">&#x27;unsavedHref&#x27;</span>) <span class="comment">// 删除存储，这是为了防止后续正常访问首页时也被重定向到存储中的链接</span></span><br><span class="line">  <span class="built_in">window</span>.top.location.href = unsavedHref <span class="comment">// 进行跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="跨域传输数据的解决方案"><a href="#跨域传输数据的解决方案" class="headerlink" title="跨域传输数据的解决方案"></a>跨域传输数据的解决方案</h2><p>问题描述：A页面中存在一定的数据，需要在跨域打开的B页面中获取使用。</p>
<h3 id="方案一：使用url传参的方式。"><a href="#方案一：使用url传参的方式。" class="headerlink" title="方案一：使用url传参的方式。"></a>方案一：使用url传参的方式。</h3><p>实现方式：A页面跳转到B页面时，在url中拼接?data=&lt;…&gt;形式的参数。B页面启动时，获取到url中的参数即可。</p>
<p>优点：速度快，B页面启动后立刻能获取到。</p>
<p>缺点：数据过长的时候，url长度可能会被浏览器限制。</p>
<h3 id="方案二：使用window-postMessage方法。"><a href="#方案二：使用window-postMessage方法。" class="headerlink" title="方案二：使用window.postMessage方法。"></a>方案二：使用window.postMessage方法。</h3><p>技术前提：使用window.open打开页面时，A页面可获取到B页面的窗口对象，B页面也可通过window.opener获取到A页面的窗口对象。</p>
<p>具体过程：B页面加载完成并绑定监听器后，先发送消息告知A页面；A页面接收到消息后，向B页面发送消息传递数据；B页面接收到消息后，则根据消息中的数据执行操作。</p>
<p>优点：无需考虑数据的长度限制。</p>
<p>缺点：异步操作，需要一定时间才能完成；A、B页面都需要明确对方的源地址；需要A页面保持开启才会发送数据。</p>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A页面 - 打开B页面前</span></span><br><span class="line"><span class="keyword">const</span> nextOrigin = <span class="string">&#x27;https://marycly.github.io&#x27;</span> <span class="comment">// B页面的源地址</span></span><br><span class="line"><span class="keyword">const</span> nextUrl = <span class="string">&#x27;https://marycly.github.io/archives/&#x27;</span> <span class="comment">// B页面的完整打开地址</span></span><br><span class="line"><span class="keyword">const</span> parseValue = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// 要传递的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.origin.includes(nextOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 任何消息监听器里都应该加上这个判断，不仅可以区分不同地址发来的消息所产生的不同效果，也可以防止未知网站的消息攻击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.receiveMessageTimeout) &#123;</span><br><span class="line">    <span class="built_in">window</span>.clearTimeout(<span class="built_in">this</span>.receiveMessageTimeout)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.receiveMessageTimeout = <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nextPage.postMessage(parseValue, nextOrigin) <span class="comment">// 这是最终会干的事情，向B页面发送数据</span></span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">  <span class="comment">// 这里小小做了一个0.5s延时的消抖，防止消息重复发送</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">this</span>.nextPage = <span class="built_in">window</span>.open(nextUrl) <span class="comment">// 然后打开B页面，并保存窗口对象到变量中，便于监听器调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B页面 - 加载完成后</span></span><br><span class="line"><span class="keyword">const</span> lastOrigin = <span class="string">&#x27;https://anyone.hello&#x27;</span> <span class="comment">// A页面的源地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.origin.includes(lastOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 任何消息监听器里都应该加上这个判断，不仅可以区分不同地址发来的消息所产生的不同效果，也可以防止未知网站的消息攻击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用e.data干任何事！</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.data)</span><br><span class="line">  <span class="built_in">this</span>.lastPageData = e.data</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> lastPage = <span class="built_in">window</span>.opener <span class="comment">// 通过opener获取A页面的窗口对象</span></span><br><span class="line">lastPage.postMessage(<span class="string">&#x27;I am all okay!&#x27;</span>, lastOrigin) <span class="comment">// 向A页面表示你已经准备好接收数据了</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="无法更改源码时阻止网页中默认弹出提示的解决方案"><a href="#无法更改源码时阻止网页中默认弹出提示的解决方案" class="headerlink" title="无法更改源码时阻止网页中默认弹出提示的解决方案"></a>无法更改源码时阻止网页中默认弹出提示的解决方案</h2><p>问题描述：工程所使用的一个依赖包中有这样一个逻辑，提交数据成功时会默认弹出一个提示（element-ui的message组件）。现需要阻止该提示，但依赖包的内容难以直接更改。</p>
<p>解决方式：获取该message组件弹窗显示的元素类名，在弹窗出现时使用querySelector找到该元素，并移除它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&#x27;.el-message&#x27;).remove()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="对付前人写的坏代码的心得感想"><a href="#对付前人写的坏代码的心得感想" class="headerlink" title="对付前人写的坏代码的心得感想"></a>对付前人写的坏代码的心得感想</h2><p>当接手某个工程的时候，有时会发现一些不规范的，逻辑错误的，或是造成了全局性不良污染的代码。我认为比较合适的处理方式如下：</p>
<ol>
<li><p>首先，需要仔细评估该段代码的影响范围。如果牵涉的范围非常大，且依赖于该代码的功能都能够正常运行，则不应轻易更改，而考虑使用局部重写的方式解决问题。</p>
</li>
<li><p>然后，需要理解该段代码的意义和作用，确定自己的更改是否100%不影响原先的功能。如果不确定，尝试跟原开发者联系确认。</p>
</li>
<li><p>如果影响范围较小且能确保不影响逻辑，或者影响范围只有正在开发的当前页面或模块，便可以进行修改。修改后必须要经过反复的自测验证，保证功能正常运作。</p>
</li>
<li><p>有时某段有问题的代码会随着工程体量的增加而积重难返，这时大概率是要对它妥协，将就总比意外好。</p>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再也不想加班和直面屎山了！</p>
</div></article><div class="pagination"><a class="pagination__link pagination__prev" href="/%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%84%9F%E6%83%B3-2/">上一篇</a><a class="pagination__link pagination__next" href="/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E7%BB%8F%E9%AA%8C/">下一篇</a></div></main><footer class="footer metadata"><p class="footer__text">© 2024 陈俪影</p><p class="footer__text">Powered by <a class="footer__text__link" href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a class="footer__text__link" href="https://pages.github.com/" target="_blank">Github Page</a></p></footer></div></body></html>
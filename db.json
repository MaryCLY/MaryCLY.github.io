{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/lx/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/lx/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/lx/source/css/main.min.css","path":"css/main.min.css","modified":1,"renderable":1},{"_id":"themes/lx/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/lx/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/cover.jpeg","path":"images/cover.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/footer-l.jpeg","path":"images/footer-l.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/footer-r.jpeg","path":"images/footer-r.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/post_cover.jpeg","path":"images/post_cover.jpeg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/lx/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/lx/source/js/jquery.easing.min.js","path":"js/jquery.easing.min.js","modified":1,"renderable":1},{"_id":"themes/lx/source/js/jquery.jside.menu.js","path":"js/jquery.jside.menu.js","modified":1,"renderable":1},{"_id":"themes/lx/source/js/local.search.js","path":"js/local.search.js","modified":1,"renderable":1},{"_id":"themes/lx/source/css/menu/button.styl","path":"css/menu/button.styl","modified":1,"renderable":1},{"_id":"themes/lx/source/css/menu/menu.styl","path":"css/menu/menu.styl","modified":1,"renderable":1},{"_id":"themes/lx/source/css/page_style/page_style.styl","path":"css/page_style/page_style.styl","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map.md","hash":"8a509e5471bb7c4ab41c005e9ce0cb5d82f35d4e","modified":1630250110868},{"_id":"source/_posts/Pow-x-n-10-（快速幂-大数取模问题）.md","hash":"12d9ed1f1a831cec7a96c9155e0a149c535f11da","modified":1630317585196},{"_id":"source/_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）.md","hash":"f7aa2d4ef1b5ca157676c28db76d582bb01af1ca","modified":1629453099894},{"_id":"source/_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）.md","hash":"2d68bab635a5e5b63c6d62c63835d3f567c49215","modified":1629453099922},{"_id":"source/_posts/微信小程序：灵活适配不同标题栏高度的设备的方法.md","hash":"95f85a9996c7b8d9b77d92ef75c7b8978decb28a","modified":1629453099923},{"_id":"source/about/index.md","hash":"ef01c825579fdfd820ca4a1fbf2b4e8eb4674665","modified":1630331442661},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg","hash":"2ad76c60d6d8f172555f45575da3bad866542aa2","modified":1629453099885},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png","hash":"ebab7bc8a320818e31d5952bec8009dc6abc14d1","modified":1629453099886},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png","hash":"c370ef1ff1e4458fcbf83ffe9802dfaccf193e2c","modified":1629453099891},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png","hash":"4324dcf04b74152be6de70860e3e1ee7cbe34953","modified":1629453099882},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/compare.png","hash":"710314ce886d5ca0e1c125b2f8d5197a70d4e998","modified":1629453099883},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png","hash":"c8abdb84d9c33272d5b815b72cec98adf467b2ad","modified":1629453099887},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png","hash":"0824bb0d2d6bb43a0028fafd26395aedb5bc2c27","modified":1629453099889},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png","hash":"bdf83f353affd7055761dd54d46f6e509aa8fe36","modified":1629453099893},{"_id":"themes/lx/.gitignore","hash":"87ba54d22c49aaf9f302309244be4009278a5dc1","modified":1629453099977},{"_id":"themes/lx/.editorconfig","hash":"dc7797dd69f0037ef5048f6b6f3b0217c0e0efc4","modified":1629453099973},{"_id":"themes/lx/CODE_OF_CONDUCT.md","hash":"549cec0446b45a45760744fa88049a6b571c9ebe","modified":1629453099978},{"_id":"themes/lx/CONTRIBUTING.md","hash":"6e9a02510cf7965b9dd0c61006a1325114227563","modified":1629453099978},{"_id":"themes/lx/LICENSE","hash":"4394e136b0ccaa770c057706f12d046ef1e0966f","modified":1629453099979},{"_id":"themes/lx/_config.yml","hash":"a39a62b87da850ce1ea7fa298d261d06500258fc","modified":1630330305865},{"_id":"themes/lx/README.md","hash":"af86577f147c42913640fa8566d7a8f0ecbc8013","modified":1629453099979},{"_id":"themes/lx/package.json","hash":"2c3add4c2d20429b9e3e048dfe82f664d18f73f3","modified":1629453099995},{"_id":"themes/lx/.github/FUNDING.yml","hash":"70c496850d98768a2f52e8a6f154c03be22b20c0","modified":1629453099974},{"_id":"themes/lx/README/README.zh.md","hash":"f8134501daa596ff36f032906ce7640ec3e4fe4e","modified":1629453099980},{"_id":"themes/lx/languages/en.yml","hash":"65e5bcbc883ac718fadb6a79505f145dec0c9e28","modified":1629453099981},{"_id":"themes/lx/layout/archive.ejs","hash":"171588edc68c827814a6ddabcba77a659cebf3c6","modified":1629453099982},{"_id":"themes/lx/languages/zh.yml","hash":"56668514d677ec63a918ed932baacfbaa3d975e1","modified":1629453099982},{"_id":"themes/lx/layout/index.ejs","hash":"5143c704fa9ebbc2bdce888c78d1cbbc9f60549c","modified":1629453099983},{"_id":"themes/lx/layout/layout.ejs","hash":"5c2db885ad301862e9c7a2b40fb530f85d9d8840","modified":1629453099984},{"_id":"themes/lx/layout/page.ejs","hash":"d48b85e518b0f60d0b3eb704f5a1a65189ae854c","modified":1629453099984},{"_id":"themes/lx/layout/post.ejs","hash":"eb6830cf6770d1c0f7cbb5b901fceeb32b4c014f","modified":1629453099990},{"_id":"themes/lx/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1629453100004},{"_id":"themes/lx/.github/ISSUE_TEMPLATE/------bug-bug-report.md","hash":"ffa54dc9061531e1c4ad51f9f947f8cfc3034b63","modified":1629453099975},{"_id":"themes/lx/.github/ISSUE_TEMPLATE/--------feature-request.md","hash":"d169dff110923dd5fbc5ba3c3a966b2049ef0be1","modified":1629453099974},{"_id":"themes/lx/.github/ISSUE_TEMPLATE/------help-wanted.md","hash":"5cb6957ecd448779e4aedd735691e7f7fdb07e19","modified":1629453099976},{"_id":"themes/lx/.github/workflows/greetings.yml","hash":"f539aa99c9b941f427897fe636a79dbd7eef0fe9","modified":1629453099977},{"_id":"themes/lx/layout/partials/aside.ejs","hash":"436da0db022602e9d91655ca2e767d651a80bcba","modified":1629453099985},{"_id":"themes/lx/layout/partials/config.ejs","hash":"9eb72a63ba0757b5d2055875ca559fda511e1610","modified":1629453099986},{"_id":"themes/lx/layout/partials/font.ejs","hash":"082edb9da043186dfe0ccaeb4942f837349861cb","modified":1629453099986},{"_id":"themes/lx/layout/partials/footer.ejs","hash":"d2b0d7db0a7c8a3709fbd2ff9cf443599cffce94","modified":1629453099987},{"_id":"themes/lx/layout/partials/menu.ejs","hash":"7a5669635602506f2bf91866b0bcdeadec302e47","modified":1629453099987},{"_id":"themes/lx/layout/partials/pagination.ejs","hash":"d9e5a782597aed71d0b639c5beafa32dcd5a50c5","modified":1629453099988},{"_id":"themes/lx/layout/partials/post-footer.ejs","hash":"a6bcdf77c5b16963b5205e7df4c93d5dff951d83","modified":1629453099988},{"_id":"themes/lx/layout/partials/post-header.ejs","hash":"435e2eb2473e870b1501d07cc8167d5900c6dc85","modified":1629453099989},{"_id":"themes/lx/layout/partials/recent-posts.ejs","hash":"d8b047769630ccb38acc345c001b34686def8962","modified":1629453099989},{"_id":"themes/lx/layout/partials/search.ejs","hash":"cdac775b4d170c54a91a3351c3027b228843ac1b","modified":1629453099989},{"_id":"themes/lx/layout/partials/sociallinks.ejs","hash":"e5263d447d3fe65710a108e46d8411bf46415550","modified":1629453099990},{"_id":"themes/lx/layout/third-party/comment.ejs","hash":"2019105df99d8c8dd9ca0aef4a95aa4f050ea9fd","modified":1629453099994},{"_id":"themes/lx/layout/third-party/mathjax.ejs","hash":"22867399744379382e67b9a91b71f720c900b499","modified":1629453099994},{"_id":"themes/lx/scripts/helpers/font.js","hash":"231b3a10d229e9606ab965a24250a993bcaa29ec","modified":1629453099997},{"_id":"themes/lx/scripts/tags/button.js","hash":"13e06e262d537636b525e38a6620e68f9c1d58c3","modified":1629453099997},{"_id":"themes/lx/scripts/tags/label.js","hash":"d3703b9c9a583783de487e153aac20542d7115b1","modified":1629453099998},{"_id":"themes/lx/scripts/tags/center-quote.js","hash":"695f2530317e906dd7de997a2a25455189006077","modified":1629453099998},{"_id":"themes/lx/scripts/tags/note.js","hash":"55ea05c45ea091826038f62f98fd1620f9960ce9","modified":1629453099999},{"_id":"themes/lx/scripts/tags/video.js","hash":"2235cbe69d313c6890e40955d5da20b955f185d3","modified":1629453099999},{"_id":"themes/lx/source/css/base.styl","hash":"c1abc364e9816f7b9c29401f9a28efa3045d8728","modified":1629453100000},{"_id":"themes/lx/source/css/main.min.css","hash":"20c32e1a93832269ab5c9ed0f9b07c6921a86bea","modified":1629453100001},{"_id":"themes/lx/source/css/main.styl","hash":"f2ce5402d2c788314759fe963f3530823a4d4ce4","modified":1629453100002},{"_id":"themes/lx/source/images/avatar.jpeg","hash":"7ce0557fb0cdf3d05e2e3be975d73ea0e6635df6","modified":1629453100005},{"_id":"themes/lx/source/images/footer-l.jpeg","hash":"f036edc5f66ffbcc34c3d855414c6ca5ef30a04b","modified":1629453100008},{"_id":"themes/lx/source/images/footer-r.jpeg","hash":"5c7677ac85cf8a683b91e97702b7096017006b4f","modified":1629453100009},{"_id":"themes/lx/source/images/post_cover.jpeg","hash":"93f216636c87dbbe635d4bb6b944851d92d84723","modified":1629453100010},{"_id":"themes/lx/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1629453100010},{"_id":"themes/lx/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1629453100011},{"_id":"themes/lx/source/js/jquery.easing.min.js","hash":"54be6707bc47ec09b6b40f658cd6e840415379b9","modified":1629453100011},{"_id":"themes/lx/source/js/jquery.jside.menu.js","hash":"d15b40199520d22771f9a211ac4282041df2ae5a","modified":1629453100012},{"_id":"themes/lx/source/js/local.search.js","hash":"770e063f160c11b5cb6f0233629ce9ae70207edb","modified":1629453100012},{"_id":"themes/lx/layout/third-party/analytics/baidu-analytics.ejs","hash":"46e74e98dc950e9df7280c50c6cd07359de5b4fd","modified":1629453099992},{"_id":"themes/lx/layout/third-party/analytics/google-analytics.ejs","hash":"9d95e4abfd45222934370861d6948300dc15d3ec","modified":1629453099992},{"_id":"themes/lx/layout/third-party/analytics/index.ejs","hash":"c98b574b2634de33694edb40b1f9120160b81acb","modified":1629453099993},{"_id":"themes/lx/source/css/menu/button.styl","hash":"4ea6d48484b235f3f3b480c6c478febc59c65354","modified":1629453100003},{"_id":"themes/lx/source/css/menu/menu.styl","hash":"ebe4d6bc7e0081ad4d7659427abb98a1344c1aae","modified":1629453100003},{"_id":"themes/lx/source/css/page_style/page_style.styl","hash":"8c76756cd6fabe20c0926c4551295d9ab41cc465","modified":1629453100004},{"_id":"themes/lx/source/images/cover.jpeg","hash":"186350a358c03649b83d5501ee43c90b1cc1160e","modified":1629453100007},{"_id":"source/_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）/侧滑效果.gif","hash":"3b489ac4084d6ebd5b1b3de30b7d9d429f777af4","modified":1629453099921},{"_id":"public/search.xml","hash":"dd2b0021152c5254e8633206822ad9ab277891e3","modified":1630331450081},{"_id":"public/sitemap.xml","hash":"beb7eb2170e7bdc70eed940bfa28b26aa6e40cd9","modified":1630331450081},{"_id":"public/about/index.html","hash":"dbe17d7ff91429c71af714e9d33664390df1b1ef","modified":1630331450081},{"_id":"public/2021/08/14/微信小程序：灵活适配不同标题栏高度的设备的方法/index.html","hash":"4c9b73b7329e0a9ebfa9ac45eaac29e99ddef08b","modified":1630331450081},{"_id":"public/archives/index.html","hash":"b1c96d510c6b9e5586cd4857959f4712092f190f","modified":1630331450081},{"_id":"public/archives/2021/index.html","hash":"b1c96d510c6b9e5586cd4857959f4712092f190f","modified":1630331450081},{"_id":"public/archives/2021/08/index.html","hash":"b1c96d510c6b9e5586cd4857959f4712092f190f","modified":1630331450081},{"_id":"public/categories/JS/index.html","hash":"d2cab8e1375a05ec7e3773d8b699de89ebb4f2e0","modified":1630331450081},{"_id":"public/categories/微信小程序/index.html","hash":"f08bfb8e0980e3f136fdd7425fbe037ef467fed2","modified":1630331450081},{"_id":"public/categories/JS/算法/index.html","hash":"af272293a24f21ab90047e4df473a75b4f5b3d9f","modified":1630331450081},{"_id":"public/tags/JS/index.html","hash":"a6d1141020e176fbfe44f0a2e931e928b89c8e10","modified":1630331450081},{"_id":"public/tags/算法/index.html","hash":"9072ab50c02e68ade47626a25d593209d32427b1","modified":1630331450081},{"_id":"public/tags/快速幂/index.html","hash":"0d5a63a34691d0989ff25cc3f637ee68c5db4fb9","modified":1630331450081},{"_id":"public/tags/大数越界/index.html","hash":"5e1db37cda7009dfadad3e2851859302326b680b","modified":1630331450081},{"_id":"public/tags/微信小程序/index.html","hash":"a5f93c9029536081aaa9528d165994fd7ea3a153","modified":1630331450081},{"_id":"public/tags/fs/index.html","hash":"52cef9f665b9b20431d1d546c31c684ef7294830","modified":1630331450081},{"_id":"public/2021/08/29/Pow-x-n-10-（快速幂-大数取模问题）/index.html","hash":"846dece71d802de810bccc70973c417d4541af5c","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/index.html","hash":"4d4c82b252465267a7ad6451bcd670237f076f28","modified":1630331450081},{"_id":"public/2021/08/18/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）/index.html","hash":"3d78edcd6561e5fd239f57caea5b74c4fdc2de29","modified":1630331450081},{"_id":"public/2021/08/16/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）/index.html","hash":"bc5c3f9e1986c8e3bb5f389ce1b06ef4a43ade62","modified":1630331450081},{"_id":"public/index.html","hash":"b9de63cab7440f733115b212e48fea9eca37d0fe","modified":1630331450081},{"_id":"public/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1630331450081},{"_id":"public/images/avatar.jpeg","hash":"7ce0557fb0cdf3d05e2e3be975d73ea0e6635df6","modified":1630331450081},{"_id":"public/images/footer-l.jpeg","hash":"f036edc5f66ffbcc34c3d855414c6ca5ef30a04b","modified":1630331450081},{"_id":"public/images/footer-r.jpeg","hash":"5c7677ac85cf8a683b91e97702b7096017006b4f","modified":1630331450081},{"_id":"public/images/post_cover.jpeg","hash":"93f216636c87dbbe635d4bb6b944851d92d84723","modified":1630331450081},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1630331450081},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg","hash":"2ad76c60d6d8f172555f45575da3bad866542aa2","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png","hash":"ebab7bc8a320818e31d5952bec8009dc6abc14d1","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png","hash":"c370ef1ff1e4458fcbf83ffe9802dfaccf193e2c","modified":1630331450081},{"_id":"public/images/cover.jpeg","hash":"186350a358c03649b83d5501ee43c90b1cc1160e","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png","hash":"4324dcf04b74152be6de70860e3e1ee7cbe34953","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare.png","hash":"710314ce886d5ca0e1c125b2f8d5197a70d4e998","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png","hash":"c8abdb84d9c33272d5b815b72cec98adf467b2ad","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png","hash":"0824bb0d2d6bb43a0028fafd26395aedb5bc2c27","modified":1630331450081},{"_id":"public/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png","hash":"bdf83f353affd7055761dd54d46f6e509aa8fe36","modified":1630331450081},{"_id":"public/css/base.css","hash":"6d884ebc4f4c1a7c750e4b871ecfff6c28b47ed0","modified":1630331450081},{"_id":"public/js/jquery.jside.menu.js","hash":"688b8b03f8590a05e35a1fbbc59f37bc36051aa1","modified":1630331450081},{"_id":"public/js/jquery.easing.min.js","hash":"af83a43279779fbc716f40ba8c5280782027540a","modified":1630331450081},{"_id":"public/css/menu/button.css","hash":"ce03713a291978281b66ce9d5738c456020a8e61","modified":1630331450081},{"_id":"public/js/local.search.js","hash":"3dd788d1e64431feb8faca7a7f175d25ed31f25a","modified":1630331450081},{"_id":"public/css/menu/menu.css","hash":"70f8a5b346f4b106eebc1c5199bc4add479da3c5","modified":1630331450081},{"_id":"public/css/page_style/page_style.css","hash":"07178b2c270eafa0c21e424663946015bfc08b0e","modified":1630331450081},{"_id":"public/css/main.css","hash":"6918851c41dabfa45fcd46fdc871ed4a08c73109","modified":1630331450081},{"_id":"public/css/main.min.css","hash":"20c32e1a93832269ab5c9ed0f9b07c6921a86bea","modified":1630331450081},{"_id":"public/2021/08/16/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）/侧滑效果.gif","hash":"3b489ac4084d6ebd5b1b3de30b7d9d429f777af4","modified":1630331450081}],"Category":[{"name":"JS","_id":"cksyp92bu00030su6ac0b51em"},{"name":"微信小程序","_id":"cksyp92c0000a0su6hfnyf7yt"},{"name":"算法","parent":"cksyp92bu00030su6ac0b51em","_id":"cksyp92c2000g0su64u9c4f9p"}],"Data":[],"Page":[{"title":"关于我","date":"2021-08-30T10:07:56.000Z","comment":true,"_content":"\n## 个人发展\n\n来自北京邮电大学2018级（2022年毕业），信息与通信工程学院。比起通信和电子更热爱coding，主攻方向是前端开发，此外对移动端（Android之类）的开发也有兴趣。目前没有考研意向，静心准备秋招中。未来意向工作城市是合肥（恋人的家乡，生活压力也没有一线城市那么大），或许有些缺乏互联网企业的土壤，可能就业优先级是大厂>国企>恰烂钱。目前期望965以下的工作时间，因为本人没有做一番事业的偏向（但是会想要获得自己的能力应得的薪酬收入）。计划在闲暇时间（拿到offer后或者工作稳定后）写一些兴趣使然的程序，或许是实用工具或游戏。有少量的绘画功底，但近期没有精进的打算。\n\n2021.7~2021.8 在纷享销客公司Paas平台部实习（大前端），工作时间10-7.5-5。工作内容是用微信小程序+[hera](https://weidian-inc.github.io/hera/#/)开发跨平台APP。\n\n感受：跨平台开发好麻烦，要同时适配微信小程序，h5, android, ios.\n<!-- 2.不知道是能者多劳还是跟对mentor很重要，邻座研究生小姐姐入职不会做小程序，工资比我每天多拿60块，然后我入职第一天配环境第二天就做需求，没日没夜做到离职，小姐姐没事干，mentor都不派活，吐了。 -->\n\n## 思想倾向\n\n圣母白左（doge），支持各种政治正确如反种族歧视、性别歧视、性倾向歧视等。支持完善动保体系（理中客派）。\n\n温和转激进派女权主义者，目前对各种流派处包容态度，对能理解女性处境的男性持接纳态度，支持在部分很不平衡的方面矫枉过正，但反对没有理由的冲突。\n\n支持国内阶级斗争，坚决支持完善劳动法的实施（作为劳动者的屁股）。\n\n## 个人兴趣\n\n最终幻想14 -和恋人结识的地方，也是非常好的游戏\n![FF14-1](https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_1.png)\n![FF14-2](https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_2.png)\n![FF14-3](https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_3.png)\n\n音乐方面：Vocaloid & 华语HipHop & 独立/日系/英伦摇滚\n\n最近在玩的游戏：荒野大镖客2，刺客信条：奥德赛、起源，火焰纹章：风花雪月。\n\n## 人生目标\n\n想要无止境地获取知识，以及在享乐中游戏人生。","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2021-08-30 18:07:56\ncomment: true\n---\n\n## 个人发展\n\n来自北京邮电大学2018级（2022年毕业），信息与通信工程学院。比起通信和电子更热爱coding，主攻方向是前端开发，此外对移动端（Android之类）的开发也有兴趣。目前没有考研意向，静心准备秋招中。未来意向工作城市是合肥（恋人的家乡，生活压力也没有一线城市那么大），或许有些缺乏互联网企业的土壤，可能就业优先级是大厂>国企>恰烂钱。目前期望965以下的工作时间，因为本人没有做一番事业的偏向（但是会想要获得自己的能力应得的薪酬收入）。计划在闲暇时间（拿到offer后或者工作稳定后）写一些兴趣使然的程序，或许是实用工具或游戏。有少量的绘画功底，但近期没有精进的打算。\n\n2021.7~2021.8 在纷享销客公司Paas平台部实习（大前端），工作时间10-7.5-5。工作内容是用微信小程序+[hera](https://weidian-inc.github.io/hera/#/)开发跨平台APP。\n\n感受：跨平台开发好麻烦，要同时适配微信小程序，h5, android, ios.\n<!-- 2.不知道是能者多劳还是跟对mentor很重要，邻座研究生小姐姐入职不会做小程序，工资比我每天多拿60块，然后我入职第一天配环境第二天就做需求，没日没夜做到离职，小姐姐没事干，mentor都不派活，吐了。 -->\n\n## 思想倾向\n\n圣母白左（doge），支持各种政治正确如反种族歧视、性别歧视、性倾向歧视等。支持完善动保体系（理中客派）。\n\n温和转激进派女权主义者，目前对各种流派处包容态度，对能理解女性处境的男性持接纳态度，支持在部分很不平衡的方面矫枉过正，但反对没有理由的冲突。\n\n支持国内阶级斗争，坚决支持完善劳动法的实施（作为劳动者的屁股）。\n\n## 个人兴趣\n\n最终幻想14 -和恋人结识的地方，也是非常好的游戏\n![FF14-1](https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_1.png)\n![FF14-2](https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_2.png)\n![FF14-3](https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_3.png)\n\n音乐方面：Vocaloid & 华语HipHop & 独立/日系/英伦摇滚\n\n最近在玩的游戏：荒野大镖客2，刺客信条：奥德赛、起源，火焰纹章：风花雪月。\n\n## 人生目标\n\n想要无止境地获取知识，以及在享乐中游戏人生。","updated":"2021-08-30T13:50:42.661Z","path":"about/index.html","comments":1,"layout":"page","_id":"cksyp92bk00000su6hu1xfy0n","content":"<h2 id=\"个人发展\"><a href=\"#个人发展\" class=\"headerlink\" title=\"个人发展\"></a>个人发展</h2><p>来自北京邮电大学2018级（2022年毕业），信息与通信工程学院。比起通信和电子更热爱coding，主攻方向是前端开发，此外对移动端（Android之类）的开发也有兴趣。目前没有考研意向，静心准备秋招中。未来意向工作城市是合肥（恋人的家乡，生活压力也没有一线城市那么大），或许有些缺乏互联网企业的土壤，可能就业优先级是大厂&gt;国企&gt;恰烂钱。目前期望965以下的工作时间，因为本人没有做一番事业的偏向（但是会想要获得自己的能力应得的薪酬收入）。计划在闲暇时间（拿到offer后或者工作稳定后）写一些兴趣使然的程序，或许是实用工具或游戏。有少量的绘画功底，但近期没有精进的打算。</p>\n<p>2021.7~2021.8 在纷享销客公司Paas平台部实习（大前端），工作时间10-7.5-5。工作内容是用微信小程序+<a href=\"https://weidian-inc.github.io/hera/#/\">hera</a>开发跨平台APP。</p>\n<p>感受：跨平台开发好麻烦，要同时适配微信小程序，h5, android, ios.</p>\n<!-- 2.不知道是能者多劳还是跟对mentor很重要，邻座研究生小姐姐入职不会做小程序，工资比我每天多拿60块，然后我入职第一天配环境第二天就做需求，没日没夜做到离职，小姐姐没事干，mentor都不派活，吐了。 -->\n\n<h2 id=\"思想倾向\"><a href=\"#思想倾向\" class=\"headerlink\" title=\"思想倾向\"></a>思想倾向</h2><p>圣母白左（doge），支持各种政治正确如反种族歧视、性别歧视、性倾向歧视等。支持完善动保体系（理中客派）。</p>\n<p>温和转激进派女权主义者，目前对各种流派处包容态度，对能理解女性处境的男性持接纳态度，支持在部分很不平衡的方面矫枉过正，但反对没有理由的冲突。</p>\n<p>支持国内阶级斗争，坚决支持完善劳动法的实施（作为劳动者的屁股）。</p>\n<h2 id=\"个人兴趣\"><a href=\"#个人兴趣\" class=\"headerlink\" title=\"个人兴趣\"></a>个人兴趣</h2><p>最终幻想14 -和恋人结识的地方，也是非常好的游戏<br><img src=\"https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_1.png\" alt=\"FF14-1\"><br><img src=\"https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_2.png\" alt=\"FF14-2\"><br><img src=\"https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_3.png\" alt=\"FF14-3\"></p>\n<p>音乐方面：Vocaloid &amp; 华语HipHop &amp; 独立/日系/英伦摇滚</p>\n<p>最近在玩的游戏：荒野大镖客2，刺客信条：奥德赛、起源，火焰纹章：风花雪月。</p>\n<h2 id=\"人生目标\"><a href=\"#人生目标\" class=\"headerlink\" title=\"人生目标\"></a>人生目标</h2><p>想要无止境地获取知识，以及在享乐中游戏人生。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"个人发展\"><a href=\"#个人发展\" class=\"headerlink\" title=\"个人发展\"></a>个人发展</h2><p>来自北京邮电大学2018级（2022年毕业），信息与通信工程学院。比起通信和电子更热爱coding，主攻方向是前端开发，此外对移动端（Android之类）的开发也有兴趣。目前没有考研意向，静心准备秋招中。未来意向工作城市是合肥（恋人的家乡，生活压力也没有一线城市那么大），或许有些缺乏互联网企业的土壤，可能就业优先级是大厂&gt;国企&gt;恰烂钱。目前期望965以下的工作时间，因为本人没有做一番事业的偏向（但是会想要获得自己的能力应得的薪酬收入）。计划在闲暇时间（拿到offer后或者工作稳定后）写一些兴趣使然的程序，或许是实用工具或游戏。有少量的绘画功底，但近期没有精进的打算。</p>\n<p>2021.7~2021.8 在纷享销客公司Paas平台部实习（大前端），工作时间10-7.5-5。工作内容是用微信小程序+<a href=\"https://weidian-inc.github.io/hera/#/\">hera</a>开发跨平台APP。</p>\n<p>感受：跨平台开发好麻烦，要同时适配微信小程序，h5, android, ios.</p>\n<!-- 2.不知道是能者多劳还是跟对mentor很重要，邻座研究生小姐姐入职不会做小程序，工资比我每天多拿60块，然后我入职第一天配环境第二天就做需求，没日没夜做到离职，小姐姐没事干，mentor都不派活，吐了。 -->\n\n<h2 id=\"思想倾向\"><a href=\"#思想倾向\" class=\"headerlink\" title=\"思想倾向\"></a>思想倾向</h2><p>圣母白左（doge），支持各种政治正确如反种族歧视、性别歧视、性倾向歧视等。支持完善动保体系（理中客派）。</p>\n<p>温和转激进派女权主义者，目前对各种流派处包容态度，对能理解女性处境的男性持接纳态度，支持在部分很不平衡的方面矫枉过正，但反对没有理由的冲突。</p>\n<p>支持国内阶级斗争，坚决支持完善劳动法的实施（作为劳动者的屁股）。</p>\n<h2 id=\"个人兴趣\"><a href=\"#个人兴趣\" class=\"headerlink\" title=\"个人兴趣\"></a>个人兴趣</h2><p>最终幻想14 -和恋人结识的地方，也是非常好的游戏<br><img src=\"https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_1.png\" alt=\"FF14-1\"><br><img src=\"https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_2.png\" alt=\"FF14-2\"><br><img src=\"https://cdn.jsdelivr.net/gh/MaryCLY/blog_cdn/source/images/ff14_3.png\" alt=\"FF14-3\"></p>\n<p>音乐方面：Vocaloid &amp; 华语HipHop &amp; 独立/日系/英伦摇滚</p>\n<p>最近在玩的游戏：荒野大镖客2，刺客信条：奥德赛、起源，火焰纹章：风花雪月。</p>\n<h2 id=\"人生目标\"><a href=\"#人生目标\" class=\"headerlink\" title=\"人生目标\"></a>人生目标</h2><p>想要无止境地获取知识，以及在享乐中游戏人生。</p>\n"}],"Post":[{"title":"JS: Union-find(quick-union + weighting + path compression + map)","date":"2021-08-20T01:52:59.000Z","comment":true,"_content":"\n## 简介\n\nUnion-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。\n\n### 用于解决的问题\n\n假定一个学校的圈子中，有A,B,C...这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。\n\n### 核心的方法需求\n\nUnion(p, q): 将点p和点q建立连接的方法。\n\nFind(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。\n\n<!-- more -->\n\n## 基本构建思路\n\n### Quick-Find\n\n这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。\n\n#### 图解\n\n![quick-find图解](qf1.png)\n\n#### Java代码\n\n![quick-find代码](qf2.png)\n\n#### 缺点\n\n如果一条很长的链被合并，可能需要大量地改变root值。\n\n### Quick-Union\n\n这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。\n\n此时使用类似链表的数据结构十分恰当。\n\n#### 图解\n\n![quick-union图解](qu1.png)\n\n#### Java代码\n\n![quick-union代码](qu2.png)\n\n#### 缺点\n\n如果有一条很长的链，查找效率会很低。\n\n### 二者比较\n\n#### 共通点\n\n不管是quick-find还是quick-union，算法中都有这样的共通点：\n\n1.每次union时会判断是否同根，如果是则直接跳过。\n\n2.在进行两个子集的union时，会连接两个子集的root。\n\n#### 时间复杂度比较\n\n![时间复杂度比较](compare.png)\n\n因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。\n\n由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。\n\n## Quick-Union算法的优化\n\n### Map\n\n因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。\n\n结构：{key: id, value: parent_id}\n\n### Weighting\n\nWeighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。\n\n#### 图解\n\n![weighting图解](weighting.png)\n\n#### 代码变动\n\n由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。\n\nmap结构变化: {key: id, value: {parent: parent_id, size: size}}\n\nunion时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身\n\n### Path Compression\n\nPath Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。\n\n#### 图解\n\n![path-compression图解](path-compression.jpg)\n\n## 最终代码\n\nquick-union + weighting + path compression + map\n\n``` javascript Union-Find.js\nconst map = new Map();\nclass Node {\n    //每个节点保存的结构\n    constructor(parent, size){\n        this.parent = parent || null;\n        this.size = size || 0;\n    }\n}\n\nfunction union(p, q){\n    if(!map.has(p)||!map.has(q)){\n        //有一个不在map里，说明是游离节点，自动设为child\n        if(!map.has(p)){\n            var child = p, parent = find(q); //path compression 父母直接设给根节点\n        } else {\n            var child = q, parent = find(p);\n        }\n        map.set(child, new Node(parent, 0));\n    } else {\n        //均存在map中，需要进行weighting的两个节点\n        const pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; //暂存两个节点的root\n        if(pr===qr){\n            //如果已经连通，不需要再连接了\n            return;\n        }\n        if(prs < qrs){\n            //把容量更小的那个设为child被合并\n            var child = pr, parent = qr;\n        } else {\n            var child = qr, parent = pr;\n        }\n        //root应该都存在map中\n        map.get(child).parent = parent;\n    }\n    if(!map.has(parent)){\n        map.set(parent, new Node(parent, map.get(child).size+1)); //map中新建一个root node，root的parent设给自己\n    } else {\n        map.get(parent).size+=map.get(child).size+1; //合并size\n    }\n};\n\nfunction find(p){\n    if(!map.has(p)){\n        return p;\n    }\n    while(map.get(p).parent!=p){\n        //如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent\n        p = map.get(p).parent;\n    }\n    return p;\n};\n\nfunction isConnected(p, q){\n    return (find(p)===find(q));\n}\n```\n\n## 时间复杂度\n\n最后贴上algorithms书中的各种方法的时间复杂度：\n\n![时间复杂度比较](compare-final.png)\n\n有weighting和path compression的quick union时间复杂度无限接近1。","source":"_posts/JS-Union-find-quick-union-weighting-path-compression-map.md","raw":"---\ntitle: 'JS: Union-find(quick-union + weighting + path compression + map)'\ndate: 2021-08-20 09:52:59\ntags: [JS, 算法]\ncategories: [JS, 算法]\ncomment: true\n---\n\n## 简介\n\nUnion-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。\n\n### 用于解决的问题\n\n假定一个学校的圈子中，有A,B,C...这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。\n\n### 核心的方法需求\n\nUnion(p, q): 将点p和点q建立连接的方法。\n\nFind(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。\n\n<!-- more -->\n\n## 基本构建思路\n\n### Quick-Find\n\n这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。\n\n#### 图解\n\n![quick-find图解](qf1.png)\n\n#### Java代码\n\n![quick-find代码](qf2.png)\n\n#### 缺点\n\n如果一条很长的链被合并，可能需要大量地改变root值。\n\n### Quick-Union\n\n这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。\n\n此时使用类似链表的数据结构十分恰当。\n\n#### 图解\n\n![quick-union图解](qu1.png)\n\n#### Java代码\n\n![quick-union代码](qu2.png)\n\n#### 缺点\n\n如果有一条很长的链，查找效率会很低。\n\n### 二者比较\n\n#### 共通点\n\n不管是quick-find还是quick-union，算法中都有这样的共通点：\n\n1.每次union时会判断是否同根，如果是则直接跳过。\n\n2.在进行两个子集的union时，会连接两个子集的root。\n\n#### 时间复杂度比较\n\n![时间复杂度比较](compare.png)\n\n因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。\n\n由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。\n\n## Quick-Union算法的优化\n\n### Map\n\n因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。\n\n结构：{key: id, value: parent_id}\n\n### Weighting\n\nWeighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。\n\n#### 图解\n\n![weighting图解](weighting.png)\n\n#### 代码变动\n\n由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。\n\nmap结构变化: {key: id, value: {parent: parent_id, size: size}}\n\nunion时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身\n\n### Path Compression\n\nPath Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。\n\n#### 图解\n\n![path-compression图解](path-compression.jpg)\n\n## 最终代码\n\nquick-union + weighting + path compression + map\n\n``` javascript Union-Find.js\nconst map = new Map();\nclass Node {\n    //每个节点保存的结构\n    constructor(parent, size){\n        this.parent = parent || null;\n        this.size = size || 0;\n    }\n}\n\nfunction union(p, q){\n    if(!map.has(p)||!map.has(q)){\n        //有一个不在map里，说明是游离节点，自动设为child\n        if(!map.has(p)){\n            var child = p, parent = find(q); //path compression 父母直接设给根节点\n        } else {\n            var child = q, parent = find(p);\n        }\n        map.set(child, new Node(parent, 0));\n    } else {\n        //均存在map中，需要进行weighting的两个节点\n        const pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; //暂存两个节点的root\n        if(pr===qr){\n            //如果已经连通，不需要再连接了\n            return;\n        }\n        if(prs < qrs){\n            //把容量更小的那个设为child被合并\n            var child = pr, parent = qr;\n        } else {\n            var child = qr, parent = pr;\n        }\n        //root应该都存在map中\n        map.get(child).parent = parent;\n    }\n    if(!map.has(parent)){\n        map.set(parent, new Node(parent, map.get(child).size+1)); //map中新建一个root node，root的parent设给自己\n    } else {\n        map.get(parent).size+=map.get(child).size+1; //合并size\n    }\n};\n\nfunction find(p){\n    if(!map.has(p)){\n        return p;\n    }\n    while(map.get(p).parent!=p){\n        //如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent\n        p = map.get(p).parent;\n    }\n    return p;\n};\n\nfunction isConnected(p, q){\n    return (find(p)===find(q));\n}\n```\n\n## 时间复杂度\n\n最后贴上algorithms书中的各种方法的时间复杂度：\n\n![时间复杂度比较](compare-final.png)\n\n有weighting和path compression的quick union时间复杂度无限接近1。","slug":"JS-Union-find-quick-union-weighting-path-compression-map","published":1,"updated":"2021-08-29T15:15:10.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksyp92bp00010su6gial8b49","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。</p>\n<h3 id=\"用于解决的问题\"><a href=\"#用于解决的问题\" class=\"headerlink\" title=\"用于解决的问题\"></a>用于解决的问题</h3><p>假定一个学校的圈子中，有A,B,C…这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。</p>\n<h3 id=\"核心的方法需求\"><a href=\"#核心的方法需求\" class=\"headerlink\" title=\"核心的方法需求\"></a>核心的方法需求</h3><p>Union(p, q): 将点p和点q建立连接的方法。</p>\n<p>Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"基本构建思路\"><a href=\"#基本构建思路\" class=\"headerlink\" title=\"基本构建思路\"></a>基本构建思路</h2><h3 id=\"Quick-Find\"><a href=\"#Quick-Find\" class=\"headerlink\" title=\"Quick-Find\"></a>Quick-Find</h3><p>这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。</p>\n<h4 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png\" alt=\"quick-find图解\"></p>\n<h4 id=\"Java代码\"><a href=\"#Java代码\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png\" alt=\"quick-find代码\"></p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果一条很长的链被合并，可能需要大量地改变root值。</p>\n<h3 id=\"Quick-Union\"><a href=\"#Quick-Union\" class=\"headerlink\" title=\"Quick-Union\"></a>Quick-Union</h3><p>这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。</p>\n<p>此时使用类似链表的数据结构十分恰当。</p>\n<h4 id=\"图解-1\"><a href=\"#图解-1\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png\" alt=\"quick-union图解\"></p>\n<h4 id=\"Java代码-1\"><a href=\"#Java代码-1\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png\" alt=\"quick-union代码\"></p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果有一条很长的链，查找效率会很低。</p>\n<h3 id=\"二者比较\"><a href=\"#二者比较\" class=\"headerlink\" title=\"二者比较\"></a>二者比较</h3><h4 id=\"共通点\"><a href=\"#共通点\" class=\"headerlink\" title=\"共通点\"></a>共通点</h4><p>不管是quick-find还是quick-union，算法中都有这样的共通点：</p>\n<p>1.每次union时会判断是否同根，如果是则直接跳过。</p>\n<p>2.在进行两个子集的union时，会连接两个子集的root。</p>\n<h4 id=\"时间复杂度比较\"><a href=\"#时间复杂度比较\" class=\"headerlink\" title=\"时间复杂度比较\"></a>时间复杂度比较</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare.png\" alt=\"时间复杂度比较\"></p>\n<p>因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。</p>\n<p>由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。</p>\n<h2 id=\"Quick-Union算法的优化\"><a href=\"#Quick-Union算法的优化\" class=\"headerlink\" title=\"Quick-Union算法的优化\"></a>Quick-Union算法的优化</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。</p>\n<p>结构：{key: id, value: parent_id}</p>\n<h3 id=\"Weighting\"><a href=\"#Weighting\" class=\"headerlink\" title=\"Weighting\"></a>Weighting</h3><p>Weighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。</p>\n<h4 id=\"图解-2\"><a href=\"#图解-2\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png\" alt=\"weighting图解\"></p>\n<h4 id=\"代码变动\"><a href=\"#代码变动\" class=\"headerlink\" title=\"代码变动\"></a>代码变动</h4><p>由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。</p>\n<p>map结构变化: {key: id, value: {parent: parent_id, size: size}}</p>\n<p>union时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身</p>\n<h3 id=\"Path-Compression\"><a href=\"#Path-Compression\" class=\"headerlink\" title=\"Path Compression\"></a>Path Compression</h3><p>Path Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。</p>\n<h4 id=\"图解-3\"><a href=\"#图解-3\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg\" alt=\"path-compression图解\"></p>\n<h2 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h2><p>quick-union + weighting + path compression + map</p>\n<figure class=\"highlight javascript\"><figcaption><span>Union-Find.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每个节点保存的结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">parent, size</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parent = parent || <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size = size || <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">union</span>(<span class=\"params\">p, q</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(p)||!map.has(q))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//有一个不在map里，说明是游离节点，自动设为child</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!map.has(p))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = p, parent = find(q); <span class=\"comment\">//path compression 父母直接设给根节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = q, parent = find(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.set(child, <span class=\"keyword\">new</span> Node(parent, <span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//均存在map中，需要进行weighting的两个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; <span class=\"comment\">//暂存两个节点的root</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pr===qr)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果已经连通，不需要再连接了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prs &lt; qrs)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//把容量更小的那个设为child被合并</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = pr, parent = qr;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = qr, parent = pr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//root应该都存在map中</span></span><br><span class=\"line\">        map.get(child).parent = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(parent))&#123;</span><br><span class=\"line\">        map.set(parent, <span class=\"keyword\">new</span> Node(parent, map.get(child).size+<span class=\"number\">1</span>)); <span class=\"comment\">//map中新建一个root node，root的parent设给自己</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        map.get(parent).size+=map.get(child).size+<span class=\"number\">1</span>; <span class=\"comment\">//合并size</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">p</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(p))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(map.get(p).parent!=p)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent</span></span><br><span class=\"line\">        p = map.get(p).parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isConnected</span>(<span class=\"params\">p, q</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (find(p)===find(q));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>最后贴上algorithms书中的各种方法的时间复杂度：</p>\n<p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png\" alt=\"时间复杂度比较\"></p>\n<p>有weighting和path compression的quick union时间复杂度无限接近1。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。</p>\n<h3 id=\"用于解决的问题\"><a href=\"#用于解决的问题\" class=\"headerlink\" title=\"用于解决的问题\"></a>用于解决的问题</h3><p>假定一个学校的圈子中，有A,B,C…这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。</p>\n<h3 id=\"核心的方法需求\"><a href=\"#核心的方法需求\" class=\"headerlink\" title=\"核心的方法需求\"></a>核心的方法需求</h3><p>Union(p, q): 将点p和点q建立连接的方法。</p>\n<p>Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。</p>","more":"<h2 id=\"基本构建思路\"><a href=\"#基本构建思路\" class=\"headerlink\" title=\"基本构建思路\"></a>基本构建思路</h2><h3 id=\"Quick-Find\"><a href=\"#Quick-Find\" class=\"headerlink\" title=\"Quick-Find\"></a>Quick-Find</h3><p>这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。</p>\n<h4 id=\"图解\"><a href=\"#图解\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png\" alt=\"quick-find图解\"></p>\n<h4 id=\"Java代码\"><a href=\"#Java代码\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png\" alt=\"quick-find代码\"></p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果一条很长的链被合并，可能需要大量地改变root值。</p>\n<h3 id=\"Quick-Union\"><a href=\"#Quick-Union\" class=\"headerlink\" title=\"Quick-Union\"></a>Quick-Union</h3><p>这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。</p>\n<p>此时使用类似链表的数据结构十分恰当。</p>\n<h4 id=\"图解-1\"><a href=\"#图解-1\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png\" alt=\"quick-union图解\"></p>\n<h4 id=\"Java代码-1\"><a href=\"#Java代码-1\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png\" alt=\"quick-union代码\"></p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>如果有一条很长的链，查找效率会很低。</p>\n<h3 id=\"二者比较\"><a href=\"#二者比较\" class=\"headerlink\" title=\"二者比较\"></a>二者比较</h3><h4 id=\"共通点\"><a href=\"#共通点\" class=\"headerlink\" title=\"共通点\"></a>共通点</h4><p>不管是quick-find还是quick-union，算法中都有这样的共通点：</p>\n<p>1.每次union时会判断是否同根，如果是则直接跳过。</p>\n<p>2.在进行两个子集的union时，会连接两个子集的root。</p>\n<h4 id=\"时间复杂度比较\"><a href=\"#时间复杂度比较\" class=\"headerlink\" title=\"时间复杂度比较\"></a>时间复杂度比较</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare.png\" alt=\"时间复杂度比较\"></p>\n<p>因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。</p>\n<p>由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。</p>\n<h2 id=\"Quick-Union算法的优化\"><a href=\"#Quick-Union算法的优化\" class=\"headerlink\" title=\"Quick-Union算法的优化\"></a>Quick-Union算法的优化</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。</p>\n<p>结构：{key: id, value: parent_id}</p>\n<h3 id=\"Weighting\"><a href=\"#Weighting\" class=\"headerlink\" title=\"Weighting\"></a>Weighting</h3><p>Weighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。</p>\n<h4 id=\"图解-2\"><a href=\"#图解-2\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png\" alt=\"weighting图解\"></p>\n<h4 id=\"代码变动\"><a href=\"#代码变动\" class=\"headerlink\" title=\"代码变动\"></a>代码变动</h4><p>由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。</p>\n<p>map结构变化: {key: id, value: {parent: parent_id, size: size}}</p>\n<p>union时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身</p>\n<h3 id=\"Path-Compression\"><a href=\"#Path-Compression\" class=\"headerlink\" title=\"Path Compression\"></a>Path Compression</h3><p>Path Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。</p>\n<h4 id=\"图解-3\"><a href=\"#图解-3\" class=\"headerlink\" title=\"图解\"></a>图解</h4><p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg\" alt=\"path-compression图解\"></p>\n<h2 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h2><p>quick-union + weighting + path compression + map</p>\n<figure class=\"highlight javascript\"><figcaption><span>Union-Find.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//每个节点保存的结构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">parent, size</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parent = parent || <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.size = size || <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">union</span>(<span class=\"params\">p, q</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(p)||!map.has(q))&#123;</span><br><span class=\"line\">        <span class=\"comment\">//有一个不在map里，说明是游离节点，自动设为child</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!map.has(p))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = p, parent = find(q); <span class=\"comment\">//path compression 父母直接设给根节点</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = q, parent = find(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        map.set(child, <span class=\"keyword\">new</span> Node(parent, <span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//均存在map中，需要进行weighting的两个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; <span class=\"comment\">//暂存两个节点的root</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pr===qr)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果已经连通，不需要再连接了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(prs &lt; qrs)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//把容量更小的那个设为child被合并</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = pr, parent = qr;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> child = qr, parent = pr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//root应该都存在map中</span></span><br><span class=\"line\">        map.get(child).parent = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(parent))&#123;</span><br><span class=\"line\">        map.set(parent, <span class=\"keyword\">new</span> Node(parent, map.get(child).size+<span class=\"number\">1</span>)); <span class=\"comment\">//map中新建一个root node，root的parent设给自己</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        map.get(parent).size+=map.get(child).size+<span class=\"number\">1</span>; <span class=\"comment\">//合并size</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">p</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!map.has(p))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(map.get(p).parent!=p)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent</span></span><br><span class=\"line\">        p = map.get(p).parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isConnected</span>(<span class=\"params\">p, q</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (find(p)===find(q));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>最后贴上algorithms书中的各种方法的时间复杂度：</p>\n<p><img src=\"/2021/08/20/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png\" alt=\"时间复杂度比较\"></p>\n<p>有weighting和path compression的quick union时间复杂度无限接近1。</p>"},{"title":"Pow(x, n)%10 （快速幂+大数取模问题）","date":"2021-08-29T15:13:10.000Z","comment":true,"_content":"\n## 题目描述\n\n### 来自：Zoom2021年秋招前端工程师笔试编程题2\n\n给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。\n\n任何数的0次方都是1.\n\n## 分析\n\n### 思路1\n\n不难发现规律： ((x%y)^n)%y = (x^n)%y\n\n<!-- more -->\n\n因此很容易想到，第一步先把题目中的底数x提取成最后一位。但如果直接用编程语言库里自带的Math.pow(x, n)，依然可能会直接得到一个很大的结果，取模依然可能不正确。因此，我们需要考虑自己实现一套幂运算，在过程中多次取最后一位，这样就会使得所有的运算都是小数取模了。\n\n快速幂公式参考[LeetCode 50. Pow(x, n) （快速幂，清晰图解）-Krahets](https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/)\n\n### 思路2\n\n根据观察不难发现，0-9为底的幂运算取最后一位是存在一个循环的。我们先求出这个循环的规律，然后判断n是在循环的第几位，即可直接得到结果。\n\n### 注意\n\n由于Javascript BigInt过于复杂，没有实现x, y为大数时的算法。\n\n## 代码\n\n```javascript 公用方法.js\nfunction mod10( num ) {\n    return parseInt(num) % 10;\n}\n```\n\n```javascript 思路1.js\nfunction lastDigitQuickPow(str1, str2) {\n    let x = mod10(str1); // x直接取最后一位\n    let n = parseInt(str2); // 可能涉及大数，转成BigInt\n    if (n === 0) {\n        return 1; // 任何数的0次方都是1\n    }\n    let res = 1;\n    for (let i = x; n; i = mod10(i * i), n = n >> 1) {\n    \t// 每次使i平方，然后n减少一位二进制位（位右移）\n        if ((n & 1) == 1) {\n            res = mod10(res * i); // 如果当前位是1，则在结果中增加\n        }\n    }\n    return res;\n}\n```\n\n```javascript 思路2.js\nfunction lastDigit(str1, str2) {\n    let x = mod10(str1); // x直接取最后一位\n    let n = parseInt(str2); // 可能涉及大数，转成BigInt\n    if (n === 0) {\n        return 1; // 任何数的0次方都是1\n    }\n    let loopCount = 0;\n    let loopNum = [x];\n    for (let i = x; true;) {\n        i = mod10(i * x); // 查找循环的下一位\n        loopCount++;\n        if (i === x) {\n            break; // 得到循环的总长度loopCount和取余对应loopNum[]\n        } else {\n            loopNum.push(i);\n        }\n    }\n    let resMod = (n - 1) % loopCount; // 获取循环中的余数（左移一位）\n    return loopNum[resMod];\n}\n```","source":"_posts/Pow-x-n-10-（快速幂-大数取模问题）.md","raw":"---\ntitle: 'Pow(x, n)%10 （快速幂+大数取模问题）'\ndate: 2021-08-29 23:13:10\ntags: [JS, 算法, 快速幂, 大数越界]\ncategories: [JS, 算法]\ncomment: true\n---\n\n## 题目描述\n\n### 来自：Zoom2021年秋招前端工程师笔试编程题2\n\n给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。\n\n任何数的0次方都是1.\n\n## 分析\n\n### 思路1\n\n不难发现规律： ((x%y)^n)%y = (x^n)%y\n\n<!-- more -->\n\n因此很容易想到，第一步先把题目中的底数x提取成最后一位。但如果直接用编程语言库里自带的Math.pow(x, n)，依然可能会直接得到一个很大的结果，取模依然可能不正确。因此，我们需要考虑自己实现一套幂运算，在过程中多次取最后一位，这样就会使得所有的运算都是小数取模了。\n\n快速幂公式参考[LeetCode 50. Pow(x, n) （快速幂，清晰图解）-Krahets](https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/)\n\n### 思路2\n\n根据观察不难发现，0-9为底的幂运算取最后一位是存在一个循环的。我们先求出这个循环的规律，然后判断n是在循环的第几位，即可直接得到结果。\n\n### 注意\n\n由于Javascript BigInt过于复杂，没有实现x, y为大数时的算法。\n\n## 代码\n\n```javascript 公用方法.js\nfunction mod10( num ) {\n    return parseInt(num) % 10;\n}\n```\n\n```javascript 思路1.js\nfunction lastDigitQuickPow(str1, str2) {\n    let x = mod10(str1); // x直接取最后一位\n    let n = parseInt(str2); // 可能涉及大数，转成BigInt\n    if (n === 0) {\n        return 1; // 任何数的0次方都是1\n    }\n    let res = 1;\n    for (let i = x; n; i = mod10(i * i), n = n >> 1) {\n    \t// 每次使i平方，然后n减少一位二进制位（位右移）\n        if ((n & 1) == 1) {\n            res = mod10(res * i); // 如果当前位是1，则在结果中增加\n        }\n    }\n    return res;\n}\n```\n\n```javascript 思路2.js\nfunction lastDigit(str1, str2) {\n    let x = mod10(str1); // x直接取最后一位\n    let n = parseInt(str2); // 可能涉及大数，转成BigInt\n    if (n === 0) {\n        return 1; // 任何数的0次方都是1\n    }\n    let loopCount = 0;\n    let loopNum = [x];\n    for (let i = x; true;) {\n        i = mod10(i * x); // 查找循环的下一位\n        loopCount++;\n        if (i === x) {\n            break; // 得到循环的总长度loopCount和取余对应loopNum[]\n        } else {\n            loopNum.push(i);\n        }\n    }\n    let resMod = (n - 1) % loopCount; // 获取循环中的余数（左移一位）\n    return loopNum[resMod];\n}\n```","slug":"Pow-x-n-10-（快速幂-大数取模问题）","published":1,"updated":"2021-08-30T09:59:45.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksyp92bs00020su642444fco","content":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><h3 id=\"来自：Zoom2021年秋招前端工程师笔试编程题2\"><a href=\"#来自：Zoom2021年秋招前端工程师笔试编程题2\" class=\"headerlink\" title=\"来自：Zoom2021年秋招前端工程师笔试编程题2\"></a>来自：Zoom2021年秋招前端工程师笔试编程题2</h3><p>给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。</p>\n<p>任何数的0次方都是1.</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><h3 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h3><p>不难发现规律： ((x%y)^n)%y = (x^n)%y</p>\n<span id=\"more\"></span>\n\n<p>因此很容易想到，第一步先把题目中的底数x提取成最后一位。但如果直接用编程语言库里自带的Math.pow(x, n)，依然可能会直接得到一个很大的结果，取模依然可能不正确。因此，我们需要考虑自己实现一套幂运算，在过程中多次取最后一位，这样就会使得所有的运算都是小数取模了。</p>\n<p>快速幂公式参考<a href=\"https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/\">LeetCode 50. Pow(x, n) （快速幂，清晰图解）-Krahets</a></p>\n<h3 id=\"思路2\"><a href=\"#思路2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h3><p>根据观察不难发现，0-9为底的幂运算取最后一位是存在一个循环的。我们先求出这个循环的规律，然后判断n是在循环的第几位，即可直接得到结果。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>由于Javascript BigInt过于复杂，没有实现x, y为大数时的算法。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight javascript\"><figcaption><span>公用方法.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mod10</span>(<span class=\"params\"> num </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(num) % <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>思路1.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lastDigitQuickPow</span>(<span class=\"params\">str1, str2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = mod10(str1); <span class=\"comment\">// x直接取最后一位</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"built_in\">parseInt</span>(str2); <span class=\"comment\">// 可能涉及大数，转成BigInt</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// 任何数的0次方都是1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = x; n; i = mod10(i * i), n = n &gt;&gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 每次使i平方，然后n减少一位二进制位（位右移）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res = mod10(res * i); <span class=\"comment\">// 如果当前位是1，则在结果中增加</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>思路2.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lastDigit</span>(<span class=\"params\">str1, str2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = mod10(str1); <span class=\"comment\">// x直接取最后一位</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"built_in\">parseInt</span>(str2); <span class=\"comment\">// 可能涉及大数，转成BigInt</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// 任何数的0次方都是1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> loopCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> loopNum = [x];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = x; <span class=\"literal\">true</span>;) &#123;</span><br><span class=\"line\">        i = mod10(i * x); <span class=\"comment\">// 查找循环的下一位</span></span><br><span class=\"line\">        loopCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i === x) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>; <span class=\"comment\">// 得到循环的总长度loopCount和取余对应loopNum[]</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            loopNum.push(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> resMod = (n - <span class=\"number\">1</span>) % loopCount; <span class=\"comment\">// 获取循环中的余数（左移一位）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loopNum[resMod];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><h3 id=\"来自：Zoom2021年秋招前端工程师笔试编程题2\"><a href=\"#来自：Zoom2021年秋招前端工程师笔试编程题2\" class=\"headerlink\" title=\"来自：Zoom2021年秋招前端工程师笔试编程题2\"></a>来自：Zoom2021年秋招前端工程师笔试编程题2</h3><p>给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。</p>\n<p>任何数的0次方都是1.</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><h3 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h3><p>不难发现规律： ((x%y)^n)%y = (x^n)%y</p>","more":"<p>因此很容易想到，第一步先把题目中的底数x提取成最后一位。但如果直接用编程语言库里自带的Math.pow(x, n)，依然可能会直接得到一个很大的结果，取模依然可能不正确。因此，我们需要考虑自己实现一套幂运算，在过程中多次取最后一位，这样就会使得所有的运算都是小数取模了。</p>\n<p>快速幂公式参考<a href=\"https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/\">LeetCode 50. Pow(x, n) （快速幂，清晰图解）-Krahets</a></p>\n<h3 id=\"思路2\"><a href=\"#思路2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h3><p>根据观察不难发现，0-9为底的幂运算取最后一位是存在一个循环的。我们先求出这个循环的规律，然后判断n是在循环的第几位，即可直接得到结果。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>由于Javascript BigInt过于复杂，没有实现x, y为大数时的算法。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight javascript\"><figcaption><span>公用方法.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mod10</span>(<span class=\"params\"> num </span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(num) % <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>思路1.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lastDigitQuickPow</span>(<span class=\"params\">str1, str2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = mod10(str1); <span class=\"comment\">// x直接取最后一位</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"built_in\">parseInt</span>(str2); <span class=\"comment\">// 可能涉及大数，转成BigInt</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// 任何数的0次方都是1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = x; n; i = mod10(i * i), n = n &gt;&gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 每次使i平方，然后n减少一位二进制位（位右移）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            res = mod10(res * i); <span class=\"comment\">// 如果当前位是1，则在结果中增加</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>思路2.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lastDigit</span>(<span class=\"params\">str1, str2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = mod10(str1); <span class=\"comment\">// x直接取最后一位</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n = <span class=\"built_in\">parseInt</span>(str2); <span class=\"comment\">// 可能涉及大数，转成BigInt</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">// 任何数的0次方都是1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> loopCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> loopNum = [x];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = x; <span class=\"literal\">true</span>;) &#123;</span><br><span class=\"line\">        i = mod10(i * x); <span class=\"comment\">// 查找循环的下一位</span></span><br><span class=\"line\">        loopCount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i === x) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>; <span class=\"comment\">// 得到循环的总长度loopCount和取余对应loopNum[]</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            loopNum.push(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> resMod = (n - <span class=\"number\">1</span>) % loopCount; <span class=\"comment\">// 获取循环中的余数（左移一位）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loopNum[resMod];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）","date":"2021-08-16T03:14:19.000Z","comment":true,"_content":"\n## 工程需求\n\n开发的应用：用微信小程序经由hera生成的跨平台移动端APP。\n\n在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。\n\n## 方案参考\n\n由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。\n\n参考链接：https://blog.csdn.net/LiaoFengJi/article/details/105218664\n\n<!-- more -->\n\n## 提炼代码如下：\n\n```wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\">\n\t<!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 -->\n\t<view class=\"item-left\" data-index=\"{{index}}\">\n\t\t<!-- 每条要显示的内容 -->\n\t</view>\n\t<view class=\"item-right\">\n\t\t<view class=\"btn-right\" bindtap=\"setTopItem\">置顶</view>\n\t\t<view class=\"btn-right\" bindtap=\"deleteItem\">删除</view>\n\t</view>\n</view>\n```\n\n```wxss index.wxss\n.item {\n  display: flex;\n}\n\n/* 内容部分 */\n.item-left {\n  width: 100%;\n  /*关键代码*/\n  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  /*关键代码*/\n}\n\n/* 按钮部分 */\n.item-right {\n  height: 100%;\n  width: 400rpx; /*根据需要调整*/\n  display: flex;\n  flex-direction: row;\n  /*关键代码*/\n  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/\n  /*关键代码*/\n}\n\n.btn-right {\n  width: 50%; /*这里根据自己的需要划成了两半*/\n}\n\n/* 向左滑动 */\n.touch-move-active .item-left,\n.touch-move-active .item-right {\n  /*关键代码*/\n  -webkit-transform: translateX(0);\n  transform: translateX(0);\n  /*关键代码*/\n}\n```\n\n```javascript index.js\n/* Page */\n  data: {\n    dataList: [/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/],\n    startX: 0,// 设置开始的位置X\n    startY: 0,// 设置开始的位置Y\n  },\n\n  // 开始滑动\n  touchStart(e) {\n    let dataList = this.data.dataList;\n    dataList.forEach(item => {\n    // 让原先滑动的块隐藏\n      if (item.isTouchMove) {\n        item.isTouchMove = !item.isTouchMove;\n      }\n    });\n    this.setData({\n      dataList: dataList,\n    });\n    // 初始化开始位置\n    this.data.startX = e.touches[0].clientX;\n    this.data.startY = e.touches[0].clientY;\n\t// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData\n\t},\n  // 滑动的过程\n  touchMove(e) {\n    let moveX = e.changedTouches[0].clientX,\n      moveY = e.changedTouches[0].clientY,\n      curIndex = e.currentTarget.dataset.index, \n      //注意，wxml里面一定要设置data-index=\"{{index}}\",这样e.currentTarget.dataset中才会传index的值\n      dataList = this.data.dataList,\n      // 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动\n      angle = this.angle(\n        { X: this.data.startX,\n\t    Y: this.data.startY\n\t    }, { X: moveX,\n\t    Y: moveY\n\t    }\n\t  );\n\n    dataList.forEach((item, index) => {\n    // 这里相对参考代码做了精炼\n\t// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑\n      if (curIndex === index && angle < 30 && moveX < this.data.startX) {\n        item.isTouchMove = true;\n      } else {\n      \titem.isTouchMove = false; //否则右滑\n      }\n    });\n\n    this.setData({\n      dataList\n    });\n  },\n\n  /**\n   * 计算滑动角度\n   * @param {Object} start 起点坐标\n   * @param {Object} end 终点坐标\n   */\n  angle: function (start, end) {\n    var _X = end.X - start.X,\n      _Y = end.Y - start.Y\n    //返回角度 /Math.atan()返回数字的反正切值\n    return 360 * Math.atan(_Y / _X) / (2 * Math.PI);\n  },\n\n  // 删除\n  deleteItem(e) {\n  \t/* 这里是具体删除item的方法 */\n  }\n```\n\n## 实现效果\n\n![侧滑效果](侧滑效果.gif)\n\n## 结语\n\n本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。\n\n实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。","source":"_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）.md","raw":"---\ntitle: 关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）\ndate: 2021-08-16 11:14:19\ntags: [微信小程序,fs]\ncategories: 微信小程序\ncomment: true\n---\n\n## 工程需求\n\n开发的应用：用微信小程序经由hera生成的跨平台移动端APP。\n\n在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。\n\n## 方案参考\n\n由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。\n\n参考链接：https://blog.csdn.net/LiaoFengJi/article/details/105218664\n\n<!-- more -->\n\n## 提炼代码如下：\n\n```wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"touchStart\" bindtouchmove=\"touchMove\">\n\t<!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 -->\n\t<view class=\"item-left\" data-index=\"{{index}}\">\n\t\t<!-- 每条要显示的内容 -->\n\t</view>\n\t<view class=\"item-right\">\n\t\t<view class=\"btn-right\" bindtap=\"setTopItem\">置顶</view>\n\t\t<view class=\"btn-right\" bindtap=\"deleteItem\">删除</view>\n\t</view>\n</view>\n```\n\n```wxss index.wxss\n.item {\n  display: flex;\n}\n\n/* 内容部分 */\n.item-left {\n  width: 100%;\n  /*关键代码*/\n  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/\n  /*关键代码*/\n}\n\n/* 按钮部分 */\n.item-right {\n  height: 100%;\n  width: 400rpx; /*根据需要调整*/\n  display: flex;\n  flex-direction: row;\n  /*关键代码*/\n  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/\n  -webkit-transition: all 0.4s;\n  transition: all 0.4s;\n  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/\n  /*关键代码*/\n}\n\n.btn-right {\n  width: 50%; /*这里根据自己的需要划成了两半*/\n}\n\n/* 向左滑动 */\n.touch-move-active .item-left,\n.touch-move-active .item-right {\n  /*关键代码*/\n  -webkit-transform: translateX(0);\n  transform: translateX(0);\n  /*关键代码*/\n}\n```\n\n```javascript index.js\n/* Page */\n  data: {\n    dataList: [/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/],\n    startX: 0,// 设置开始的位置X\n    startY: 0,// 设置开始的位置Y\n  },\n\n  // 开始滑动\n  touchStart(e) {\n    let dataList = this.data.dataList;\n    dataList.forEach(item => {\n    // 让原先滑动的块隐藏\n      if (item.isTouchMove) {\n        item.isTouchMove = !item.isTouchMove;\n      }\n    });\n    this.setData({\n      dataList: dataList,\n    });\n    // 初始化开始位置\n    this.data.startX = e.touches[0].clientX;\n    this.data.startY = e.touches[0].clientY;\n\t// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData\n\t},\n  // 滑动的过程\n  touchMove(e) {\n    let moveX = e.changedTouches[0].clientX,\n      moveY = e.changedTouches[0].clientY,\n      curIndex = e.currentTarget.dataset.index, \n      //注意，wxml里面一定要设置data-index=\"{{index}}\",这样e.currentTarget.dataset中才会传index的值\n      dataList = this.data.dataList,\n      // 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动\n      angle = this.angle(\n        { X: this.data.startX,\n\t    Y: this.data.startY\n\t    }, { X: moveX,\n\t    Y: moveY\n\t    }\n\t  );\n\n    dataList.forEach((item, index) => {\n    // 这里相对参考代码做了精炼\n\t// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑\n      if (curIndex === index && angle < 30 && moveX < this.data.startX) {\n        item.isTouchMove = true;\n      } else {\n      \titem.isTouchMove = false; //否则右滑\n      }\n    });\n\n    this.setData({\n      dataList\n    });\n  },\n\n  /**\n   * 计算滑动角度\n   * @param {Object} start 起点坐标\n   * @param {Object} end 终点坐标\n   */\n  angle: function (start, end) {\n    var _X = end.X - start.X,\n      _Y = end.Y - start.Y\n    //返回角度 /Math.atan()返回数字的反正切值\n    return 360 * Math.atan(_Y / _X) / (2 * Math.PI);\n  },\n\n  // 删除\n  deleteItem(e) {\n  \t/* 这里是具体删除item的方法 */\n  }\n```\n\n## 实现效果\n\n![侧滑效果](侧滑效果.gif)\n\n## 结语\n\n本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。\n\n实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。","slug":"关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）","published":1,"updated":"2021-08-20T09:51:39.894Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksyp92bv00050su6249a54co","content":"<h2 id=\"工程需求\"><a href=\"#工程需求\" class=\"headerlink\" title=\"工程需求\"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端APP。</p>\n<p>在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。</p>\n<h2 id=\"方案参考\"><a href=\"#方案参考\" class=\"headerlink\" title=\"方案参考\"></a>方案参考</h2><p>由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。</p>\n<p>参考链接：<a href=\"https://blog.csdn.net/LiaoFengJi/article/details/105218664\">https://blog.csdn.net/LiaoFengJi/article/details/105218664</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"提炼代码如下：\"><a href=\"#提炼代码如下：\" class=\"headerlink\" title=\"提炼代码如下：\"></a>提炼代码如下：</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;touchStart&quot; bindtouchmove=&quot;touchMove&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 --&gt;</span><br><span class=\"line\">\t&lt;view class=&quot;item-left&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">\t\t&lt;!-- 每条要显示的内容 --&gt;</span><br><span class=\"line\">\t&lt;/view&gt;</span><br><span class=\"line\">\t&lt;view class=&quot;item-right&quot;&gt;</span><br><span class=\"line\">\t\t&lt;view class=&quot;btn-right&quot; bindtap=&quot;setTopItem&quot;&gt;置顶&lt;/view&gt;</span><br><span class=\"line\">\t\t&lt;view class=&quot;btn-right&quot; bindtap=&quot;deleteItem&quot;&gt;删除&lt;/view&gt;</span><br><span class=\"line\">\t&lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxss</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 内容部分 */</span><br><span class=\"line\">.item-left &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  -webkit-transition: all 0.4s;</span><br><span class=\"line\">  transition: all 0.4s;</span><br><span class=\"line\">  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 按钮部分 */</span><br><span class=\"line\">.item-right &#123;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  width: 400rpx; /*根据需要调整*/</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: row;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class=\"line\">  -webkit-transition: all 0.4s;</span><br><span class=\"line\">  transition: all 0.4s;</span><br><span class=\"line\">  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.btn-right &#123;</span><br><span class=\"line\">  width: 50%; /*这里根据自己的需要划成了两半*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 向左滑动 */</span><br><span class=\"line\">.touch-move-active .item-left,</span><br><span class=\"line\">.touch-move-active .item-right &#123;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  -webkit-transform: translateX(0);</span><br><span class=\"line\">  transform: translateX(0);</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Page */</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">dataList</span>: [<span class=\"comment\">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class=\"line\">    <span class=\"attr\">startX</span>: <span class=\"number\">0</span>,<span class=\"comment\">// 设置开始的位置X</span></span><br><span class=\"line\">    <span class=\"attr\">startY</span>: <span class=\"number\">0</span>,<span class=\"comment\">// 设置开始的位置Y</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开始滑动</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchStart</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataList = <span class=\"built_in\">this</span>.data.dataList;</span><br><span class=\"line\">    dataList.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 让原先滑动的块隐藏</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item.isTouchMove) &#123;</span><br><span class=\"line\">        item.isTouchMove = !item.isTouchMove;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化开始位置</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startX = e.touches[<span class=\"number\">0</span>].clientX;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startY = e.touches[<span class=\"number\">0</span>].clientY;</span><br><span class=\"line\">\t<span class=\"comment\">// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 滑动的过程</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchMove</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> moveX = e.changedTouches[<span class=\"number\">0</span>].clientX,</span><br><span class=\"line\">      moveY = e.changedTouches[<span class=\"number\">0</span>].clientY,</span><br><span class=\"line\">      curIndex = e.currentTarget.dataset.index, </span><br><span class=\"line\">      <span class=\"comment\">//注意，wxml里面一定要设置data-index=&quot;&#123;&#123;index&#125;&#125;&quot;,这样e.currentTarget.dataset中才会传index的值</span></span><br><span class=\"line\">      dataList = <span class=\"built_in\">this</span>.data.dataList,</span><br><span class=\"line\">      <span class=\"comment\">// 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动</span></span><br><span class=\"line\">      angle = <span class=\"built_in\">this</span>.angle(</span><br><span class=\"line\">        &#123; <span class=\"attr\">X</span>: <span class=\"built_in\">this</span>.data.startX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: <span class=\"built_in\">this</span>.data.startY</span><br><span class=\"line\">\t    &#125;, &#123; <span class=\"attr\">X</span>: moveX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: moveY</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  );</span><br><span class=\"line\"></span><br><span class=\"line\">    dataList.forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里相对参考代码做了精炼</span></span><br><span class=\"line\">\t<span class=\"comment\">// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curIndex === index &amp;&amp; angle &lt; <span class=\"number\">30</span> &amp;&amp; moveX &lt; <span class=\"built_in\">this</span>.data.startX) &#123;</span><br><span class=\"line\">        item.isTouchMove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \titem.isTouchMove = <span class=\"literal\">false</span>; <span class=\"comment\">//否则右滑</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      dataList</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 计算滑动角度</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>start 起点坐标</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>end 终点坐标</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"attr\">angle</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _X = end.X - start.X,</span><br><span class=\"line\">      _Y = end.Y - start.Y</span><br><span class=\"line\">    <span class=\"comment\">//返回角度 /Math.atan()返回数字的反正切值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">360</span> * <span class=\"built_in\">Math</span>.atan(_Y / _X) / (<span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 删除</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">deleteItem</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">/* 这里是具体删除item的方法 */</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p><img src=\"/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/%E4%BE%A7%E6%BB%91%E6%95%88%E6%9E%9C.gif\" alt=\"侧滑效果\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。</p>\n<p>实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"工程需求\"><a href=\"#工程需求\" class=\"headerlink\" title=\"工程需求\"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端APP。</p>\n<p>在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。</p>\n<h2 id=\"方案参考\"><a href=\"#方案参考\" class=\"headerlink\" title=\"方案参考\"></a>方案参考</h2><p>由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。</p>\n<p>参考链接：<a href=\"https://blog.csdn.net/LiaoFengJi/article/details/105218664\">https://blog.csdn.net/LiaoFengJi/article/details/105218664</a></p>","more":"<h2 id=\"提炼代码如下：\"><a href=\"#提炼代码如下：\" class=\"headerlink\" title=\"提炼代码如下：\"></a>提炼代码如下：</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;touchStart&quot; bindtouchmove=&quot;touchMove&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 --&gt;</span><br><span class=\"line\">\t&lt;view class=&quot;item-left&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">\t\t&lt;!-- 每条要显示的内容 --&gt;</span><br><span class=\"line\">\t&lt;/view&gt;</span><br><span class=\"line\">\t&lt;view class=&quot;item-right&quot;&gt;</span><br><span class=\"line\">\t\t&lt;view class=&quot;btn-right&quot; bindtap=&quot;setTopItem&quot;&gt;置顶&lt;/view&gt;</span><br><span class=\"line\">\t\t&lt;view class=&quot;btn-right&quot; bindtap=&quot;deleteItem&quot;&gt;删除&lt;/view&gt;</span><br><span class=\"line\">\t&lt;/view&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxss</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.item &#123;</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 内容部分 */</span><br><span class=\"line\">.item-left &#123;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  -webkit-transition: all 0.4s;</span><br><span class=\"line\">  transition: all 0.4s;</span><br><span class=\"line\">  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 按钮部分 */</span><br><span class=\"line\">.item-right &#123;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">  width: 400rpx; /*根据需要调整*/</span><br><span class=\"line\">  display: flex;</span><br><span class=\"line\">  flex-direction: row;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class=\"line\">  -webkit-transition: all 0.4s;</span><br><span class=\"line\">  transition: all 0.4s;</span><br><span class=\"line\">  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">.btn-right &#123;</span><br><span class=\"line\">  width: 50%; /*这里根据自己的需要划成了两半*/</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/* 向左滑动 */</span><br><span class=\"line\">.touch-move-active .item-left,</span><br><span class=\"line\">.touch-move-active .item-right &#123;</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">  -webkit-transform: translateX(0);</span><br><span class=\"line\">  transform: translateX(0);</span><br><span class=\"line\">  /*关键代码*/</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Page */</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">dataList</span>: [<span class=\"comment\">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class=\"line\">    <span class=\"attr\">startX</span>: <span class=\"number\">0</span>,<span class=\"comment\">// 设置开始的位置X</span></span><br><span class=\"line\">    <span class=\"attr\">startY</span>: <span class=\"number\">0</span>,<span class=\"comment\">// 设置开始的位置Y</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 开始滑动</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchStart</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataList = <span class=\"built_in\">this</span>.data.dataList;</span><br><span class=\"line\">    dataList.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 让原先滑动的块隐藏</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item.isTouchMove) &#123;</span><br><span class=\"line\">        item.isTouchMove = !item.isTouchMove;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">// 初始化开始位置</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startX = e.touches[<span class=\"number\">0</span>].clientX;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startY = e.touches[<span class=\"number\">0</span>].clientY;</span><br><span class=\"line\">\t<span class=\"comment\">// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 滑动的过程</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchMove</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> moveX = e.changedTouches[<span class=\"number\">0</span>].clientX,</span><br><span class=\"line\">      moveY = e.changedTouches[<span class=\"number\">0</span>].clientY,</span><br><span class=\"line\">      curIndex = e.currentTarget.dataset.index, </span><br><span class=\"line\">      <span class=\"comment\">//注意，wxml里面一定要设置data-index=&quot;&#123;&#123;index&#125;&#125;&quot;,这样e.currentTarget.dataset中才会传index的值</span></span><br><span class=\"line\">      dataList = <span class=\"built_in\">this</span>.data.dataList,</span><br><span class=\"line\">      <span class=\"comment\">// 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动</span></span><br><span class=\"line\">      angle = <span class=\"built_in\">this</span>.angle(</span><br><span class=\"line\">        &#123; <span class=\"attr\">X</span>: <span class=\"built_in\">this</span>.data.startX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: <span class=\"built_in\">this</span>.data.startY</span><br><span class=\"line\">\t    &#125;, &#123; <span class=\"attr\">X</span>: moveX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: moveY</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  );</span><br><span class=\"line\"></span><br><span class=\"line\">    dataList.forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里相对参考代码做了精炼</span></span><br><span class=\"line\">\t<span class=\"comment\">// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curIndex === index &amp;&amp; angle &lt; <span class=\"number\">30</span> &amp;&amp; moveX &lt; <span class=\"built_in\">this</span>.data.startX) &#123;</span><br><span class=\"line\">        item.isTouchMove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \titem.isTouchMove = <span class=\"literal\">false</span>; <span class=\"comment\">//否则右滑</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      dataList</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 计算滑动角度</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>start 起点坐标</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> </span>end 终点坐标</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"attr\">angle</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _X = end.X - start.X,</span><br><span class=\"line\">      _Y = end.Y - start.Y</span><br><span class=\"line\">    <span class=\"comment\">//返回角度 /Math.atan()返回数字的反正切值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">360</span> * <span class=\"built_in\">Math</span>.atan(_Y / _X) / (<span class=\"number\">2</span> * <span class=\"built_in\">Math</span>.PI);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 删除</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">deleteItem</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">/* 这里是具体删除item的方法 */</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实现效果\"><a href=\"#实现效果\" class=\"headerlink\" title=\"实现效果\"></a>实现效果</h2><p><img src=\"/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/%E4%BE%A7%E6%BB%91%E6%95%88%E6%9E%9C.gif\" alt=\"侧滑效果\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。</p>\n<p>实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。</p>"},{"title":"关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）","date":"2021-08-18T08:35:47.000Z","comment":true,"_content":"\n上一章内容：[关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）](/2021/08/16/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）)\n\n原代码不再贴出。\n\n## 新的工程需求\n\n上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：\n\n不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。\n\n## 初步想法：阻止手势穿透\n\n微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？\n\n<!-- more -->\n\n## 尝试：将bind换成catch\n\n``` wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"touchStart\" catchtouchmove=\"touchMove\">\n\t<!-- 内容 -->\n</view>\n```\n\n可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。\n\n## 尝试：使bind和catch的事件根据isTouchMove进行变化\n\n``` wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\" \n    bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n\t<!-- 内容 -->\n</view>\n```\n\n但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。\n\n## 尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\n\n``` wxml index.wxml\n<block wx:for=\"{{dataList}}\" data-index=\"{{index}}\">\n    <!-- 一个是没有被打开菜单的（支持上下滑动和返回） -->\n    <view wx:if=\"{{!item.isTouchMove}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n        <!-- 内容 -->\n    </view>\n    <!-- 被打开菜单的（阻止上下滑动和返回） -->\n    <view wx:else class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\">\n        <!-- 内容 -->\n    </view>\n</block>\n``` \n\n效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。\n\n## 最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\n\n绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。\n\n思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。\n\n注意：css中，动画设定是0.4s，延时应当适当小于这个值。\n\n``` wxml index.wxml\n<block wx:for=\"{{dataList}}\" data-index=\"{{index}}\">\n    <!-- 一个是没有被打开菜单的（支持上下滑动和返回） -->\n    <view wx:if=\"{{index!==hidden}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n        <!-- 内容 -->\n    </view>\n    <!-- 被打开菜单的（阻止上下滑动和返回） -->\n    <view wx:else class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\">\n        <!-- 内容 -->\n    </view>\n</block>\n``` \n\n```javascript index.js\n/* Page */\n  data: {\n    dataList: [/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/],\n    startX: 0,\n    startY: 0,\n    hidden: null,//标记被隐藏的块index\n  },\n\n\n  touchStart(e) {\n    let dataList = this.data.dataList;\n    dataList.forEach(item => {\n      if (item.isTouchMove) {\n        item.isTouchMove = !item.isTouchMove;\n      }\n    });\n    this.setData({\n      dataList: dataList,\n    });\n\n    this.data.hidden = null; //先把hidden置null, 但不渲染\n\n    this.data.startX = e.touches[0].clientX;\n    this.data.startY = e.touches[0].clientY;\n  },\n  touchMove(e) {\n    let moveX = e.changedTouches[0].clientX,\n      moveY = e.changedTouches[0].clientY,\n      curIndex = e.currentTarget.dataset.index, \n      dataList = this.data.dataList,\n      angle = this.angle(\n        { X: this.data.startX,\n\t    Y: this.data.startY\n\t    }, { X: moveX,\n\t    Y: moveY\n\t    }\n\t  );\n    const that = this; //用于在forEach函数里访问data\n    dataList.forEach((item, index) => {\n      if (curIndex === index && angle < 30 && moveX < this.data.startX) {\n        item.isTouchMove = true;\n        that.data.hidden = index;//如果有块被滑动，将hidden设为此块，否则就会保持在null\n      } else {\n      \titem.isTouchMove = false; \n      }\n    });\n\n    this.setData({\n      dataList: dataList,\n    });\n\n    setTimeOut({\n      that.setData({\n        hidden: that.data.hidden //0.3s后渲染hidden来替换组件，此时动画基本放完了\n      })\n    }, 300);\n  },\n```\n\n经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。\n\n## 总结\n\n至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。","source":"_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）.md","raw":"---\ntitle: 关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）\ndate: 2021-08-18 16:35:47\ntags: [微信小程序,fs]\ncategories: 微信小程序\ncomment: true\n---\n\n上一章内容：[关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）](/2021/08/16/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）)\n\n原代码不再贴出。\n\n## 新的工程需求\n\n上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：\n\n不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。\n\n## 初步想法：阻止手势穿透\n\n微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？\n\n<!-- more -->\n\n## 尝试：将bind换成catch\n\n``` wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"touchStart\" catchtouchmove=\"touchMove\">\n\t<!-- 内容 -->\n</view>\n```\n\n可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。\n\n## 尝试：使bind和catch的事件根据isTouchMove进行变化\n\n``` wxml index.wxml\n<view wx:for=\"{{dataList}}\" data-index=\"{{index}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\" \n    bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n\t<!-- 内容 -->\n</view>\n```\n\n但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。\n\n## 尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\n\n``` wxml index.wxml\n<block wx:for=\"{{dataList}}\" data-index=\"{{index}}\">\n    <!-- 一个是没有被打开菜单的（支持上下滑动和返回） -->\n    <view wx:if=\"{{!item.isTouchMove}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n        <!-- 内容 -->\n    </view>\n    <!-- 被打开菜单的（阻止上下滑动和返回） -->\n    <view wx:else class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\">\n        <!-- 内容 -->\n    </view>\n</block>\n``` \n\n效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。\n\n## 最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\n\n绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。\n\n思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。\n\n注意：css中，动画设定是0.4s，延时应当适当小于这个值。\n\n``` wxml index.wxml\n<block wx:for=\"{{dataList}}\" data-index=\"{{index}}\">\n    <!-- 一个是没有被打开菜单的（支持上下滑动和返回） -->\n    <view wx:if=\"{{index!==hidden}}\" class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" bindtouchstart=\"{{item.isTouchMove ? '' : 'touchstart'}}\" bindtouchmove=\"{{item.isTouchMove ? '' : 'touchmove'}}\">\n        <!-- 内容 -->\n    </view>\n    <!-- 被打开菜单的（阻止上下滑动和返回） -->\n    <view wx:else class=\"item {{item.isTouchMove ? 'touch-move-active' : ''}}\" catchtouchstart=\"{{item.isTouchMove ? 'touchstart' : ''}}\" catchtouchmove=\"{{item.isTouchMove ? 'touchmove' : ''}}\">\n        <!-- 内容 -->\n    </view>\n</block>\n``` \n\n```javascript index.js\n/* Page */\n  data: {\n    dataList: [/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/],\n    startX: 0,\n    startY: 0,\n    hidden: null,//标记被隐藏的块index\n  },\n\n\n  touchStart(e) {\n    let dataList = this.data.dataList;\n    dataList.forEach(item => {\n      if (item.isTouchMove) {\n        item.isTouchMove = !item.isTouchMove;\n      }\n    });\n    this.setData({\n      dataList: dataList,\n    });\n\n    this.data.hidden = null; //先把hidden置null, 但不渲染\n\n    this.data.startX = e.touches[0].clientX;\n    this.data.startY = e.touches[0].clientY;\n  },\n  touchMove(e) {\n    let moveX = e.changedTouches[0].clientX,\n      moveY = e.changedTouches[0].clientY,\n      curIndex = e.currentTarget.dataset.index, \n      dataList = this.data.dataList,\n      angle = this.angle(\n        { X: this.data.startX,\n\t    Y: this.data.startY\n\t    }, { X: moveX,\n\t    Y: moveY\n\t    }\n\t  );\n    const that = this; //用于在forEach函数里访问data\n    dataList.forEach((item, index) => {\n      if (curIndex === index && angle < 30 && moveX < this.data.startX) {\n        item.isTouchMove = true;\n        that.data.hidden = index;//如果有块被滑动，将hidden设为此块，否则就会保持在null\n      } else {\n      \titem.isTouchMove = false; \n      }\n    });\n\n    this.setData({\n      dataList: dataList,\n    });\n\n    setTimeOut({\n      that.setData({\n        hidden: that.data.hidden //0.3s后渲染hidden来替换组件，此时动画基本放完了\n      })\n    }, 300);\n  },\n```\n\n经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。\n\n## 总结\n\n至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。","slug":"关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）","published":1,"updated":"2021-08-20T09:51:39.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksyp92bw00060su62c75dhsx","content":"<p>上一章内容：<a href=\"/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89\">关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</a></p>\n<p>原代码不再贴出。</p>\n<h2 id=\"新的工程需求\"><a href=\"#新的工程需求\" class=\"headerlink\" title=\"新的工程需求\"></a>新的工程需求</h2><p>上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：</p>\n<p>不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。</p>\n<h2 id=\"初步想法：阻止手势穿透\"><a href=\"#初步想法：阻止手势穿透\" class=\"headerlink\" title=\"初步想法：阻止手势穿透\"></a>初步想法：阻止手势穿透</h2><p>微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"尝试：将bind换成catch\"><a href=\"#尝试：将bind换成catch\" class=\"headerlink\" title=\"尝试：将bind换成catch\"></a>尝试：将bind换成catch</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;touchStart&quot; catchtouchmove=&quot;touchMove&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。</p>\n<h2 id=\"尝试：使bind和catch的事件根据isTouchMove进行变化\"><a href=\"#尝试：使bind和catch的事件根据isTouchMove进行变化\" class=\"headerlink\" title=\"尝试：使bind和catch的事件根据isTouchMove进行变化\"></a>尝试：使bind和catch的事件根据isTouchMove进行变化</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot; </span><br><span class=\"line\">    bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。</p>\n<h2 id=\"尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\"><a href=\"#尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\" class=\"headerlink\" title=\"尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\"></a>尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:if=&quot;&#123;&#123;!item.isTouchMove&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。</p>\n<h2 id=\"最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\"><a href=\"#最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\" class=\"headerlink\" title=\"最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\"></a>最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换</h2><p>绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。</p>\n<p>思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。</p>\n<p>注意：css中，动画设定是0.4s，延时应当适当小于这个值。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:if=&quot;&#123;&#123;index!==hidden&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Page */</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">dataList</span>: [<span class=\"comment\">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class=\"line\">    <span class=\"attr\">startX</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">startY</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">hidden</span>: <span class=\"literal\">null</span>,<span class=\"comment\">//标记被隐藏的块index</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchStart</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataList = <span class=\"built_in\">this</span>.data.dataList;</span><br><span class=\"line\">    dataList.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item.isTouchMove) &#123;</span><br><span class=\"line\">        item.isTouchMove = !item.isTouchMove;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.hidden = <span class=\"literal\">null</span>; <span class=\"comment\">//先把hidden置null, 但不渲染</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startX = e.touches[<span class=\"number\">0</span>].clientX;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startY = e.touches[<span class=\"number\">0</span>].clientY;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchMove</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> moveX = e.changedTouches[<span class=\"number\">0</span>].clientX,</span><br><span class=\"line\">      moveY = e.changedTouches[<span class=\"number\">0</span>].clientY,</span><br><span class=\"line\">      curIndex = e.currentTarget.dataset.index, </span><br><span class=\"line\">      dataList = <span class=\"built_in\">this</span>.data.dataList,</span><br><span class=\"line\">      angle = <span class=\"built_in\">this</span>.angle(</span><br><span class=\"line\">        &#123; <span class=\"attr\">X</span>: <span class=\"built_in\">this</span>.data.startX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: <span class=\"built_in\">this</span>.data.startY</span><br><span class=\"line\">\t    &#125;, &#123; <span class=\"attr\">X</span>: moveX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: moveY</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  );</span><br><span class=\"line\">    <span class=\"keyword\">const</span> that = <span class=\"built_in\">this</span>; <span class=\"comment\">//用于在forEach函数里访问data</span></span><br><span class=\"line\">    dataList.forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curIndex === index &amp;&amp; angle &lt; <span class=\"number\">30</span> &amp;&amp; moveX &lt; <span class=\"built_in\">this</span>.data.startX) &#123;</span><br><span class=\"line\">        item.isTouchMove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        that.data.hidden = index;<span class=\"comment\">//如果有块被滑动，将hidden设为此块，否则就会保持在null</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \titem.isTouchMove = <span class=\"literal\">false</span>; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeOut(&#123;</span><br><span class=\"line\">      that.setData(&#123;</span><br><span class=\"line\">        <span class=\"attr\">hidden</span>: that.data.hidden <span class=\"comment\">//0.3s后渲染hidden来替换组件，此时动画基本放完了</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。</p>\n","site":{"data":{}},"excerpt":"<p>上一章内容：<a href=\"/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89\">关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</a></p>\n<p>原代码不再贴出。</p>\n<h2 id=\"新的工程需求\"><a href=\"#新的工程需求\" class=\"headerlink\" title=\"新的工程需求\"></a>新的工程需求</h2><p>上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：</p>\n<p>不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。</p>\n<h2 id=\"初步想法：阻止手势穿透\"><a href=\"#初步想法：阻止手势穿透\" class=\"headerlink\" title=\"初步想法：阻止手势穿透\"></a>初步想法：阻止手势穿透</h2><p>微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？</p>","more":"<h2 id=\"尝试：将bind换成catch\"><a href=\"#尝试：将bind换成catch\" class=\"headerlink\" title=\"尝试：将bind换成catch\"></a>尝试：将bind换成catch</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;touchStart&quot; catchtouchmove=&quot;touchMove&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。</p>\n<h2 id=\"尝试：使bind和catch的事件根据isTouchMove进行变化\"><a href=\"#尝试：使bind和catch的事件根据isTouchMove进行变化\" class=\"headerlink\" title=\"尝试：使bind和catch的事件根据isTouchMove进行变化\"></a>尝试：使bind和catch的事件根据isTouchMove进行变化</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot; </span><br><span class=\"line\">    bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。</p>\n<h2 id=\"尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\"><a href=\"#尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\" class=\"headerlink\" title=\"尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个\"></a>尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个</h2><figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:if=&quot;&#123;&#123;!item.isTouchMove&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<p>效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。</p>\n<h2 id=\"最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\"><a href=\"#最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\" class=\"headerlink\" title=\"最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换\"></a>最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换</h2><p>绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。</p>\n<p>思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。</p>\n<p>注意：css中，动画设定是0.4s，延时应当适当小于这个值。</p>\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:if=&quot;&#123;&#123;index!==hidden&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class=\"line\">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class=\"line\">        &lt;!-- 内容 --&gt;</span><br><span class=\"line\">    &lt;/view&gt;</span><br><span class=\"line\">&lt;/block&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Page */</span></span><br><span class=\"line\">  <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">dataList</span>: [<span class=\"comment\">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class=\"line\">    <span class=\"attr\">startX</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">startY</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">hidden</span>: <span class=\"literal\">null</span>,<span class=\"comment\">//标记被隐藏的块index</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchStart</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dataList = <span class=\"built_in\">this</span>.data.dataList;</span><br><span class=\"line\">    dataList.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (item.isTouchMove) &#123;</span><br><span class=\"line\">        item.isTouchMove = !item.isTouchMove;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.hidden = <span class=\"literal\">null</span>; <span class=\"comment\">//先把hidden置null, 但不渲染</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startX = e.touches[<span class=\"number\">0</span>].clientX;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.data.startY = e.touches[<span class=\"number\">0</span>].clientY;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">touchMove</span>(<span class=\"params\">e</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> moveX = e.changedTouches[<span class=\"number\">0</span>].clientX,</span><br><span class=\"line\">      moveY = e.changedTouches[<span class=\"number\">0</span>].clientY,</span><br><span class=\"line\">      curIndex = e.currentTarget.dataset.index, </span><br><span class=\"line\">      dataList = <span class=\"built_in\">this</span>.data.dataList,</span><br><span class=\"line\">      angle = <span class=\"built_in\">this</span>.angle(</span><br><span class=\"line\">        &#123; <span class=\"attr\">X</span>: <span class=\"built_in\">this</span>.data.startX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: <span class=\"built_in\">this</span>.data.startY</span><br><span class=\"line\">\t    &#125;, &#123; <span class=\"attr\">X</span>: moveX,</span><br><span class=\"line\">\t    <span class=\"attr\">Y</span>: moveY</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  );</span><br><span class=\"line\">    <span class=\"keyword\">const</span> that = <span class=\"built_in\">this</span>; <span class=\"comment\">//用于在forEach函数里访问data</span></span><br><span class=\"line\">    dataList.forEach(<span class=\"function\">(<span class=\"params\">item, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (curIndex === index &amp;&amp; angle &lt; <span class=\"number\">30</span> &amp;&amp; moveX &lt; <span class=\"built_in\">this</span>.data.startX) &#123;</span><br><span class=\"line\">        item.isTouchMove = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        that.data.hidden = index;<span class=\"comment\">//如果有块被滑动，将hidden设为此块，否则就会保持在null</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      \titem.isTouchMove = <span class=\"literal\">false</span>; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setData(&#123;</span><br><span class=\"line\">      <span class=\"attr\">dataList</span>: dataList,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    setTimeOut(&#123;</span><br><span class=\"line\">      that.setData(&#123;</span><br><span class=\"line\">        <span class=\"attr\">hidden</span>: that.data.hidden <span class=\"comment\">//0.3s后渲染hidden来替换组件，此时动画基本放完了</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;, <span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;,</span><br></pre></td></tr></table></figure>\n\n<p>经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。</p>"},{"title":"微信小程序：灵活适配不同标题栏高度的设备的方法","date":"2021-08-14T15:40:07.000Z","comment":true,"_content":"\n## 工程需求\n\n开发的应用：用微信小程序经由hera生成的跨平台移动端App。\n\n作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？\n\n首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。\n\n## 方案参考\n\n在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。\n\n私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：\n\n<!-- more -->\n\n## 最终方案\n\n### 大体思路如下：\n\n在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。\n\n### 主要代码：\n\n``` javascript index.js\n/* page */\n\tdata: {\n\t\tdAbsoluteTop: 0, //准备设置固定内容组件的高度\n\t},\n\n\tonLoad: function(){\n\t\tconst that = this;\n\t\tconst query = wx.createSelectorQuery();\n\t\tquery.select('#fixed-view').boundingClientRect();\n\t\tquery.selectViewport().scrollOffset();\n\t\tquery.exec(function(res){\n\t\t\tthat.setData({\n\t\t\t\tdAbsoluteTop: res[0].bottom //根据底部渲染\n\t\t\t});\n\t\t});\n\t},\n```\n\n``` wxml index.wxml\n<view id=\"fixed-view\" style=\"position: fixed; top: 0; display: flex; flex-direction: column;\">\n\t<titlebar /> <!-- 标题栏 -->\n\t<tabbar /> <!-- 选择标签栏 -->\n</view>\n<view style=\"position: absolute; top: {{dAbsolute}};\">\n\t<!-- 内容 -->\n</view>\n```\n\n经不同设备检验，效果良好。","source":"_posts/微信小程序：灵活适配不同标题栏高度的设备的方法.md","raw":"---\ntitle: 微信小程序：灵活适配不同标题栏高度的设备的方法\ndate: 2021-08-14 23:40:07\ntags: [微信小程序,fs]\ncategories: 微信小程序\ncomment: true\n---\n\n## 工程需求\n\n开发的应用：用微信小程序经由hera生成的跨平台移动端App。\n\n作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？\n\n首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。\n\n## 方案参考\n\n在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。\n\n私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：\n\n<!-- more -->\n\n## 最终方案\n\n### 大体思路如下：\n\n在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。\n\n### 主要代码：\n\n``` javascript index.js\n/* page */\n\tdata: {\n\t\tdAbsoluteTop: 0, //准备设置固定内容组件的高度\n\t},\n\n\tonLoad: function(){\n\t\tconst that = this;\n\t\tconst query = wx.createSelectorQuery();\n\t\tquery.select('#fixed-view').boundingClientRect();\n\t\tquery.selectViewport().scrollOffset();\n\t\tquery.exec(function(res){\n\t\t\tthat.setData({\n\t\t\t\tdAbsoluteTop: res[0].bottom //根据底部渲染\n\t\t\t});\n\t\t});\n\t},\n```\n\n``` wxml index.wxml\n<view id=\"fixed-view\" style=\"position: fixed; top: 0; display: flex; flex-direction: column;\">\n\t<titlebar /> <!-- 标题栏 -->\n\t<tabbar /> <!-- 选择标签栏 -->\n</view>\n<view style=\"position: absolute; top: {{dAbsolute}};\">\n\t<!-- 内容 -->\n</view>\n```\n\n经不同设备检验，效果良好。","slug":"微信小程序：灵活适配不同标题栏高度的设备的方法","published":1,"updated":"2021-08-20T09:51:39.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksyp92bx00070su6ackuezp0","content":"<h2 id=\"工程需求\"><a href=\"#工程需求\" class=\"headerlink\" title=\"工程需求\"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端App。</p>\n<p>作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？</p>\n<p>首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。</p>\n<h2 id=\"方案参考\"><a href=\"#方案参考\" class=\"headerlink\" title=\"方案参考\"></a>方案参考</h2><p>在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。</p>\n<p>私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：</p>\n<span id=\"more\"></span>\n\n<h2 id=\"最终方案\"><a href=\"#最终方案\" class=\"headerlink\" title=\"最终方案\"></a>最终方案</h2><h3 id=\"大体思路如下：\"><a href=\"#大体思路如下：\" class=\"headerlink\" title=\"大体思路如下：\"></a>大体思路如下：</h3><p>在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。</p>\n<h3 id=\"主要代码：\"><a href=\"#主要代码：\" class=\"headerlink\" title=\"主要代码：\"></a>主要代码：</h3><figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* page */</span></span><br><span class=\"line\">\t<span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">dAbsoluteTop</span>: <span class=\"number\">0</span>, <span class=\"comment\">//准备设置固定内容组件的高度</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">onLoad</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> that = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> query = wx.createSelectorQuery();</span><br><span class=\"line\">\t\tquery.select(<span class=\"string\">&#x27;#fixed-view&#x27;</span>).boundingClientRect();</span><br><span class=\"line\">\t\tquery.selectViewport().scrollOffset();</span><br><span class=\"line\">\t\tquery.exec(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">\t\t\tthat.setData(&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">dAbsoluteTop</span>: res[<span class=\"number\">0</span>].bottom <span class=\"comment\">//根据底部渲染</span></span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;,</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view id=&quot;fixed-view&quot; style=&quot;position: fixed; top: 0; display: flex; flex-direction: column;&quot;&gt;</span><br><span class=\"line\">\t&lt;titlebar /&gt; &lt;!-- 标题栏 --&gt;</span><br><span class=\"line\">\t&lt;tabbar /&gt; &lt;!-- 选择标签栏 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br><span class=\"line\">&lt;view style=&quot;position: absolute; top: &#123;&#123;dAbsolute&#125;&#125;;&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>经不同设备检验，效果良好。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"工程需求\"><a href=\"#工程需求\" class=\"headerlink\" title=\"工程需求\"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端App。</p>\n<p>作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？</p>\n<p>首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。</p>\n<h2 id=\"方案参考\"><a href=\"#方案参考\" class=\"headerlink\" title=\"方案参考\"></a>方案参考</h2><p>在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。</p>\n<p>私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：</p>","more":"<h2 id=\"最终方案\"><a href=\"#最终方案\" class=\"headerlink\" title=\"最终方案\"></a>最终方案</h2><h3 id=\"大体思路如下：\"><a href=\"#大体思路如下：\" class=\"headerlink\" title=\"大体思路如下：\"></a>大体思路如下：</h3><p>在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。</p>\n<h3 id=\"主要代码：\"><a href=\"#主要代码：\" class=\"headerlink\" title=\"主要代码：\"></a>主要代码：</h3><figure class=\"highlight javascript\"><figcaption><span>index.js</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* page */</span></span><br><span class=\"line\">\t<span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">\t\t<span class=\"attr\">dAbsoluteTop</span>: <span class=\"number\">0</span>, <span class=\"comment\">//准备设置固定内容组件的高度</span></span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"attr\">onLoad</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> that = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">const</span> query = wx.createSelectorQuery();</span><br><span class=\"line\">\t\tquery.select(<span class=\"string\">&#x27;#fixed-view&#x27;</span>).boundingClientRect();</span><br><span class=\"line\">\t\tquery.selectViewport().scrollOffset();</span><br><span class=\"line\">\t\tquery.exec(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">\t\t\tthat.setData(&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"attr\">dAbsoluteTop</span>: res[<span class=\"number\">0</span>].bottom <span class=\"comment\">//根据底部渲染</span></span><br><span class=\"line\">\t\t\t&#125;);</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;,</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><figcaption><span>index.wxml</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;view id=&quot;fixed-view&quot; style=&quot;position: fixed; top: 0; display: flex; flex-direction: column;&quot;&gt;</span><br><span class=\"line\">\t&lt;titlebar /&gt; &lt;!-- 标题栏 --&gt;</span><br><span class=\"line\">\t&lt;tabbar /&gt; &lt;!-- 选择标签栏 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br><span class=\"line\">&lt;view style=&quot;position: absolute; top: &#123;&#123;dAbsolute&#125;&#125;;&quot;&gt;</span><br><span class=\"line\">\t&lt;!-- 内容 --&gt;</span><br><span class=\"line\">&lt;/view&gt;</span><br></pre></td></tr></table></figure>\n\n<p>经不同设备检验，效果良好。</p>"}],"PostAsset":[{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png","post":"cksyp92bp00010su6gial8b49","slug":"compare-final.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/compare.png","post":"cksyp92bp00010su6gial8b49","slug":"compare.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg","post":"cksyp92bp00010su6gial8b49","slug":"path-compression.jpg","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png","post":"cksyp92bp00010su6gial8b49","slug":"qf1.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png","post":"cksyp92bp00010su6gial8b49","slug":"qf2.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png","post":"cksyp92bp00010su6gial8b49","slug":"qu1.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png","post":"cksyp92bp00010su6gial8b49","slug":"qu2.png","modified":1,"renderable":1},{"_id":"source/_posts/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png","post":"cksyp92bp00010su6gial8b49","slug":"weighting.png","modified":1,"renderable":1},{"_id":"source/_posts/关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）/侧滑效果.gif","post":"cksyp92bv00050su6249a54co","slug":"侧滑效果.gif","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cksyp92bv00050su6249a54co","category_id":"cksyp92c0000a0su6hfnyf7yt","_id":"cksyp92c2000h0su6au58evxn"},{"post_id":"cksyp92bw00060su62c75dhsx","category_id":"cksyp92c0000a0su6hfnyf7yt","_id":"cksyp92c3000j0su6d22a2dja"},{"post_id":"cksyp92bp00010su6gial8b49","category_id":"cksyp92bu00030su6ac0b51em","_id":"cksyp92c4000n0su615626670"},{"post_id":"cksyp92bp00010su6gial8b49","category_id":"cksyp92c2000g0su64u9c4f9p","_id":"cksyp92c5000p0su6bz862ws1"},{"post_id":"cksyp92bx00070su6ackuezp0","category_id":"cksyp92c0000a0su6hfnyf7yt","_id":"cksyp92c5000r0su65ejjd4qe"},{"post_id":"cksyp92bs00020su642444fco","category_id":"cksyp92bu00030su6ac0b51em","_id":"cksyp92c6000v0su6fodlbo1c"},{"post_id":"cksyp92bs00020su642444fco","category_id":"cksyp92c2000g0su64u9c4f9p","_id":"cksyp92c6000y0su6alw9332y"}],"PostTag":[{"post_id":"cksyp92bp00010su6gial8b49","tag_id":"cksyp92bv00040su60u50gpr7","_id":"cksyp92c1000c0su6dm4n9qqa"},{"post_id":"cksyp92bp00010su6gial8b49","tag_id":"cksyp92by00090su6h4f49g9n","_id":"cksyp92c1000d0su676afgaf2"},{"post_id":"cksyp92bs00020su642444fco","tag_id":"cksyp92bv00040su60u50gpr7","_id":"cksyp92c5000q0su69n4d7qq7"},{"post_id":"cksyp92bs00020su642444fco","tag_id":"cksyp92by00090su6h4f49g9n","_id":"cksyp92c5000s0su6d1vhguuq"},{"post_id":"cksyp92bs00020su642444fco","tag_id":"cksyp92c2000i0su6cvrg8woc","_id":"cksyp92c6000u0su66zszd3eh"},{"post_id":"cksyp92bs00020su642444fco","tag_id":"cksyp92c3000l0su6aww6e5dp","_id":"cksyp92c6000w0su6dnug1wma"},{"post_id":"cksyp92bv00050su6249a54co","tag_id":"cksyp92c4000o0su6ct0och2d","_id":"cksyp92c6000z0su66d5ta21b"},{"post_id":"cksyp92bv00050su6249a54co","tag_id":"cksyp92c5000t0su62n4gb0t6","_id":"cksyp92c700100su636vh6ak2"},{"post_id":"cksyp92bw00060su62c75dhsx","tag_id":"cksyp92c4000o0su6ct0och2d","_id":"cksyp92c700130su6d3in30bi"},{"post_id":"cksyp92bw00060su62c75dhsx","tag_id":"cksyp92c5000t0su62n4gb0t6","_id":"cksyp92c800140su6b0rde0gz"},{"post_id":"cksyp92bx00070su6ackuezp0","tag_id":"cksyp92c4000o0su6ct0och2d","_id":"cksyp92c800160su6fan347wz"},{"post_id":"cksyp92bx00070su6ackuezp0","tag_id":"cksyp92c5000t0su62n4gb0t6","_id":"cksyp92c800170su615xc1x27"}],"Tag":[{"name":"JS","_id":"cksyp92bv00040su60u50gpr7"},{"name":"算法","_id":"cksyp92by00090su6h4f49g9n"},{"name":"快速幂","_id":"cksyp92c2000i0su6cvrg8woc"},{"name":"大数越界","_id":"cksyp92c3000l0su6aww6e5dp"},{"name":"微信小程序","_id":"cksyp92c4000o0su6ct0och2d"},{"name":"fs","_id":"cksyp92c5000t0su62n4gb0t6"}]}}
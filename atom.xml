<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员玛丽的星海方舟</title>
  
  <subtitle>陈俪影的个人空间，用于分享自己学习、工作和兴趣中写程序的心得体会。</subtitle>
  <link href="https://marycly.github.io/atom.xml" rel="self"/>
  
  <link href="https://marycly.github.io/"/>
  <updated>2024-08-08T03:26:46.530Z</updated>
  <id>https://marycly.github.io/</id>
  
  <author>
    <name>陈俪影</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双版本应用重构后的感想</title>
    <link href="https://marycly.github.io/%E5%8F%8C%E7%89%88%E6%9C%AC%E5%BA%94%E7%94%A8%E9%87%8D%E6%9E%84%E5%90%8E%E7%9A%84%E6%84%9F%E6%83%B3/"/>
    <id>https://marycly.github.io/%E5%8F%8C%E7%89%88%E6%9C%AC%E5%BA%94%E7%94%A8%E9%87%8D%E6%9E%84%E5%90%8E%E7%9A%84%E6%84%9F%E6%83%B3/</id>
    <published>2024-08-08T02:07:00.000Z</published>
    <updated>2024-08-08T03:26:46.530Z</updated>
    
    <content type="html"><![CDATA[<p>上篇中突然发现项目前端架构不合理后，我是有点坐立不安的。考虑到之后战线还会拉长，所以我还是抽了2-3天时间把这个事情处理掉。提前跟后端（兼研发经理）沟通过，让他配合我重新部署测试。</p><span id="more"></span><h2 id="重构的具体操作"><a href="#重构的具体操作" class="headerlink" title="重构的具体操作"></a>重构的具体操作</h2><p>首先，将源代码中可以完全复用的内容提取到上级目录下。如图片素材、通用逻辑函数、API定义等。移动后对代码进行全局替换，调整它们的引用地址。</p><p>然后，新建一个package（前端脚手架的分包管理），将剩余的代码复制一份。然后对于每个文件，两边对照着保留当前比例所使用的代码，删除未使用的代码。这个过程需要非常细心，合理利用文件内搜索（我使用的分支信号是is169这个变量，就重点搜索这个变量）。</p><p>完成这些后，再在package.json, 脚手架开发服务配置和webpack配置中定义16:9, 32:9单独或同时的启动服务方式和打包方式。如定义serve:169是只启动16:9的服务，serve是同时启动；build:169是打包16:9的程序，build是打包两个程序。</p><p>以上就完成了重构。重构完后在本地启动服务，分别浏览16:9和32:9应用是否存在bug。本地确认无bug后发布测试环境，再确认测试环境是否有bug。对于后端来说，原先的部署方式是两个文件夹放置大体相同的打包文件，只有一个配置文件的区别，现在就是两个文件夹放不同的打包文件，改动不是特别大。</p><h2 id="重构后感觉到的变化"><a href="#重构后感觉到的变化" class="headerlink" title="重构后感觉到的变化"></a>重构后感觉到的变化</h2><ol><li><p>启动和打包速度：对于启动和打包单个比例的情况，是有一定的速度提升的，体感大约有20%。但是同时启动或打包两个比例时，会更慢。特别是打包时，会需要接近原来2倍的时间，因为实际上是按先后顺序分别打包，而不是同时。在实际开发过程中，大约70%的时间需要启动和打包单个比例，30%的时间是两个一起。综合来看，加权平均的启动、打包时间是略微更久。</p></li><li><p>单个包大小：相比原来的组合版本，16:9的减少约5%，32:9的减少约10%，效果没有我想象的好。我一开始认为，包大小中占比最大的就是素材，16:9和32:9单独的素材加起来会占很大的空间。而根据重构后的结果来看，素材实际上本来就复用得很多，并没有特别多单独的素材。不过32:9的包通常都比16:9的大几MB，说明32:9的素材还是比较大的。</p></li><li><p>部署速度：部署速度理论上通常取决于上传文件的速度。原本是将同一个包上传到服务器，然后复制到两个文件夹；现在需要将两个包上传到服务器的两个文件夹。因为上传两个文件实际上是几乎没有降速，所以上传速度取决于最大的那个包，还是小于原来的包大小，因此就算是两个包同时上传，也会比原来的部署速度稍快。更新一个包的情况则自然是更快一些的。</p></li><li><p>开发体验：代码易读性提升非常明显，开发难度也显著下降。不用想尽办法写分支，只需要关注当下的事情真是太好了。开发完一个比例后直接复制一份，再稍微修改就行，除了echarts配置外，js逻辑基本不需要改。需要跟新人解释的事情也少多了。</p></li><li><p>代码冗余和维护难度：那都不叫事儿……其实没有多少。</p></li></ol><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>综合来说，重构还是非常值得的。虽然性能没有明显的提升，但开发体验真的好很多。这次架构决策失误让我深刻地体会到代码的少和精并不代表好。有时恰恰需要冗余，才能让程序更加灵活。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上篇中突然发现项目前端架构不合理后，我是有点坐立不安的。考虑到之后战线还会拉长，所以我还是抽了2-3天时间把这个事情处理掉。提前跟后端（兼研发经理）沟通过，让他配合我重新部署测试。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>双版本应用的架构决策反思</title>
    <link href="https://marycly.github.io/%E5%8F%8C%E7%89%88%E6%9C%AC%E5%BA%94%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%86%B3%E7%AD%96%E5%8F%8D%E6%80%9D/"/>
    <id>https://marycly.github.io/%E5%8F%8C%E7%89%88%E6%9C%AC%E5%BA%94%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%86%B3%E7%AD%96%E5%8F%8D%E6%80%9D/</id>
    <published>2024-05-20T07:40:00.000Z</published>
    <updated>2024-05-20T09:17:27.283Z</updated>
    
    <content type="html"><![CDATA[<p>去年8月启动的项目一直基本作为独立前端干到现在，有时候会突然意识到一些非常严重的技术决策失误，有些轻易就可以挽救，有些却已经积重难返。当然，我不会过分责怪那时的自己，毕竟当时还是一个只工作了一年的小白。但我决定把一个最近发现的决策失误记录下来，以警醒自己。</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这个决策是在项目开发了大约2-3个月，已经开发了5-6个页面的时候出现的。一开始项目的需求是在32:9比例的大屏上进行展示，只开发了适配32:9比例的版本。但后来客户发现汇报时经常只有条件使用16:9的屏幕，且平常政府人员也有在电脑上浏览应用的需求，因此决定今后要同时开发16:9和32:9两个版本。因为这个需求，我们需要设计一套前端架构来实现两种比例的分别显示。</p><h2 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h2><p>当时做前端架构设计的是我自己，时间比较仓促，只是简单跟研发经理交流了一下（研发经理是后端出身，其实不是很懂），暂时得出了以下的两个方案：</p><ol><li>使用同一套前端代码进行开发部署，通过一个变量来进行16:9和32:9比例的切换，代码通过这个变量作为条件进行分支表达</li></ol><p>具体的操作就是创建一个全局可获取的state(is169)，在template和script中通过这个变量来做分支表达；根节点根据is169设置类名.ratio169和.ratio329来进行css的覆盖。项目部署时附带一个config文件，在这里可以设置is169的值，或者自动切换（在代码里设置window的resize事件监听，判断当前屏幕比例）。</p><ol start="2"><li>使用两套前端代码进行开发部署，16:9和32:9独立开发</li></ol><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p>优点：</p><ol><li><p>代码和素材可以高度复用，冗余最小化，整体包大小较小</p></li><li><p>减少了代码重复的情况下，更改无需反复同步</p></li><li><p>可以实现两种比例之间快速切换，方便开发者和客户对比观察</p></li></ol><p>缺点：</p><ol><li><p>必须同时载入整个包，启动速度可能较慢</p></li><li><p>分支判断的编码方式会降低易读性，且新人难以上手，后续维护较麻烦</p></li><li><p>当某个页面需要大幅度改动，而两个比例版本之间存在进度不一致的情况时，会比较麻烦</p></li></ol><h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><p>优点：</p><ol><li><p>两个比例的包是独立的，单个启动速度较快</p></li><li><p>代码更加简单，易读性更强，新人上手更快，后续维护更简单</p></li><li><p>两种比例的内容不一致的情况会更好处理</p></li></ol><p>缺点：</p><ol><li><p>作为整体来看代码冗余更多，包大小更大</p></li><li><p>存在更多重复代码，常需要进行修改同步</p></li><li><p>不可以实现两种比例之间快速切换</p></li></ol><h2 id="当时的决策和现在的看法"><a href="#当时的决策和现在的看法" class="headerlink" title="当时的决策和现在的看法"></a>当时的决策和现在的看法</h2><p>首先说明，当时选择的是方案一，而现在我觉得方案二更好。为什么？这需要结合当时和现在的不同情况来解释。</p><h3 id="选择方案一的理由"><a href="#选择方案一的理由" class="headerlink" title="选择方案一的理由"></a>选择方案一的理由</h3><ol><li><p>当时项目还处于初期，需求的变化是迅速的，我需要一个更有备无患的方式去应对客户可能的需求。如果客户想要进行16:9和32:9的快速切换，怎么办？方案一是更容易实现这一点的。</p></li><li><p>开发的工期很赶。我认为使用方案一能减少代码量，很好地提高开发的效率。</p></li><li><p>可能会需要频繁地更改全局样式。使用方案一的情况下，在更改全局样式时能够更快地进行两种比例下的综合审阅。</p></li></ol><p>除上述几点之外，也许当时的我并没有考虑到上文所提到的所有的优缺点来进行综合的评估，并且技术经验不足以支撑比较实际的设想对比。在比较仓促的情况下，认为方案一为更好实现的一方。</p><h3 id="现在认为方案二更好的理由"><a href="#现在认为方案二更好的理由" class="headerlink" title="现在认为方案二更好的理由"></a>现在认为方案二更好的理由</h3><ol><li><p>随着项目的发展，内容越来越多。现在一整个包的启动速度会很慢（相对单位的垃圾电脑来说），这个问题其实是对开发效率的一个很大的阻碍。</p></li><li><p>因为独特的编码方案，项目难以临时加新人支援（还需要花时间教学），我也不得不一直在这个项目上。就算以后调走了，估计也会是一个沉重的技术债。这个问题是当时没有考虑到的。</p></li><li><p>当时对公司的多package框架还不熟悉，现在深刻地掌握了以后发现，其实如果走方案二，还是可以复用很多代码和素材的，其实应对这种情况非常好。当时太高估方案二的开发难度和冗余程度了。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总地来说，我现在觉得这是一个从长远来看比较失败的架构决策。考虑了重构成本，觉得还是比较困难，风险太高了。如果没有充分的时间和理想的方案，应该暂时不会考虑重构。但我现在深切感受到在某些情况下追求“精简”、“复用”可能是一个严重的谬误，希望能够在以后的开发生涯中成为一个教训。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年8月启动的项目一直基本作为独立前端干到现在，有时候会突然意识到一些非常严重的技术决策失误，有些轻易就可以挽救，有些却已经积重难返。当然，我不会过分责怪那时的自己，毕竟当时还是一个只工作了一年的小白。但我决定把一个最近发现的决策失误记录下来，以警醒自己。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件复制实现模块放大终极优化版</title>
    <link href="https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96%E7%89%88/"/>
    <id>https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E7%BB%88%E6%9E%81%E4%BC%98%E5%8C%96%E7%89%88/</id>
    <published>2023-11-15T09:39:04.000Z</published>
    <updated>2023-11-15T10:14:05.247Z</updated>
    
    <content type="html"><![CDATA[<p>继上章研究出模块放大的实现方法并选择了 Vue 组件复制的方法后，将该方法投入了实践。在开发过程中还是觉得之前设计的调用方式有些繁琐，于是灵机一动，改良了一下代码。接下来将放出完整的关键代码，没看上一章也没关系。</p><span id="more"></span><h3 id="用于渲染的组件"><a href="#用于渲染的组件" class="headerlink" title="用于渲染的组件"></a>用于渲染的组件</h3><figure class="highlight html"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;component&quot;</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperArea&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 遮罩，点击关闭 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperAreaMask&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 中心的一层包装，可设置背景 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapper&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: finalWidth + &#x27;px&#x27;, height: finalHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 这里设置了一个enlarged属性来便于组件内部分辨是否被放大，按需添加 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:is</span>=<span class="string">&quot;component&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-bind</span>=<span class="string">&quot;props&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;transform-origin: top left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:style</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">          width: initialWidth + &#x27;px&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          height: initialHeight + &#x27;px&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          transform: `scale($&#123;scale&#125;)`,</span></span></span><br><span class="line"><span class="string"><span class="tag">        &#125;&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">enlarged</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">component</span>: <span class="literal">null</span>, <span class="comment">// 渲染放大的组件，顺便控制是否显示</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">props</span>: &#123;&#125;, <span class="comment">// 将输入组件的参数</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">initialWidth</span>: <span class="number">0</span>, <span class="comment">// 原始组件的宽度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">initialHeight</span>: <span class="number">0</span>, <span class="comment">// 原始组件的高度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">finalWidth</span>: <span class="number">0</span>, <span class="comment">// 放大后的宽度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">finalHeight</span>: <span class="number">0</span>, <span class="comment">// 放大后的高度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">scale</span>: <span class="number">1</span>, <span class="comment">// 应放大的倍数</span></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收参数并显示浮层的方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">handler</span>(<span class="params">component, initialWidth, initialHeight, props = &#123;&#125;</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!component || !initialWidth || !initialHeight) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 预防异常</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.initialWidth = initialWidth;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.initialHeight = initialHeight;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 根据情况计算应放大的效果，获取finalWidth, finalHeight和scale.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> maxWidth = <span class="number">2400</span>, maxHeight = <span class="number">1200</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> maxWidthScale = maxWidth / <span class="built_in">this</span>.initialWidth, maxHeightScale = maxHeight / <span class="built_in">this</span>.initialHeight;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.scale = <span class="built_in">Math</span>.min(maxWidthScale, maxHeightScale);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.finalWidth = <span class="built_in">this</span>.initialWidth * <span class="built_in">this</span>.scale;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.finalHeight = <span class="built_in">this</span>.initialHeight * <span class="built_in">this</span>.scale;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置组件和参数，将会开始渲染</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.component = component;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.props = props;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 关闭浮层的方法</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.component = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.props = &#123;&#125;;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapperArea</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 覆盖全屏 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">z-index</span>: <span class="number">9999</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapperAreaMask</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 覆盖全屏，第一层 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>); <span class="comment">/* 遮罩颜色 */</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapper</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 居中，第二层 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="number">#061d33</span>; <span class="comment">/* 设置的深色背景颜色，用于显示浅色调的内容 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>该组件需要被设置在较低层级的地方，如#app 元素中，以使其 z-index 能否覆盖所有的图层。</strong></p><figure class="highlight html"><figcaption><span>App.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">enlarge-wrapper</span>&gt;</span><span class="tag">&lt;/<span class="name">enlarge-wrapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>上一个版本需要更改父组件，较为繁琐，本版本仅需操作需要复制放大的组件。</p><p>如果父组件中注册了我们的目标组件，名称为TargetComponent：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target-component</span>&gt;</span><span class="tag">&lt;/<span class="name">target-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> TargetComponent <span class="keyword">from</span> <span class="string">&#x27;[path]&#x27;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">components</span>: &#123; TargetComponent &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子组件中，需要这样调用放大功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 需要知道自己在父组件中的注册名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;enlarge(&#x27;TargetComponent&#x27;)&quot;</span>&gt;</span>Enlarge Myself<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">/* 按需获取enlarged属性 */</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="javascript">  props: &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">    enlarged: &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">      type: Boolean,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">      default: false</span></span></span><br><span class="line"><span class="comment"><span class="javascript">    &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">  &#125;, </span></span></span><br><span class="line"><span class="comment"><span class="javascript">  */</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">enlarge</span>(<span class="params">name</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> el = <span class="built_in">this</span>.$el;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> component = <span class="built_in">this</span>.$parent?.$options?.components[name];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!el || !component) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 保存当前的props列表及对应的值，用于再次渲染</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 过滤enlarged属性，因为在enlarge-wrapper中会直接置为true</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 保存成键值对的形式，用于传递给v-bind方法</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> propsNameList = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.$options.props).filter(<span class="function"><span class="params">v</span> =&gt;</span> v !== <span class="string">&#x27;enlarged&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> props = propsNameList.reduce(<span class="function">(<span class="params">cum, v</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        cum[v] = <span class="built_in">this</span>[v];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> cum;</span></span><br><span class="line"><span class="javascript">      &#125;, &#123;&#125;);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 触发enlarge-wrapper组件中的handler方法，这里用的事件总线</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$bus.emit(<span class="string">&#x27;enlarge&#x27;</span>, component, el.clientWidth, el.clientHeight, props);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，你可以将以上的props和methods保存到mixin，方便在每个需要放大的组件中调用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>虽然优化的代码行数不多，但是可以把代码局限在需要调用的目标组件中，缩小影响的代码范围。此外，能够复制props也是比较有用的功能拓展。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;继上章研究出模块放大的实现方法并选择了 Vue 组件复制的方法后，将该方法投入了实践。在开发过程中还是觉得之前设计的调用方式有些繁琐，于是灵机一动，改良了一下代码。接下来将放出完整的关键代码，没看上一章也没关系。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件的复制或HTML快照，最终实现模块放大显示的功能</title>
    <link href="https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/</id>
    <published>2023-11-07T09:14:35.000Z</published>
    <updated>2023-11-08T02:00:46.193Z</updated>
    
    <content type="html"><![CDATA[<p>首先介绍一下开展本次尝试的需求背景：</p><p>该项目是一个 Web 大屏应用。有时在演示的时候，因为投影质量差的问题，如果字体不够大，就很难看清内容。产品提议开发一个放大功能，在点击某模块的时候能够放大展示。</p><span id="more"></span><p>延申的需求分析：</p><ol><li><p>尽可能保留组件中的各类交互，如果无法实现才使用快照。</p></li><li><p>因为大屏开发的元素排列较为紧密，因此没有做 CSS 的屏幕比例适应。如果改变了模块的宽高大小，可能放大后会造成样式偏差。而且，对每个模块都定制放大的 CSS 也不太可能，成本过高。因此，尽可能在保留原始模块元素大小的基础上，使用 transform: scale 来进行放大。</p></li><li><p>保证放大显示区域在最上层。根据本应用的结构，将放大显示区域插入#app 节点中。</p></li><li><p>关闭的方式。可以设计成点击遮罩关闭。</p></li></ol><p>在完成最终开发的过程中，尝试了三种方法，最终综合考虑实现难度和实现效果选择了其中一种。</p><h3 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h3><p>项目中的真实实现效果如图，所有数据已用劣质工具打码……</p><ul><li>原始元素：</li></ul><p><img src="https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/%E5%8E%9F%E5%A7%8B%E5%85%83%E7%B4%A0.png" alt="原始元素"></p><ul><li>放大效果 1：</li></ul><p><img src="https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C.png" alt="放大效果1"></p><ul><li>放大效果 2：</li></ul><p><img src="https://marycly.github.io/Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%88%96HTML%E5%BF%AB%E7%85%A7%EF%BC%8C%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97%E6%94%BE%E5%A4%A7%E6%98%BE%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD/%E6%94%BE%E5%A4%A7%E6%95%88%E6%9E%9C1.png" alt="放大效果2"></p><h3 id="基础的放大显示区域组件"><a href="#基础的放大显示区域组件" class="headerlink" title="基础的放大显示区域组件"></a>基础的放大显示区域组件</h3><figure class="highlight html"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;component&quot;</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperArea&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 遮罩，点击关闭 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperAreaMask&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 中心的一层包装，可设置背景 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapper&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: finalWidth + &#x27;px&#x27;, height: finalHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">component</span>: <span class="literal">null</span>, <span class="comment">// 渲染放大的组件，顺便控制是否显示</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">initialWidth</span>: <span class="number">0</span>, <span class="comment">// 原始组件的宽度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">initialHeight</span>: <span class="number">0</span>, <span class="comment">// 原始组件的高度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">finalWidth</span>: <span class="number">0</span>, <span class="comment">// 放大后的宽度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">finalHeight</span>: <span class="number">0</span>, <span class="comment">// 放大后的高度</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">scale</span>: <span class="number">1</span>, <span class="comment">// 应放大的倍数</span></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapperArea</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 覆盖全屏 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">z-index</span>: <span class="number">9999</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapperAreaMask</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 覆盖全屏，第一层 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>); <span class="comment">/* 遮罩颜色 */</span></span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#EnlargeWrapper</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="comment">/* 居中，第二层 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">  <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">  <span class="attribute">background</span>: <span class="number">#061d33</span>; <span class="comment">/* 设置的深色背景颜色，用于显示浅色调的内容 */</span></span></span><br><span class="line"><span class="css">  <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将该组件插入 body 或#app 节点下，设置为一个最高层级的覆盖物。</p><h3 id="方法一：cloneNode"><a href="#方法一：cloneNode" class="headerlink" title="方法一：cloneNode"></a>方法一：cloneNode</h3><p>这个方法的核心是使用 cloneNode 方法进行 DOM 节点复制。</p><figure class="highlight javascript"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 接收参数并显示浮层的方法</span></span><br><span class="line">    <span class="function"><span class="title">handler</span>(<span class="params">component, initialWidth, initialHeight</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 使用任何方法（如querySelector）获取到目标节点component, 然后用clientWidth和clientHeight属性获取到initialWidth和initialHeight参数</span></span><br><span class="line">      <span class="keyword">if</span> (!component || !initialWidth || !initialHeight) &#123;</span><br><span class="line">        <span class="comment">// 预防异常</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.initialWidth = initialWidth;</span><br><span class="line">      <span class="built_in">this</span>.initialHeight = initialHeight;</span><br><span class="line">      <span class="comment">// 根据情况计算应放大的效果，获取finalWidth, finalHeight和scale.</span></span><br><span class="line">      <span class="keyword">const</span> maxWidth = <span class="number">2400</span>, maxHeight = <span class="number">1200</span>;</span><br><span class="line">      <span class="keyword">const</span> maxWidthScale = maxWidth / <span class="built_in">this</span>.initialWidth, maxHeightScale = maxHeight / <span class="built_in">this</span>.initialHeight;</span><br><span class="line">      <span class="built_in">this</span>.scale = <span class="built_in">Math</span>.min(maxWidthScale, maxHeightScale);</span><br><span class="line">      <span class="built_in">this</span>.finalWidth = <span class="built_in">this</span>.initialWidth * <span class="built_in">this</span>.scale;</span><br><span class="line">      <span class="built_in">this</span>.finalHeight = <span class="built_in">this</span>.initialHeight * <span class="built_in">this</span>.scale;</span><br><span class="line">      <span class="comment">// 克隆节点</span></span><br><span class="line">      <span class="keyword">const</span> el = component.cloneNode(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 设置样式</span></span><br><span class="line">      el.style.width = <span class="built_in">this</span>.initialWidth;</span><br><span class="line">      el.style.height = <span class="built_in">this</span>.initialHeight;</span><br><span class="line">      el.style.transform = <span class="string">`scale(<span class="subst">$&#123;<span class="built_in">this</span>.scale&#125;</span>)`</span>;</span><br><span class="line">      el.style.transformOrigin = <span class="string">&#x27;top left&#x27;</span>;</span><br><span class="line">      <span class="comment">// 插入节点</span></span><br><span class="line">      <span class="keyword">const</span> parent = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#EnlargeWrapper&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">        <span class="comment">// 预防异常</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      parent.appendChild(el);</span><br><span class="line">      <span class="comment">// 记录对象并显示浮层</span></span><br><span class="line">      <span class="built_in">this</span>.component = el;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 关闭浮层的方法</span></span><br><span class="line">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> component = <span class="built_in">this</span>.component;</span><br><span class="line">      <span class="comment">// 隐藏</span></span><br><span class="line">      <span class="built_in">this</span>.component = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 删除节点</span></span><br><span class="line">      <span class="keyword">if</span> (component) &#123;</span><br><span class="line">        component.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可以以较快的速度生成 HTML 节点快照，一般情况下对静态 HTML、CSS 的渲染效果很好。</p><p>缺点：丢弃了所有的 JavaScript，因此无法交互，并且没有成功渲染 ECharts 图表。</p><h3 id="方法二：html2canvas"><a href="#方法二：html2canvas" class="headerlink" title="方法二：html2canvas"></a>方法二：html2canvas</h3><p>第二个尝试，考虑用 html2canvas 将代码转为 canvas 来展示。</p><p>首先需在项目中下载 html2canvas 依赖库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install html2canvas</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">yarn add html2canvas</span><br></pre></td></tr></table></figure><p>然后只需修改方法一的部分代码：</p><figure class="highlight javascript"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> html2canvas <span class="keyword">from</span> <span class="string">&#x27;html2canvas&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 接收参数并显示浮层的方法（添加async）</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">handler</span>(<span class="params">component, initialWidth, initialHeight</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 修改方法一中的【克隆节点】步骤</span></span><br><span class="line">      <span class="keyword">const</span> el = <span class="keyword">await</span> html2canvas(component);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：一般情况下对静态 HTML、CSS 的渲染效果较好，而且如果有需求可以保存canvas，导出图片。</p><p>缺点：生成速度较慢；放大后画质的损失略大于方法一；同样也无法交互；不支持高级的CSS属性，对于复杂的元素也经常有各种各样的问题。</p><h3 id="方法三：重新挂载Vue组件"><a href="#方法三：重新挂载Vue组件" class="headerlink" title="方法三：重新挂载Vue组件"></a>方法三：重新挂载Vue组件</h3><p>先决条件：目标模块是一个可以独立运行的组件。</p><p>首先需要在EnlargeWrapper组件中增加一个&lt;component&gt;，以渲染Vue组件。如果使用标签定义元素，则可以直接在&lt;component&gt;标签中定义样式，而无需通过DOM对象来给style属性赋值。</p><figure class="highlight html"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;component&quot;</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperArea&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapperAreaMask&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;close&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;EnlargeWrapper&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; width: finalWidth + &#x27;px&#x27;, height: finalHeight + &#x27;px&#x27; &#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在这里插入一个component --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:is</span>=<span class="string">&quot;component&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;transform-origin: top left&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:style</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">          width: initialWidth + &#x27;px&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          height: initialHeight + &#x27;px&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          transform: `scale($&#123;scale&#125;)`,</span></span></span><br><span class="line"><span class="string"><span class="tag">        &#125;&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后更改handler和close方法，把DOM操作的部分移除。</p><figure class="highlight javascript"><figcaption><span>enlarge-wrapper.vue</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">handler</span>(<span class="params">component, initialWidth, initialHeight</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ... 获取原始高度和计算放大后的效果</span></span><br><span class="line">      <span class="comment">// 删除方法一、方法二的【克隆节点】【设置样式】和【插入节点】步骤</span></span><br><span class="line">      <span class="comment">// 直接赋值component标签的is属性</span></span><br><span class="line">      <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">close</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.component = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 去掉了删除DOM元素的部分</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取传给handler的component参数：</p><p>在目标模块的父组件中，通常注册方法是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;[path]&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; ComponentA &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种情况下，methods中比较难获取到组件模板，即ComponentA这个引用常量。</p><p>因此可以将代码修改成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">&#x27;[path]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> components = &#123; ComponentA &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; ...components &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就可以在method中通过名称ComponentA获取到组件模板，通过事件总线传给EnlargeWrapper.handler;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">enlarge</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> component = components[id];</span><br><span class="line">      <span class="keyword">const</span> el = <span class="built_in">this</span>.$refs[id];</span><br><span class="line">      <span class="built_in">this</span>.$bus.emit(<span class="string">&#x27;enlarge&#x27;</span>, component, el.clientWidth, el.clientHeight);</span><br><span class="line">      <span class="comment">// 注：此为示例，事件总线需自行配置</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：在不依赖其他组件运行的情况下，可以最大程度地复刻目标模块，保留一切交互。</p><p>缺点：会出现组件初挂载的加载过程；如果没有单独处理，不能体现放大时的组件状态；需要更改父组件，代码会更复杂。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在本应用的情况下，方法一和方法二都出现了比较明显的实现偏差，但是对于方法三的实施条件充足，因此最终使用的是方法三。</p><p>但是，根据不同的应用情况和需求，您可以参考这三种方法来选择最合适的解决方案。希望这些思路能帮到您。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;首先介绍一下开展本次尝试的需求背景：&lt;/p&gt;
&lt;p&gt;该项目是一个 Web 大屏应用。有时在演示的时候，因为投影质量差的问题，如果字体不够大，就很难看清内容。产品提议开发一个放大功能，在点击某模块的时候能够放大展示。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>对一些团队前端开发规范的质疑、求证和思考总结</title>
    <link href="https://marycly.github.io/%E5%AF%B9%E4%B8%80%E4%BA%9B%E5%9B%A2%E9%98%9F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E7%9A%84%E8%B4%A8%E7%96%91%E3%80%81%E6%B1%82%E8%AF%81%E5%92%8C%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    <id>https://marycly.github.io/%E5%AF%B9%E4%B8%80%E4%BA%9B%E5%9B%A2%E9%98%9F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E7%9A%84%E8%B4%A8%E7%96%91%E3%80%81%E6%B1%82%E8%AF%81%E5%92%8C%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/</id>
    <published>2023-01-04T03:41:38.000Z</published>
    <updated>2023-01-04T08:43:38.458Z</updated>
    
    <content type="html"><![CDATA[<p>因为我算是比较重视代码质量的一个人，在刚进公司的时候就开始积极地学习团队内的一些开发规范。其中有写在文档里面的，也有同事们在代码审查中提到的；有美观性、易读性方面的，也有性能提升方面的。有时，看到一些开发规范，我无法理解它的意义和必要性，并且觉得非常不方便，便会在网络上寻找相关的资料，以及与同事交流。当然，作为一名前端新人，我个人的考虑其实也有很多不足之处，以下就介绍一下我对一些团队前端开发规范产生的质疑、求证和思考总结。</p><span id="more"></span><hr><h2 id="定义样式时使用class，避免使用id"><a href="#定义样式时使用class，避免使用id" class="headerlink" title="定义样式时使用class，避免使用id"></a>定义样式时使用class，避免使用id</h2><p>这一点，我一开始不知道有什么意义，在深入了解过后觉得是必要的。</p><p>首先这两个属性存在明显的不同：class属性是专为样式准备的，并且可复用；id属性具有当前文档内的唯一性，通常能够起到特殊的作用，比如作为&lt;a&gt;标签的锚点，以及最快地被JavaScript元素节点语法选中。</p><p>因此，id属性通常作为一种具有特殊性的标识，表示本元素可能用作页面锚点，或者代码中需要对该元素执行JavaScript操作。除此之外，不在非必要的时候使用id属性也可以减少出现意外重复的概率。</p><p>总之，使用CSS选择器的时候，如果该本身就需要使用id进行其他操作，就可以使用id选择器，否则尽量不要仅为了定义样式而使用id.</p><hr><h2 id="少使用标签选择器"><a href="#少使用标签选择器" class="headerlink" title="少使用标签选择器"></a>少使用标签选择器</h2><p>从开发者的角度来说，其实使用标签选择器是很方便的。譬如某个div元素中只存在一个img标签，使用[.certain-div img]的选择器就可以最快地选中该img元素。</p><p>但从性能的方面考虑，使用标签选择器可能会带来一些性能影响。CSS选择器的层次逻辑是从右到左执行的，因此越往右边的选择器越影响效率。而标签选择器通常放在较右边，这就使得CSS先选中文档中所有的该标签，再执行上一步的层次查找。标签往往在文档中相比class和id是最多的，因此会影响CSS选择器的效率。</p><p>当然，如果本身就是在文档中比较少使用的标签，自然不会非常影响效率，但div, span等使用频率较高的标签，可以想象对性能影响还是比较大的。</p><p>总的来说，定义样式的时候，如果能使用class，尽量还是避免使用标签选择器。</p><hr><h2 id="Vue框架中v-for列表渲染的key属性是否能使用index"><a href="#Vue框架中v-for列表渲染的key属性是否能使用index" class="headerlink" title="Vue框架中v-for列表渲染的key属性是否能使用index"></a>Vue框架中v-for列表渲染的key属性是否能使用index</h2><p>key属性，是在Vue列表渲染时，被用于唯一标识每一列表项的属性。在列表渲染的机制中起到非常重要的作用。</p><p>首先，在比较简单且静态的列表结构里面，使用index作为key, 或者不使用key, 其实是能够通过依赖默认行为提高性能的。</p><p>但是，以下几种情况无法使用index作为key:</p><ol><li>该列表可能出现顺序变化。譬如需要提供向列表中间插入项的功能，这时会把顺序打乱，原本的标识作用也将产生混乱。这种情况，建议在列表结构中，给每一项增加一个单独的识别码，譬如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;hello1&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;hello2&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>两个及以上的列表渲染作为兄弟节点出现。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in array&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item1, index1) in array1&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为key的作用范围是同一元素下，这种条件下就可能会出现key重复的情况。解决方式是把index和一些字符拼接起来，就可以把两种key区分开。这种方式生成的key实际上也是和index完全相对应的。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in array&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;`a$&#123;index&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item1, index1) in array1&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;`b$&#123;index1&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>跟前辈讨论的时候，她认为为了避免key重复的情况，应该完全不使用index作为key, 尽量拼接字符串。我其实觉得，这种情况在使用简单静态列表的场景下很少出现，只要心里有数就可以用。</p><hr><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>没人爱写注释，我也不爱。听过一种说法，一个条理清晰、命名意义明确、排版舒适的代码胜过各种注释，因此我也一直很努力地在做到，为了不写注释。</p><p>当然，有些注释还是可以一写，大多方便别人，部分方便自己：</p><ol><li><p>公用的方法、变量、组件等。方法的注释推荐使用VSCode拓展koroFileHeader生成模板。如有需要，变量、组件参数建议说明取值范围。</p></li><li><p>文件头注释。也可以使用koroFileHeader生成模板，主要是介绍一下该文件负责的功能。</p></li><li><p>确实复杂，不易看懂的代码部分。如果发现某一段代码可能让未来的自己或别人看不懂，及时写注释。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为我算是比较重视代码质量的一个人，在刚进公司的时候就开始积极地学习团队内的一些开发规范。其中有写在文档里面的，也有同事们在代码审查中提到的；有美观性、易读性方面的，也有性能提升方面的。有时，看到一些开发规范，我无法理解它的意义和必要性，并且觉得非常不方便，便会在网络上寻找相关的资料，以及与同事交流。当然，作为一名前端新人，我个人的考虑其实也有很多不足之处，以下就介绍一下我对一些团队前端开发规范产生的质疑、求证和思考总结。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
    <category term="CSS" scheme="https://marycly.github.io/tags/CSS/"/>
    
    <category term="HTML" scheme="https://marycly.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>各种问题的发现、解决与感想(2)</title>
    <link href="https://marycly.github.io/%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%84%9F%E6%83%B3-2/"/>
    <id>https://marycly.github.io/%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%84%9F%E6%83%B3-2/</id>
    <published>2023-01-04T02:00:03.000Z</published>
    <updated>2023-01-04T08:43:50.627Z</updated>
    
    <content type="html"><![CDATA[<p>目录：</p><ul><li><a href="#CSS-opacity%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E7%99%BE%E5%88%86%E6%AF%94%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98">CSS opacity属性设置百分比会导致生产环境问题</a></li><li><a href="#HTML%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">HTML文件引用在服务器上的路径问题</a></li></ul><span id="more"></span><hr><h2 id="CSS-opacity属性设置百分比会导致生产环境问题"><a href="#CSS-opacity属性设置百分比会导致生产环境问题" class="headerlink" title="CSS opacity属性设置百分比会导致生产环境问题"></a>CSS opacity属性设置百分比会导致生产环境问题</h2><p>在某个项目的测试阶段中，测试人员反馈某个元素没有显示，但是本地开发环境一切正常。在浏览器检查时发现，该元素的opacity属性值被设置为1%，故几乎不可见，但实际代码中设置为70%.</p><p>经过网络查询发现，原来别人也有出现同样的问题，即当opacity属性设置为百分比的时候，打包工具无法正确处理，就会变成1%. 如果使用0.7这样的小数值，便可以正常处理。</p><p>实际上，opacity的值的标准写法就是小数（见MDN Web Doc），但工程中往往写百分比形式也可以正常使用（且符合直觉，通常不透明度的概念经常以百分比表示），然而使用一些打包工具转移到生产环境的时候，就会导致数值错误的问题。希望读者都能够知道这件事情，不要犯类似的错误。</p><hr><h2 id="HTML文件引用在服务器上的路径问题"><a href="#HTML文件引用在服务器上的路径问题" class="headerlink" title="HTML文件引用在服务器上的路径问题"></a>HTML文件引用在服务器上的路径问题</h2><p>有时我们不使用node进行开发和打包，而是直接使用HTML, CSS, JS文件开发和打包。</p><p>在开发阶段，我们在HTML代码中引用文件时通常使用文件的相对路径，如&quot;image/xxx.png&quot;, &quot;css/common.css&quot;，并且可以正常调试。打包到服务器上时，有时会把资源文件和HTML分开存放，有时就保留原始目录结构放在同一个文件夹下。但尽管放在同一个文件夹下，原来的相对路径却无法正常在浏览器中引用了，这是为什么呢？</p><p>因为HTML文件中的相对路径，在浏览器环境下，会引用的实际路径是相对服务器根目录的路径。如HTML代码中引用了&quot;image/xxx.png&quot;，服务器地址是&quot;localhost:8080&quot;, 页面的地址是&quot;localhost:8080/hello/index.html&quot;, 反馈到浏览器中则不是期望的&quot;localhost:8080/hello/image/xxx.png&quot;, 而是&quot;localhost:8080/image/xxx.png&quot;，这样就无法正确地引用到文件了。</p><p>因此，实际部署时正确的引用方式应该是&quot;hello/image/xxx.png&quot;. 实际上是一个相对服务器根目录的绝对路径。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#CSS-opacity%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E7%99%BE%E5%88%86%E6%AF%94%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98&quot;&gt;CSS opacity属性设置百分比会导致生产环境问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#HTML%E6%96%87%E4%BB%B6%E5%BC%95%E7%94%A8%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98&quot;&gt;HTML文件引用在服务器上的路径问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="CSS" scheme="https://marycly.github.io/tags/CSS/"/>
    
    <category term="HTML" scheme="https://marycly.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>各种问题的发现、解决与感想</title>
    <link href="https://marycly.github.io/%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    <id>https://marycly.github.io/%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%91%E7%8E%B0%E3%80%81%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%84%9F%E6%83%B3/</id>
    <published>2022-10-28T03:44:09.000Z</published>
    <updated>2023-01-04T02:26:59.976Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间参与了一个项目的开发，共计超过一个月的时间。工作量其实是非常饱和的，并且在接手各种老旧工程的时候经历了很多奇奇怪怪的问题，有的至今难以解决。特此分享一下在这段项目中发现的一些问题解决方案及感想。</p><p>目录：</p><ul><li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%90%8E%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E5%9C%B0%E5%9D%80%E9%BB%98%E8%AE%A4%E6%98%AF%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">重定向到统一登录页面后，返回的地址默认是网站首页的解决方案</a></li><li><a href="#%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">跨域传输数据的解决方案</a></li><li><a href="#%E6%97%A0%E6%B3%95%E6%9B%B4%E6%94%B9%E6%BA%90%E7%A0%81%E6%97%B6%E9%98%BB%E6%AD%A2%E7%BD%91%E9%A1%B5%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">无法更改源码时阻止网页中默认弹出提示的解决方案</a></li><li><a href="#%E5%AF%B9%E4%BB%98%E5%89%8D%E4%BA%BA%E5%86%99%E7%9A%84%E5%9D%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E6%84%9F%E6%83%B3">对付前人写的坏代码的心得感想</a></li></ul><span id="more"></span><hr><h2 id="重定向到统一登录页面后，返回的地址默认是网站首页的解决方案"><a href="#重定向到统一登录页面后，返回的地址默认是网站首页的解决方案" class="headerlink" title="重定向到统一登录页面后，返回的地址默认是网站首页的解决方案"></a>重定向到统一登录页面后，返回的地址默认是网站首页的解决方案</h2><p>问题描述：网站未登录时重定向到统一登录页面，登录成功自动返回时返回的是网站首页，丢失了后面的路由部分，不能按照预期返回原来的页面。</p><p>解决方式：未登录重定向前，将原先的url（删去携带的用户令牌信息）完整保存在Session Storage（浏览器临时存储）中。在进入网站首页时，检测Session Storage是否保存了url，如果有的话，重定向到该url，并删除存储即可。</p><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向前</span></span><br><span class="line"><span class="keyword">const</span> unsavedHref = <span class="built_in">window</span>.top.location.href <span class="comment">// 获取窗口url</span></span><br><span class="line"><span class="comment">// 我这边加入了删除用户令牌信息的代码（使用正则）</span></span><br><span class="line"><span class="built_in">window</span>.top.sessionStorage.setItem(<span class="string">&#x27;unsavedHref&#x27;</span>, unsavedHref) <span class="comment">// 将url保存在sessionStorage里</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录成功回到网站首页后</span></span><br><span class="line"><span class="keyword">const</span> unsavedHref = <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">&#x27;unsavedHref&#x27;</span>) <span class="comment">// 获取sessionStorage，如果没有则会得到undefined</span></span><br><span class="line"><span class="keyword">if</span> (unsavedHref) &#123;</span><br><span class="line">  <span class="comment">// 如果sessionStorage中存在未保存链接，则恢复</span></span><br><span class="line">  <span class="built_in">window</span>.sessionStorage.removeItem(<span class="string">&#x27;unsavedHref&#x27;</span>) <span class="comment">// 删除存储，这是为了防止后续正常访问首页时也被重定向到存储中的链接</span></span><br><span class="line">  <span class="built_in">window</span>.top.location.href = unsavedHref <span class="comment">// 进行跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="跨域传输数据的解决方案"><a href="#跨域传输数据的解决方案" class="headerlink" title="跨域传输数据的解决方案"></a>跨域传输数据的解决方案</h2><p>问题描述：A页面中存在一定的数据，需要在跨域打开的B页面中获取使用。</p><h3 id="方案一：使用url传参的方式。"><a href="#方案一：使用url传参的方式。" class="headerlink" title="方案一：使用url传参的方式。"></a>方案一：使用url传参的方式。</h3><p>实现方式：A页面跳转到B页面时，在url中拼接?data=&lt;…&gt;形式的参数。B页面启动时，获取到url中的参数即可。</p><p>优点：速度快，B页面启动后立刻能获取到。</p><p>缺点：数据过长的时候，url长度可能会被浏览器限制。</p><h3 id="方案二：使用window-postMessage方法。"><a href="#方案二：使用window-postMessage方法。" class="headerlink" title="方案二：使用window.postMessage方法。"></a>方案二：使用window.postMessage方法。</h3><p>技术前提：使用window.open打开页面时，A页面可获取到B页面的窗口对象，B页面也可通过window.opener获取到A页面的窗口对象。</p><p>具体过程：B页面加载完成并绑定监听器后，先发送消息告知A页面；A页面接收到消息后，向B页面发送消息传递数据；B页面接收到消息后，则根据消息中的数据执行操作。</p><p>优点：无需考虑数据的长度限制。</p><p>缺点：异步操作，需要一定时间才能完成；A、B页面都需要明确对方的源地址；需要A页面保持开启才会发送数据。</p><p>代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A页面 - 打开B页面前</span></span><br><span class="line"><span class="keyword">const</span> nextOrigin = <span class="string">&#x27;https://marycly.github.io&#x27;</span> <span class="comment">// B页面的源地址</span></span><br><span class="line"><span class="keyword">const</span> nextUrl = <span class="string">&#x27;https://marycly.github.io/archives/&#x27;</span> <span class="comment">// B页面的完整打开地址</span></span><br><span class="line"><span class="keyword">const</span> parseValue = <span class="string">&#x27;hello&#x27;</span> <span class="comment">// 要传递的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.origin.includes(nextOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 任何消息监听器里都应该加上这个判断，不仅可以区分不同地址发来的消息所产生的不同效果，也可以防止未知网站的消息攻击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.receiveMessageTimeout) &#123;</span><br><span class="line">    <span class="built_in">window</span>.clearTimeout(<span class="built_in">this</span>.receiveMessageTimeout)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.receiveMessageTimeout = <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nextPage.postMessage(parseValue, nextOrigin) <span class="comment">// 这是最终会干的事情，向B页面发送数据</span></span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">  <span class="comment">// 这里小小做了一个0.5s延时的消抖，防止消息重复发送</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">this</span>.nextPage = <span class="built_in">window</span>.open(nextUrl) <span class="comment">// 然后打开B页面，并保存窗口对象到变量中，便于监听器调用</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B页面 - 加载完成后</span></span><br><span class="line"><span class="keyword">const</span> lastOrigin = <span class="string">&#x27;https://anyone.hello&#x27;</span> <span class="comment">// A页面的源地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!e.origin.includes(lastOrigin)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 任何消息监听器里都应该加上这个判断，不仅可以区分不同地址发来的消息所产生的不同效果，也可以防止未知网站的消息攻击</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用e.data干任何事！</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.data)</span><br><span class="line">  <span class="built_in">this</span>.lastPageData = e.data</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> lastPage = <span class="built_in">window</span>.opener <span class="comment">// 通过opener获取A页面的窗口对象</span></span><br><span class="line">lastPage.postMessage(<span class="string">&#x27;I am all okay!&#x27;</span>, lastOrigin) <span class="comment">// 向A页面表示你已经准备好接收数据了</span></span><br></pre></td></tr></table></figure><hr><h2 id="无法更改源码时阻止网页中默认弹出提示的解决方案"><a href="#无法更改源码时阻止网页中默认弹出提示的解决方案" class="headerlink" title="无法更改源码时阻止网页中默认弹出提示的解决方案"></a>无法更改源码时阻止网页中默认弹出提示的解决方案</h2><p>问题描述：工程所使用的一个依赖包中有这样一个逻辑，提交数据成功时会默认弹出一个提示（element-ui的message组件）。现需要阻止该提示，但依赖包的内容难以直接更改。</p><p>解决方式：获取该message组件弹窗显示的元素类名，在弹窗出现时使用querySelector找到该元素，并移除它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector(&#x27;.el-message&#x27;).remove()</span><br></pre></td></tr></table></figure><hr><h2 id="对付前人写的坏代码的心得感想"><a href="#对付前人写的坏代码的心得感想" class="headerlink" title="对付前人写的坏代码的心得感想"></a>对付前人写的坏代码的心得感想</h2><p>当接手某个工程的时候，有时会发现一些不规范的，逻辑错误的，或是造成了全局性不良污染的代码。我认为比较合适的处理方式如下：</p><ol><li><p>首先，需要仔细评估该段代码的影响范围。如果牵涉的范围非常大，且依赖于该代码的功能都能够正常运行，则不应轻易更改，而考虑使用局部重写的方式解决问题。</p></li><li><p>然后，需要理解该段代码的意义和作用，确定自己的更改是否100%不影响原先的功能。如果不确定，尝试跟原开发者联系确认。</p></li><li><p>如果影响范围较小且能确保不影响逻辑，或者影响范围只有正在开发的当前页面或模块，便可以进行修改。修改后必须要经过反复的自测验证，保证功能正常运作。</p></li><li><p>有时某段有问题的代码会随着工程体量的增加而积重难返，这时大概率是要对它妥协，将就总比意外好。</p></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>再也不想加班和直面屎山了！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间参与了一个项目的开发，共计超过一个月的时间。工作量其实是非常饱和的，并且在接手各种老旧工程的时候经历了很多奇奇怪怪的问题，有的至今难以解决。特此分享一下在这段项目中发现的一些问题解决方案及感想。&lt;/p&gt;
&lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%90%8E%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E5%9C%B0%E5%9D%80%E9%BB%98%E8%AE%A4%E6%98%AF%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;重定向到统一登录页面后，返回的地址默认是网站首页的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;跨域传输数据的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%97%A0%E6%B3%95%E6%9B%B4%E6%94%B9%E6%BA%90%E7%A0%81%E6%97%B6%E9%98%BB%E6%AD%A2%E7%BD%91%E9%A1%B5%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%BC%B9%E5%87%BA%E6%8F%90%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot;&gt;无法更改源码时阻止网页中默认弹出提示的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%B9%E4%BB%98%E5%89%8D%E4%BA%BA%E5%86%99%E7%9A%84%E5%9D%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%BF%83%E5%BE%97%E6%84%9F%E6%83%B3&quot;&gt;对付前人写的坏代码的心得感想&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JS" scheme="https://marycly.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>一些使用UI组件库的经验</title>
    <link href="https://marycly.github.io/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    <id>https://marycly.github.io/%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8UI%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E7%BB%8F%E9%AA%8C/</id>
    <published>2022-08-24T08:58:36.000Z</published>
    <updated>2022-08-24T09:25:39.006Z</updated>
    
    <content type="html"><![CDATA[<p>近期进行前端开发的过程中，接触了一些比较全面方便的UI库，有Ant Design Vue, 以及Vant. 这些UI库使用起来比自己造零件要方便且美观，不过在初使用的过程中也会遇到一些比较疑惑的问题，因此写下本文记录一下使用这些UI组件库所积累的一些经验。</p><span id="more"></span><h2 id="主题定制"><a href="#主题定制" class="headerlink" title="主题定制"></a>主题定制</h2><p>通常来说，UI组件库都提供全局的主题定制的功能，如某个组件的默认颜色或整体的颜色风格等，一般可以在官网找到更改方式，譬如Ant Design Vue 3的主题定制方式就在<a href="https://antdv.com/docs/vue/customize-theme-cn">定制主题 - Ant Design Vue</a>. Vue项目通常需要修改全局选项文件。</p><h2 id="调整内部样式"><a href="#调整内部样式" class="headerlink" title="调整内部样式"></a>调整内部样式</h2><p>在使用UI组件库的过程中，有时候需要调整个别组件的样式，而不改变全局的UI库参数。如果直接打开浏览器的开发者检查工具，可以看到UI库组件的内部存在一些class, 它们定义了那些你不想要的样式。这种时候，如果在源代码中直接用类名选择器设置这些class的样式，会发现并没有效果。这种时候，使用/deep/ .target-class 的选择器来定义你需要更改的样式，就能起到效果（LESS预编译语言下）。有一篇类似情况的文章可供参考：<a href="https://www.jianshu.com/p/5bd38a4d4d64">&gt;&gt;&gt;或/deep/的作用</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期进行前端开发的过程中，接触了一些比较全面方便的UI库，有Ant Design Vue, 以及Vant. 这些UI库使用起来比自己造零件要方便且美观，不过在初使用的过程中也会遇到一些比较疑惑的问题，因此写下本文记录一下使用这些UI组件库所积累的一些经验。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
    <category term="CSS" scheme="https://marycly.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue router中params和query的区别</title>
    <link href="https://marycly.github.io/Vue-router%E4%B8%ADparams%E5%92%8Cquery%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://marycly.github.io/Vue-router%E4%B8%ADparams%E5%92%8Cquery%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-08-19T02:15:05.000Z</published>
    <updated>2022-08-24T09:03:10.351Z</updated>
    
    <content type="html"><![CDATA[<p>在vue开发中，页面跳转时常需要传递一些参数。如果我们使用vue router来进行路由，通常有两种方式进行参数的传递，一种是使用params, 一种是使用query. 在下文中我将介绍一下个人使用中感受到的这两者的区别。</p><span id="more"></span><h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><p>如果在url中定义了params的绑定，则可以直接在url中传递params(&#39;/articles/:id&#39;), 否则只能通过vue router的方法（router-link或$router.push等）传递路径对象时添加params. params可以直接传递值和对象，并且定义了router中的props属性后，能在页面中通过props属性去获取。如果不通过props, 也可以使用this.$route.params获取。</p><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>query既可以直接在url后添加(&#39;marycly.github.io/index?pageId=114514&#39;), 也可以通过vue router的方法传递路径对象时添加query. query可以传递值，但传递对象效果不稳定，最好将传递的对象通过JSON来保存。在页面中可以使用this.$route.query来获取query的内容。</p><h3 id="在页面跳转中的实际应用表现"><a href="#在页面跳转中的实际应用表现" class="headerlink" title="在页面跳转中的实际应用表现"></a>在页面跳转中的实际应用表现</h3><p>如果url中没有定义与params绑定的动态路由，个人不建议使用params来传递信息。因为这种情况下url里面并不包含params的信息，在浏览器历史前进/回退的过程中就会丢失，因此只能实现一个单向的传递。如果需要支持时常在页面之间跳转并保留信息的话，建议使用query.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在vue开发中，页面跳转时常需要传递一些参数。如果我们使用vue router来进行路由，通常有两种方式进行参数的传递，一种是使用params, 一种是使用query. 在下文中我将介绍一下个人使用中感受到的这两者的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>邮箱系统界面设计</title>
    <link href="https://marycly.github.io/%E9%82%AE%E7%AE%B1%E7%B3%BB%E7%BB%9F%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/"/>
    <id>https://marycly.github.io/%E9%82%AE%E7%AE%B1%E7%B3%BB%E7%BB%9F%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-08-12T07:48:50.000Z</published>
    <updated>2022-08-24T09:02:51.429Z</updated>
    
    <content type="html"><![CDATA[<p>谨以本文记录2022年7月入职科大讯飞后，作为培训的一部分参加的编程大赛。</p><p>因为项目要求队员中至少一位有TCP编程经验，原本小组中的两位前端之一（自然不是我）被分配到其他小组了，而新分配进来的这位是一个Android开发工程师，并没有Vue开发经验（比赛要求使用Vue框架进行开发）。因此，所有的前端开发工作便由我一个人完成。因为前端部分代码完全由我独立开发，因此作为个人成果发布于<a href="https://github.com/MaryCLY/mail-system-ui">GitHub</a>供公开交流学习。</p><span id="more"></span><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="登录-注册界面"><a href="#登录-注册界面" class="headerlink" title="登录/注册界面"></a>登录/注册界面</h3><p>登录/注册的过程又被分为两个步骤：第一个步骤是输入用户名并点击“下一步”，这时系统会检测用户名是否已注册，从而将用户转入登录或注册页面。而第二个步骤则是输入密码，其中需要注册的用户将被要求重复输入密码，而登录的用户只需输入一次。在这个过程中，前端包含用户名与密码的格式检测。</p><p>点击确认后，系统请求后端是否注册/登录成功，如果失败弹出错误提示，反之则弹出成功提示，并将页面转入主页。</p><h3 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h3><p>主页提供查看邮件以及写新邮件的功能。其中查看邮件的内容分为收件箱和发件箱，邮件列表提供分页功能，点击列表中的邮件标题进入邮件详情。</p><p>写邮件的功能采用按钮+模态弹窗的形式实现。因为开发时采用的富文本编辑器出现bug难以修复，只提供了输入纯文本的功能。未支持上传附件。</p><p>头部提供退出登录按钮。</p><h2 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h2><p>系统使用Vite+Vue 3进行前端开发。</p><h2 id="部分细节"><a href="#部分细节" class="headerlink" title="部分细节"></a>部分细节</h2><p>交付时的版本，只使用点击来切换sider中的选项卡，而复杂的操作下会出现bug. 之后进行了一定的优化，使用vuex state来管理当前处于的页面，从而保证sider的选项正确。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;谨以本文记录2022年7月入职科大讯飞后，作为培训的一部分参加的编程大赛。&lt;/p&gt;
&lt;p&gt;因为项目要求队员中至少一位有TCP编程经验，原本小组中的两位前端之一（自然不是我）被分配到其他小组了，而新分配进来的这位是一个Android开发工程师，并没有Vue开发经验（比赛要求使用Vue框架进行开发）。因此，所有的前端开发工作便由我一个人完成。因为前端部分代码完全由我独立开发，因此作为个人成果发布于&lt;a href=&quot;https://github.com/MaryCLY/mail-system-ui&quot;&gt;GitHub&lt;/a&gt;供公开交流学习。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Vue" scheme="https://marycly.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Pow(x, n)%10 （快速幂+大数取模问题）</title>
    <link href="https://marycly.github.io/Pow-x-n-10-%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <id>https://marycly.github.io/Pow-x-n-10-%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1%E9%97%AE%E9%A2%98%EF%BC%89/</id>
    <published>2021-08-29T15:13:10.000Z</published>
    <updated>2022-08-24T09:03:04.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。</p><p>任何数的0次方都是1.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>不难发现规律： ((x%y)^n)%y = (x^n)%y</p><span id="more"></span><p>因此很容易想到，第一步先把题目中的底数x提取成最后一位。但如果直接用编程语言库里自带的Math.pow(x, n)，依然可能会直接得到一个很大的结果，取模依然可能不正确。因此，我们需要考虑自己实现一套幂运算，在过程中多次取最后一位，这样就会使得所有的运算都是小数取模了。</p><p>快速幂公式参考<a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/">LeetCode 50. Pow(x, n) （快速幂，清晰图解）-Krahets</a></p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>根据观察不难发现，0-9为底的幂运算取最后一位是存在一个循环的。我们先求出这个循环的规律，然后判断n是在循环的第几位，即可直接得到结果。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>由于Javascript BigInt过于复杂，没有实现x, y为大数时的算法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight javascript"><figcaption><span>公用方法.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mod10</span>(<span class="params"> num </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(num) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>思路1.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastDigitQuickPow</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = mod10(str1); <span class="comment">// x直接取最后一位</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(str2); <span class="comment">// 可能涉及大数，转成BigInt</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 任何数的0次方都是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = x; n; i = mod10(i * i), n = n &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 每次使i平方，然后n减少一位二进制位（位右移）</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res = mod10(res * i); <span class="comment">// 如果当前位是1，则在结果中增加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>思路2.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lastDigit</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = mod10(str1); <span class="comment">// x直接取最后一位</span></span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>(str2); <span class="comment">// 可能涉及大数，转成BigInt</span></span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 任何数的0次方都是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> loopCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> loopNum = [x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = x; <span class="literal">true</span>;) &#123;</span><br><span class="line">        i = mod10(i * x); <span class="comment">// 查找循环的下一位</span></span><br><span class="line">        loopCount++;</span><br><span class="line">        <span class="keyword">if</span> (i === x) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 得到循环的总长度loopCount和取余对应loopNum[]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loopNum.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> resMod = (n - <span class="number">1</span>) % loopCount; <span class="comment">// 获取循环中的余数（左移一位）</span></span><br><span class="line">    <span class="keyword">return</span> loopNum[resMod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定2个非负整数x, n, 需要求 x^n （x的n次方）的最后一位。 x, n都可能很大很大。&lt;/p&gt;
&lt;p&gt;任何数的0次方都是1.&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;h3 id=&quot;思路1&quot;&gt;&lt;a href=&quot;#思路1&quot; class=&quot;headerlink&quot; title=&quot;思路1&quot;&gt;&lt;/a&gt;思路1&lt;/h3&gt;&lt;p&gt;不难发现规律： ((x%y)^n)%y = (x^n)%y&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JS" scheme="https://marycly.github.io/tags/JS/"/>
    
    <category term="算法" scheme="https://marycly.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="快速幂" scheme="https://marycly.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="大数越界" scheme="https://marycly.github.io/tags/%E5%A4%A7%E6%95%B0%E8%B6%8A%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>JS: Union-find(quick-union + weighting + path compression + map)</title>
    <link href="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/"/>
    <id>https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/</id>
    <published>2021-08-20T01:52:59.000Z</published>
    <updated>2022-08-24T09:02:57.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。</p><h3 id="用于解决的问题"><a href="#用于解决的问题" class="headerlink" title="用于解决的问题"></a>用于解决的问题</h3><p>假定一个学校的圈子中，有A,B,C...这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。</p><h3 id="核心的方法需求"><a href="#核心的方法需求" class="headerlink" title="核心的方法需求"></a>核心的方法需求</h3><p>Union(p, q): 将点p和点q建立连接的方法。</p><p>Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。</p><span id="more"></span><h2 id="基本构建思路"><a href="#基本构建思路" class="headerlink" title="基本构建思路"></a>基本构建思路</h2><h3 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick-Find"></a>Quick-Find</h3><p>这是最大化搜索效率的思路。在进行Union的时候会让所有的节点保存root（根节点），每次连接的时候为连通的节点设置同一个root，这样find时只需要读取root这个值即可。</p><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qf1.png" alt="quick-find图解"></p><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qf2.png" alt="quick-find代码"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果一条很长的链被合并，可能需要大量地改变root值。</p><h3 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick-Union"></a>Quick-Union</h3><p>这是最大化合并效率的思路。在进行Union时只保存上级节点，这样find的时候一直追溯到根节点，也能判断是否在同个子集。</p><p>此时使用类似链表的数据结构十分恰当。</p><h4 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qu1.png" alt="quick-union图解"></p><h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/qu2.png" alt="quick-union代码"></p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>如果有一条很长的链，查找效率会很低。</p><h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><h4 id="共通点"><a href="#共通点" class="headerlink" title="共通点"></a>共通点</h4><p>不管是quick-find还是quick-union，算法中都有这样的共通点：</p><p>1.每次union时会判断是否同根，如果是则直接跳过。</p><p>2.在进行两个子集的union时，会连接两个子集的root。</p><h4 id="时间复杂度比较"><a href="#时间复杂度比较" class="headerlink" title="时间复杂度比较"></a>时间复杂度比较</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/compare.png" alt="时间复杂度比较"></p><p>因为quick-union每次都要查找，所以在最坏情况下合并的效率跟quick-find拥有相同的复杂度，但好的情况下合并的效率会大大提高。</p><p>由于quick-union的方法更优雅，我们接下来会采用quick-union并尝试优化。</p><h2 id="Quick-Union算法的优化"><a href="#Quick-Union算法的优化" class="headerlink" title="Quick-Union算法的优化"></a>Quick-Union算法的优化</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>因为所有的节点都有唯一的id，在我的算法中相比书中使用数组会选择使用HashMap保存节点，这样能够提高索引效率。同时，因为每个节点只有唯一的parent，而可能有多个child，且find过程中也只是追溯parent，所以只单向保存parent的id。</p><p>结构：{key: id, value: parent_id}</p><h3 id="Weighting"><a href="#Weighting" class="headerlink" title="Weighting"></a>Weighting</h3><p>Weighting，即平衡重量。基本思路是判断两个要合并的root的child数量，将小的合并到大的，这样可以避免生成长子链，然后提高查找效率。</p><h4 id="图解-2"><a href="#图解-2" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/weighting.png" alt="weighting图解"></p><h4 id="代码变动"><a href="#代码变动" class="headerlink" title="代码变动"></a>代码变动</h4><p>由于每个节点只保存了parent，故无法追溯child的长度，因此每个节点新增一个size属性，每次union时将child以及其对应的子集size合并到该节点的size中。</p><p>map结构变化: {key: id, value: {parent: parent_id, size: size}}</p><p>union时： map.get([要合并的parent]).size+=map.get([被合并的child]).size +1 //+1是child本身</p><h3 id="Path-Compression"><a href="#Path-Compression" class="headerlink" title="Path Compression"></a>Path Compression</h3><p>Path Compression，即路径压缩。基本思路是在每次合并的时候直接将child（的root）合并到parent的root上，这样也可以避免生成长子链。</p><h4 id="图解-3"><a href="#图解-3" class="headerlink" title="图解"></a>图解</h4><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/path-compression.jpg" alt="path-compression图解"></p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>quick-union + weighting + path compression + map</p><figure class="highlight javascript"><figcaption><span>Union-Find.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个节点保存的结构</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">parent, size</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent || <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.size = size || <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">union</span>(<span class="params">p, q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(p)||!map.has(q))&#123;</span><br><span class="line">        <span class="comment">//有一个不在map里，说明是游离节点，自动设为child</span></span><br><span class="line">        <span class="keyword">if</span>(!map.has(p))&#123;</span><br><span class="line">            <span class="keyword">var</span> child = p, parent = find(q); <span class="comment">//path compression 父母直接设给根节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> child = q, parent = find(p);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(child, <span class="keyword">new</span> Node(parent, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//均存在map中，需要进行weighting的两个节点</span></span><br><span class="line">        <span class="keyword">const</span> pr = find(p), qr = find(q), prs = map.get(pr).size, qrs = map.get(qr).size; <span class="comment">//暂存两个节点的root</span></span><br><span class="line">        <span class="keyword">if</span>(pr===qr)&#123;</span><br><span class="line">            <span class="comment">//如果已经连通，不需要再连接了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prs &lt; qrs)&#123;</span><br><span class="line">            <span class="comment">//把容量更小的那个设为child被合并</span></span><br><span class="line">            <span class="keyword">var</span> child = pr, parent = qr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> child = qr, parent = pr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//root应该都存在map中</span></span><br><span class="line">        map.get(child).parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(parent))&#123;</span><br><span class="line">        map.set(parent, <span class="keyword">new</span> Node(parent, map.get(child).size+<span class="number">1</span>)); <span class="comment">//map中新建一个root node，root的parent设给自己</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.get(parent).size+=map.get(child).size+<span class="number">1</span>; <span class="comment">//合并size</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!map.has(p))&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(map.get(p).parent!=p)&#123;</span><br><span class="line">        <span class="comment">//如果parent等于自己，说明已经是根节点了，否则再往上追溯一个parent</span></span><br><span class="line">        p = map.get(p).parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isConnected</span>(<span class="params">p, q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (find(p)===find(q));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最后贴上algorithms书中的各种方法的时间复杂度：</p><p><img src="https://marycly.github.io/JS-Union-find-quick-union-weighting-path-compression-map/compare-final.png" alt="时间复杂度比较"></p><p>有weighting和path compression的quick union时间复杂度无限接近1。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Union-find，合并-查找，这个算法是在学习Algorithms这本书的时候看到的。&lt;/p&gt;
&lt;h3 id=&quot;用于解决的问题&quot;&gt;&lt;a href=&quot;#用于解决的问题&quot; class=&quot;headerlink&quot; title=&quot;用于解决的问题&quot;&gt;&lt;/a&gt;用于解决的问题&lt;/h3&gt;&lt;p&gt;假定一个学校的圈子中，有A,B,C...这些人，而A,B存在联系，B,C存在联系，若要寻找A,C是否存在联系，只要存在B这个媒介，那么就说明有联系。为了建立这样的关系网，把存在联系的人连接合并成集合，这样在判断联系时，只需要判断是否存在这个集合里即可。抽象地说，就是在一个图中划分出连通子图。&lt;/p&gt;
&lt;h3 id=&quot;核心的方法需求&quot;&gt;&lt;a href=&quot;#核心的方法需求&quot; class=&quot;headerlink&quot; title=&quot;核心的方法需求&quot;&gt;&lt;/a&gt;核心的方法需求&lt;/h3&gt;&lt;p&gt;Union(p, q): 将点p和点q建立连接的方法。&lt;/p&gt;
&lt;p&gt;Find(p): 寻找点p所在的子集。通常用Find(p)==Find(q)来判断p和q具有连通性。&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="JS" scheme="https://marycly.github.io/tags/JS/"/>
    
    <category term="算法" scheme="https://marycly.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于我如何艰难地在公司业务中实现侧滑置顶删除功能（二）</title>
    <link href="https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-08-18T08:35:47.000Z</published>
    <updated>2022-08-24T09:02:07.318Z</updated>
    
    <content type="html"><![CDATA[<p>上一章内容：<a href="/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89">关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</a></p><p>原代码不再贴出。</p><h2 id="新的工程需求"><a href="#新的工程需求" class="headerlink" title="新的工程需求"></a>新的工程需求</h2><p>上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：</p><p>不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。</p><h2 id="初步想法：阻止手势穿透"><a href="#初步想法：阻止手势穿透" class="headerlink" title="初步想法：阻止手势穿透"></a>初步想法：阻止手势穿透</h2><p>微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？</p><span id="more"></span><h2 id="尝试：将bind换成catch"><a href="#尝试：将bind换成catch" class="headerlink" title="尝试：将bind换成catch"></a>尝试：将bind换成catch</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;touchStart&quot; catchtouchmove=&quot;touchMove&quot;&gt;</span><br><span class="line">&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>可以是可以阻止滚动，但结果带来了其他的麻烦，因为catch也阻止了上下滑动触发页面滚动的手势，所以如果有很多内容，手势会被限制在某条组件内，页面就动不了了。</p><h2 id="尝试：使bind和catch的事件根据isTouchMove进行变化"><a href="#尝试：使bind和catch的事件根据isTouchMove进行变化" class="headerlink" title="尝试：使bind和catch的事件根据isTouchMove进行变化"></a>尝试：使bind和catch的事件根据isTouchMove进行变化</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot; </span><br><span class="line">    bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>但是没有用，微信小程序并不能同时使用bind和catch两种属性，只会取其一。之后想想，这样的思路也不对，传空的事件名并不会使得事件解绑，而是引发了一个空的函数。</p><h2 id="尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个"><a href="#尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个" class="headerlink" title="尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个"></a>尝试：建立两个一模一样但分别是bind和catch的组件，然后根据isTouchMove的值选择显示哪一个</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:if=&quot;&#123;&#123;!item.isTouchMove&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><p>效果是可行，但是会牺牲滑出和收起菜单的动画效果，因为通过css实现的动画效果只能在同一个组件中进行。</p><h2 id="最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换"><a href="#最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换" class="headerlink" title="最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换"></a>最终方案：建立两个一模一样但分别是bind和catch的组件，在每次动画结束后悄悄替换</h2><p>绞尽脑汁之后，突然灵机一动想到了这样一个比较邪教的方法。</p><p>思路：设置一个hidden属性（用来标记被划开菜单的条目，即需要设成catch的条目的index），在每次动画开始时进行setTimeOut设定延时，等待动画完毕后渲染hidden，根据hidden的值悄悄将所有条目替换成catch或bind的组件。</p><p>注意：css中，动画设定是0.4s，延时应当适当小于这个值。</p><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;!-- 一个是没有被打开菜单的（支持上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:if=&quot;&#123;&#123;index!==hidden&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchstart&#x27;&#125;&#125;&quot; bindtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;&#x27; : &#x27;touchmove&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;!-- 被打开菜单的（阻止上下滑动和返回） --&gt;</span><br><span class="line">    &lt;view wx:else class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchstart=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchstart&#x27; : &#x27;&#x27;&#125;&#125;&quot; catchtouchmove=&quot;&#123;&#123;item.isTouchMove ? &#x27;touchmove&#x27; : &#x27;&#x27;&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;!-- 内容 --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Page */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">dataList</span>: [<span class="comment">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class="line">    <span class="attr">startX</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">startY</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">null</span>,<span class="comment">//标记被隐藏的块index</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">touchStart</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataList = <span class="built_in">this</span>.data.dataList;</span><br><span class="line">    dataList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.isTouchMove) &#123;</span><br><span class="line">        item.isTouchMove = !item.isTouchMove;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.data.hidden = <span class="literal">null</span>; <span class="comment">//先把hidden置null, 但不渲染</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.data.startX = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">    <span class="built_in">this</span>.data.startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">touchMove</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> moveX = e.changedTouches[<span class="number">0</span>].clientX,</span><br><span class="line">      moveY = e.changedTouches[<span class="number">0</span>].clientY,</span><br><span class="line">      curIndex = e.currentTarget.dataset.index, </span><br><span class="line">      dataList = <span class="built_in">this</span>.data.dataList,</span><br><span class="line">      angle = <span class="built_in">this</span>.angle(</span><br><span class="line">        &#123; <span class="attr">X</span>: <span class="built_in">this</span>.data.startX,</span><br><span class="line">    <span class="attr">Y</span>: <span class="built_in">this</span>.data.startY</span><br><span class="line">    &#125;, &#123; <span class="attr">X</span>: moveX,</span><br><span class="line">    <span class="attr">Y</span>: moveY</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span>; <span class="comment">//用于在forEach函数里访问data</span></span><br><span class="line">    dataList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (curIndex === index &amp;&amp; angle &lt; <span class="number">30</span> &amp;&amp; moveX &lt; <span class="built_in">this</span>.data.startX) &#123;</span><br><span class="line">        item.isTouchMove = <span class="literal">true</span>;</span><br><span class="line">        that.data.hidden = index;<span class="comment">//如果有块被滑动，将hidden设为此块，否则就会保持在null</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      item.isTouchMove = <span class="literal">false</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    setTimeOut(&#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        <span class="attr">hidden</span>: that.data.hidden <span class="comment">//0.3s后渲染hidden来替换组件，此时动画基本放完了</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>经检验，如果动画设在0.3s，对于快速滑动也能比较好地适应。既保证了动画的流畅性，又保证了接管手势，不触发意外返回。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，这个功能总算是顺利完成。虽然性能问题可能有待商榷（因为要进行大量的if else），但是目前来说是没有想出更好的解决方法。我感觉这个功能对我来说还是比较有锻炼性的，如果另辟蹊径也能达到目的的话，不妨大胆尝试。如有更好的想法，欢迎在评论区留言。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一章内容：&lt;a href=&quot;/2021/08/16/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89&quot;&gt;关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原代码不再贴出。&lt;/p&gt;
&lt;h2 id=&quot;新的工程需求&quot;&gt;&lt;a href=&quot;#新的工程需求&quot; class=&quot;headerlink&quot; title=&quot;新的工程需求&quot;&gt;&lt;/a&gt;新的工程需求&lt;/h2&gt;&lt;p&gt;上次算是做出来一个像样的侧滑置顶删除功能了，在微信小程序调试中以及安卓机上调试都没有问题，但在iOS测试机上运行时却出现了问题：&lt;/p&gt;
&lt;p&gt;不知道是因为这个APP在iOS端上的一个整体功能还是微信小程序原生的触发，在右滑取消菜单的时候会触发一个返回到上级页面的操作……着实是让人不解。理论上，iOS原生的返回手势只有在手指接近屏幕左侧且右滑的时候才会触发。事实上，这个APP的另一个模块也有类似的侧滑删除功能，且右滑该条消息取消菜单时不会触发返回。于是mentor带我去请教了负责这块的iOS开发大哥，他表示：可以尝试在右滑取消时接管手势，但是微信小程序如何实现他也不知道。&lt;/p&gt;
&lt;h2 id=&quot;初步想法：阻止手势穿透&quot;&gt;&lt;a href=&quot;#初步想法：阻止手势穿透&quot; class=&quot;headerlink&quot; title=&quot;初步想法：阻止手势穿透&quot;&gt;&lt;/a&gt;初步想法：阻止手势穿透&lt;/h2&gt;&lt;p&gt;微信小程序的事件有着冒泡机制，而手势则是整个窗口的一些事件（具体事件为tap, touchstart, touchmove, touchend, touchcancel等）。在wxml代码中进行事件捕捉时，需要设定组件的属性catchtap/bindtap, catchtouchstart/bindtouchstart等，这些都是用来捕捉微信小程序原生事件的属性。catch和bind的区别则是，catch会阻止事件冒泡，而bind不会。也就是说，只要设置catchtap，tap事件就会被局限在这个组件上，在它之后可能会收到事件的父组件、子组件都无法收到这个事件了。所以，如果对消息条组件设置catchtap，会不会就能够阻止页面返回呢？&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="微信小程序" scheme="https://marycly.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于我如何艰难地在公司业务中实现侧滑置顶删除功能（一）</title>
    <link href="https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-08-16T03:14:19.000Z</published>
    <updated>2022-08-24T09:02:22.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工程需求"><a href="#工程需求" class="headerlink" title="工程需求"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端APP。</p><p>在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。</p><h2 id="方案参考"><a href="#方案参考" class="headerlink" title="方案参考"></a>方案参考</h2><p>由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。</p><p>参考链接：<a href="https://blog.csdn.net/LiaoFengJi/article/details/105218664">https://blog.csdn.net/LiaoFengJi/article/details/105218664</a></p><span id="more"></span><h2 id="提炼代码如下："><a href="#提炼代码如下：" class="headerlink" title="提炼代码如下："></a>提炼代码如下：</h2><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; class=&quot;item &#123;&#123;item.isTouchMove ? &#x27;touch-move-active&#x27; : &#x27;&#x27;&#125;&#125;&quot; bindtouchstart=&quot;touchStart&quot; bindtouchmove=&quot;touchMove&quot;&gt;</span><br><span class="line">&lt;!-- 这里原本bindtouchstart和bindtouchmove是放在内容的组件里（item-left)，但因为我的按钮做得比较大所以设成了整个组件都可以滑动，使得整条内容上都可以右滑关闭菜单 --&gt;</span><br><span class="line">&lt;view class=&quot;item-left&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;</span><br><span class="line">&lt;!-- 每条要显示的内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;item-right&quot;&gt;</span><br><span class="line">&lt;view class=&quot;btn-right&quot; bindtap=&quot;setTopItem&quot;&gt;置顶&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;btn-right&quot; bindtap=&quot;deleteItem&quot;&gt;删除&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>index.wxss</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 内容部分 */</span><br><span class="line">.item-left &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  margin-left: -400rpx; /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  -webkit-transition: all 0.4s;</span><br><span class="line">  transition: all 0.4s;</span><br><span class="line">  -webkit-transform: translateX(400rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度*/</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 按钮部分 */</span><br><span class="line">.item-right &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  width: 400rpx; /*根据需要调整*/</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class="line">  -webkit-transition: all 0.4s;</span><br><span class="line">  transition: all 0.4s;</span><br><span class="line">  -webkit-transform: translateX(420rpx); /*rpx根据需要调整，具体数值为按钮部分的宽度多一些*/</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btn-right &#123;</span><br><span class="line">  width: 50%; /*这里根据自己的需要划成了两半*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 向左滑动 */</span><br><span class="line">.touch-move-active .item-left,</span><br><span class="line">.touch-move-active .item-right &#123;</span><br><span class="line">  /*关键代码*/</span><br><span class="line">  -webkit-transform: translateX(0);</span><br><span class="line">  transform: translateX(0);</span><br><span class="line">  /*关键代码*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Page */</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">dataList</span>: [<span class="comment">/*存放的数据，每条中应有一个默认为false的属性isTouchMove*/</span>],</span><br><span class="line">    <span class="attr">startX</span>: <span class="number">0</span>,<span class="comment">// 设置开始的位置X</span></span><br><span class="line">    <span class="attr">startY</span>: <span class="number">0</span>,<span class="comment">// 设置开始的位置Y</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始滑动</span></span><br><span class="line">  <span class="function"><span class="title">touchStart</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dataList = <span class="built_in">this</span>.data.dataList;</span><br><span class="line">    dataList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 让原先滑动的块隐藏</span></span><br><span class="line">      <span class="keyword">if</span> (item.isTouchMove) &#123;</span><br><span class="line">        item.isTouchMove = !item.isTouchMove;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      <span class="attr">dataList</span>: dataList,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 初始化开始位置</span></span><br><span class="line">    <span class="built_in">this</span>.data.startX = e.touches[<span class="number">0</span>].clientX;</span><br><span class="line">    <span class="built_in">this</span>.data.startY = e.touches[<span class="number">0</span>].clientY;</span><br><span class="line"><span class="comment">// 在参考代码中，这里全部都setData了，但实际上startX, Y属于没有涉及渲染的纯数据，尽量不要用setData</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="comment">// 滑动的过程</span></span><br><span class="line">  <span class="function"><span class="title">touchMove</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> moveX = e.changedTouches[<span class="number">0</span>].clientX,</span><br><span class="line">      moveY = e.changedTouches[<span class="number">0</span>].clientY,</span><br><span class="line">      curIndex = e.currentTarget.dataset.index, </span><br><span class="line">      <span class="comment">//注意，wxml里面一定要设置data-index=&quot;&#123;&#123;index&#125;&#125;&quot;,这样e.currentTarget.dataset中才会传index的值</span></span><br><span class="line">      dataList = <span class="built_in">this</span>.data.dataList,</span><br><span class="line">      <span class="comment">// 拿到滑动的角度，判断是否大于 30°，若大于，则不滑动</span></span><br><span class="line">      angle = <span class="built_in">this</span>.angle(</span><br><span class="line">        &#123; <span class="attr">X</span>: <span class="built_in">this</span>.data.startX,</span><br><span class="line">    <span class="attr">Y</span>: <span class="built_in">this</span>.data.startY</span><br><span class="line">    &#125;, &#123; <span class="attr">X</span>: moveX,</span><br><span class="line">    <span class="attr">Y</span>: moveY</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">    dataList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 这里相对参考代码做了精炼</span></span><br><span class="line"><span class="comment">// 判断三个条件：遍历到的item是当前滑动的块，角度小于30度，滑动到的x坐标小于开始的x坐标（向左），均满足则判断为左滑</span></span><br><span class="line">      <span class="keyword">if</span> (curIndex === index &amp;&amp; angle &lt; <span class="number">30</span> &amp;&amp; moveX &lt; <span class="built_in">this</span>.data.startX) &#123;</span><br><span class="line">        item.isTouchMove = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      item.isTouchMove = <span class="literal">false</span>; <span class="comment">//否则右滑</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">      dataList</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 计算滑动角度</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>start 起点坐标</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>end 终点坐标</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">angle</span>: <span class="function"><span class="keyword">function</span> (<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _X = end.X - start.X,</span><br><span class="line">      _Y = end.Y - start.Y</span><br><span class="line">    <span class="comment">//返回角度 /Math.atan()返回数字的反正切值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">360</span> * <span class="built_in">Math</span>.atan(_Y / _X) / (<span class="number">2</span> * <span class="built_in">Math</span>.PI);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除</span></span><br><span class="line">  <span class="function"><span class="title">deleteItem</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* 这里是具体删除item的方法 */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://marycly.github.io/%E5%85%B3%E4%BA%8E%E6%88%91%E5%A6%82%E4%BD%95%E8%89%B0%E9%9A%BE%E5%9C%B0%E5%9C%A8%E5%85%AC%E5%8F%B8%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E7%BD%AE%E9%A1%B6%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%EF%BC%88%E4%B8%80%EF%BC%89/%E4%BE%A7%E6%BB%91%E6%95%88%E6%9E%9C.gif" alt="侧滑效果"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本次实践对参考代码并非完全照搬，而是根据实际使用的需求进行了调整，且对代码中的一些地方做了精炼和改良，是充满自己的理解的。实际使用时，我的内容条其实是包装在自定义组件中，而函数全部通过triggerEvent发送到页面js，在页面中执行（因为需要对每条数据的isTouchMove做更改）。但为了方便理解，在本页中依然采用全部在同一个页面上操作的方法来完成。</p><p>实际工程中，接下来还有更多的坑。当然，这些都是大前端开发跨平台APP的苦果，仅仅是参考微信小程序中的运用的可以忽略（貌似要使用movable-view也不难，js部分不带变的）。欲知后事如何，且听下回分解。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;工程需求&quot;&gt;&lt;a href=&quot;#工程需求&quot; class=&quot;headerlink&quot; title=&quot;工程需求&quot;&gt;&lt;/a&gt;工程需求&lt;/h2&gt;&lt;p&gt;开发的应用：用微信小程序经由hera生成的跨平台移动端APP。&lt;/p&gt;
&lt;p&gt;在“收藏列表”的模块中，需要添加一个类似于微信/QQ对话列表，对每一条信息左滑可以置顶或删除的功能。&lt;/p&gt;
&lt;h2 id=&quot;方案参考&quot;&gt;&lt;a href=&quot;#方案参考&quot; class=&quot;headerlink&quot; title=&quot;方案参考&quot;&gt;&lt;/a&gt;方案参考&lt;/h2&gt;&lt;p&gt;由于公司的APP构建框架似乎无法显示微信的新组件movable-view，因此选用了网络上使用view组件来实现的方案。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/LiaoFengJi/article/details/105218664&quot;&gt;https://blog.csdn.net/LiaoFengJi/article/details/105218664&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="微信小程序" scheme="https://marycly.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序：灵活适配不同标题栏高度的设备的方法</title>
    <link href="https://marycly.github.io/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E7%81%B5%E6%B4%BB%E9%80%82%E9%85%8D%E4%B8%8D%E5%90%8C%E6%A0%87%E9%A2%98%E6%A0%8F%E9%AB%98%E5%BA%A6%E7%9A%84%E8%AE%BE%E5%A4%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://marycly.github.io/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%9A%E7%81%B5%E6%B4%BB%E9%80%82%E9%85%8D%E4%B8%8D%E5%90%8C%E6%A0%87%E9%A2%98%E6%A0%8F%E9%AB%98%E5%BA%A6%E7%9A%84%E8%AE%BE%E5%A4%87%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2021-08-14T15:40:07.000Z</published>
    <updated>2022-08-24T09:02:33.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工程需求"><a href="#工程需求" class="headerlink" title="工程需求"></a>工程需求</h2><p>开发的应用：用微信小程序经由hera生成的跨平台移动端App。</p><p>作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？</p><p>首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。</p><h2 id="方案参考"><a href="#方案参考" class="headerlink" title="方案参考"></a>方案参考</h2><p>在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。</p><p>私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：</p><span id="more"></span><h2 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h2><h3 id="大体思路如下："><a href="#大体思路如下：" class="headerlink" title="大体思路如下："></a>大体思路如下：</h3><p>在onLoad函数中使用微信小程序的SelectorQuery选取需要设置fixed的view，然后获取它的底部高度，再对需要设置absolute的内容组件的top样式进行渲染。</p><h3 id="主要代码："><a href="#主要代码：" class="headerlink" title="主要代码："></a>主要代码：</h3><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* page */</span></span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"><span class="attr">dAbsoluteTop</span>: <span class="number">0</span>, <span class="comment">//准备设置固定内容组件的高度</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">const</span> query = wx.createSelectorQuery();</span><br><span class="line">query.select(<span class="string">&#x27;#fixed-view&#x27;</span>).boundingClientRect();</span><br><span class="line">query.selectViewport().scrollOffset();</span><br><span class="line">query.exec(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">that.setData(&#123;</span><br><span class="line"><span class="attr">dAbsoluteTop</span>: res[<span class="number">0</span>].bottom <span class="comment">//根据底部渲染</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>index.wxml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;view id=&quot;fixed-view&quot; style=&quot;position: fixed; top: 0; display: flex; flex-direction: column;&quot;&gt;</span><br><span class="line">&lt;titlebar /&gt; &lt;!-- 标题栏 --&gt;</span><br><span class="line">&lt;tabbar /&gt; &lt;!-- 选择标签栏 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view style=&quot;position: absolute; top: &#123;&#123;dAbsolute&#125;&#125;;&quot;&gt;</span><br><span class="line">&lt;!-- 内容 --&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>经不同设备检验，效果良好。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;工程需求&quot;&gt;&lt;a href=&quot;#工程需求&quot; class=&quot;headerlink&quot; title=&quot;工程需求&quot;&gt;&lt;/a&gt;工程需求&lt;/h2&gt;&lt;p&gt;开发的应用：用微信小程序经由hera生成的跨平台移动端App。&lt;/p&gt;
&lt;p&gt;作为实习生在工作中遇到了这样的需求：需要顶部的标题栏和选择标签栏保持一直在窗口顶部（样式即top:0; position:fixed;），而其他的内容组件则可以随着页面滚动（样式即position:absolute;）。而我开发的小程序属于跨平台App，不知道公司的标题栏大小是如何设置的，总之会产生不同设备上标题栏高度不一的问题（尤其体现在微信小程序和hera生成的Android/IOS应用之间）。那么则需要解决一个问题，如何让absolute的内容组件自动贴着fixed的顶部组件生成呢？&lt;/p&gt;
&lt;p&gt;首先，对于需要分别设置不同position的组件，当然不能使用flex布局之类的进行自动黏贴。那么接下来的想法是想办法获取fixed部分的底部高度。&lt;/p&gt;
&lt;h2 id=&quot;方案参考&quot;&gt;&lt;a href=&quot;#方案参考&quot; class=&quot;headerlink&quot; title=&quot;方案参考&quot;&gt;&lt;/a&gt;方案参考&lt;/h2&gt;&lt;p&gt;在公司其他员工的代码中发现了这样的操作：在html页面中建立一个wxs脚本，运行时获取设备是否为Android，如果是则通过Android系统接口获取标题栏高度而进行对固定内容组件的top样式的渲染，否则就不要使用位置fixed。&lt;/p&gt;
&lt;p&gt;私以为，还能够用更优雅的代码和适配性更强的方案去解决这个问题，于是经过一番思考有了以下的方案：&lt;/p&gt;</summary>
    
    
    
    <category term="开发" scheme="https://marycly.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="微信小程序" scheme="https://marycly.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
